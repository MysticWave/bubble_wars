console.log('AssemblyVersion: 4');const USE_SECURITY = 0;const DEVELOPER_MODE = true;const ALLOW_COMMANDS = true;const VERSION = 'pre-Beta 1.0.0';class Main
{
	
	static LoadContent()
	{
		// this.RUNNING = RUNNING.LOADING;
		TextureManager.Load();
		SoundManager.Load();
		Style.Load();

		Loading.Run();
	}
	
	
	static Initialize()
	{
		if(typeof TREAT_AS_DATA !== 'undefined') return;
		
		this.Keys = {};
		this.lastKey = null;

		this.frameRenderTime = 0;
		
		this.FPS = 60;
		this.ageInTicks = 0;
		this.DELTA = 0;
		this.maxDelta = 1000 / this.FPS / 1000;
		this.lastTime = (new Date()).getTime();
		this.currentTime = 0;
		this.ShowHitbox = false;
		this.BorderLess = false;
		this.SaveSlot = 'PLAYER_SAVE_0';


		this.renderFullMap = false;
		this.UnlockMiniMap = false;


		this.CurrentInterface = null;

		
		Settings.Init();

		Mouse.Initialize();
		Graphic.Initialize();
		
		SoundManager.Initialize();
		
		Lang.Initialize(Settings.General.Lang);
		this.ItemHelper = ItemHelper;
		this.ItemHelper.Initialize();

		UI_Helper.Init();
		DialogGUI.Initialize();

		this.LoadContent();
		this.AddEventListeners();
		
		InterfaceControl.Initialize();
		DamageIndicator.Initialize();


		this.interval = 1000 / Main.FPS;
		this.performanceRenderTimes = [];

		Settings.Apply();

		ItemHelper.InitializeRecipes();


		// this.LOOP = setInterval(function(){Main.Update()}, this.interval);
		this.Update();
	}
	
	static AddEventListeners()
	{
		document.getElementById('game_container').addEventListener('contextmenu', function(e)
		{
			if(DEVELOPER_MODE && Main.lastKey?.toUpperCase() != 'CONTROL') e.preventDefault();
		});

		window.addEventListener('resize', Main.Resize);

		window.addEventListener("keydown", function(e){
			if(e.key == "Tab") e.preventDefault();
			Main.Keys[e.key] = true;
			Main.lastKey = e.key;
			Settings.Controls.Update(e.key, true);
		}, false);
		
		window.addEventListener("keyup", function(e){
			if(e.key == "Tab")
			{
				e.preventDefault();
			}
			Main.Keys[e.key] = false;
			Settings.Controls.Update(e.key, false);
		}, false);

		
		
		
		
		
		window.addEventListener('mousemove',function(e){
			var rect = document.getElementById('game_container').getBoundingClientRect();

			Mouse.absX = e.clientX;
			Mouse.absY = e.clientY;

			Mouse.x = (e.clientX- rect.left)  / Main.Scale;
			Mouse.y = (e.clientY - rect.top) / Main.Scale;

			if(World?.Player?.hand) InventoryGUI.UpdateHand(true);
		},false);

		Graphic.mainCanvas.addEventListener('mousedown',function(evt){	
			if(evt.button == 0) {		//lewy przycisk myszy
				Mouse.click = true;
			}
			
			if(evt.button == 2) {		//prawy przycisk myszy
				Mouse.rightClick = true;
			}
			
			Mouse.focus = this;
			
		},false);

		Graphic.mainCanvas.addEventListener('mouseover',function(evt){	
			Mouse.onCanvas = true;	
		},false);

		Graphic.mainCanvas.addEventListener('mouseout',function(evt){	
			Mouse.onCanvas = false;
		},false);

		window.addEventListener('mouseup',function(evt){
			Mouse.click = false;
			Mouse.rightClick = false;
			Mouse.lockClick = false;
			Mouse.lockRightClick = false;
			Mouse.lockHover = false;
		},false);

		window.addEventListener("beforeunload", function(e)
		{
			// if(Main.RUNNING == RUNNING.INGAME)
			// {
			// 	e = e || window.event;

			// 	// For IE and Firefox prior to version 4
			// 	if (e)
			// 	{
			// 		e.returnValue = 'Sure?';
			// 	}

			// 	// For Safari
			// 	return 'Sure?';
			// }
		});

	}

	static Resize()
	{
		var game_container = document.getElementById('game_container');
		var gameCanvas = document.getElementById('canvas');
		
		var ratio = gameCanvas.width / gameCanvas.height;
		var newWidth = window.innerWidth;
		var newHeight = window.innerHeight;
		var new_ratio = newWidth / newHeight;
		
		if (new_ratio > ratio) newWidth = newHeight * ratio;
		else newHeight = newWidth / ratio;
		
		// gameCanvas.width = newWidth;
		// gameCanvas.height = newHeight;
		
		game_container.style.width = newWidth + 'px';
		game_container.style.height = newHeight + 'px';
			
		game_container.style.marginTop = (-newHeight / 2) + 'px';
		game_container.style.marginLeft = (-newWidth / 2) + 'px';

		Main.Scale = newHeight / gameCanvas.height;
	}


	static isDesktopVersion()
	{
		return (typeof process !== 'undefined');
	}

	static Exit()
	{
		if(Main.isDesktopVersion()) process.exit();
	}

	
	static Update()
	{
		window.requestAnimationFrame(function(){Main.Update()});
		
		this.currentTime = (new Date()).getTime();
		this.DELTA = (this.currentTime-this.lastTime) / 1000;
		if(this.DELTA > this.maxDelta) this.DELTA = this.maxDelta;
		
		// Graphic.mainCtx.imageSmoothingEnabled = true;

		this.ageInTicks++;
		Mouse.cursor = 'default';
		
		SoundManager.Update();
		if(!Mouse.Disabled) InterfaceControl.Update();

		document.body.dataset.cursor = Mouse.cursor;
		document.body.dataset.mousedown = Mouse.click;
		
		this.Render();
		this.lastTime = this.currentTime;
	}
	
	
	static Render()
	{
		Graphic.Clear();
		
		InterfaceControl.Render();

		const now = performance.now();
		while (this.performanceRenderTimes.length > 0 && this.performanceRenderTimes[0] <= now - 1000)
		{
			this.performanceRenderTimes.shift();
		}
		this.performanceRenderTimes.push(now);


		if((this.RUNNING == RUNNING.INGAME) && Settings.General.showFPS)
		{
			ChangeLayer(Graphic.Layer.GUI);
			var fps = this.performanceRenderTimes.length;
			fps = (fps > this.FPS) ? this.FPS : fps;

			var style = Style.GetStyleByName('MenuInfo');
				style.textAlign = 'right';

			Style.FillText(ctx, {style: style}, 'FPS: ' + fps, canvas.width - 15, 5);
		}

		Graphic.Render();
	}
}
	/*
window.gamepads = {};

	function gamepadHandler(event, connecting) {
	  var gamepad = event.gamepad;
	  // Note:
	  // gamepad === navigator.getGamepads()[gamepad.index]

	  if (connecting) {
		gamepads[gamepad.index] = gamepad;
	  } else {
		delete gamepads[gamepad.index];
	  }
	}

	window.addEventListener("gamepadconnected", function(e) { gamepadHandler(e, true); }, false);
	window.addEventListener("gamepaddisconnected", function(e) { gamepadHandler(e, false); }, false);
		*/class AI
{
	constructor()
	{
		this.actions = [];
	}


	/**
	 * Apply AI to entity`s AI list.
	 * @param {Class} ai AI to be apllied.
	 */
	Apply(ai, override = false)
	{
		if(override && this[ai.name])
		{
			this[ai.name] = ai;
			return;
		}
		
		this.actions.push(ai.name);
		this[ai.name] = ai;
	}
	
	/**
	 * Delete specific AI from entity`s AI list.
	 * @param {String} name Name of AI
	 */
	Delete(name)
	{
		delete this[name];
		for(var i = 0; i < this.actions.length; i++)
		{
			if(this.actions[i] == name)
			{
				this.actions.splice(i, 1);
				break;
			}
		}
	}
	
	Update(owner)
	{
		for(var i = 0; i < this.actions.length; i++)
		{
			var ai = this[this.actions[i]];
			if(!ai) continue;
			if(owner.lockAI && !owner.unlockAI?.includes(ai.name)) continue;
			if(ai.passive) continue;
			if(owner.isStunned && !ai.ignoreStuns) continue;

			ai.Update(owner);
		}
	}
}class Effect
{
	constructor(strength, time, hideParticles)
	{
		this.ageInTicks = 0;
		this.Strength = strength;
		this.Time = time * Main.FPS;
		this.hideParticles = hideParticles;

		this.durationPercent = 0;
		this.keepStrongest = true;
		this.Icon = null;
		this.toClear = false;
		this.showIcon = true;

		this.Owner
	}

	getId()
	{
		return this.constructor.name.toUpperCase();
	}

	Update(owner, effects)
	{
		this.Owner = owner;
		this.ageInTicks++;
		this.durationPercent = (this.ageInTicks / this.Time) * 100;
		
		if(this.showIcon) owner.UpdateCooltime?.(this.getId(), this.ageInTicks, this.Time, this.Icon, true);

		if(this.ageInTicks >= this.Time)
		{
			this.toClear = true;
			return;
		}
	}

	Render(context, owner){}
	onApply(owner){}
	onClear(){}
}




class Effects
{
	constructor()
	{
		this.effectList = {};
	}

	static GetEffect(name)
	{
		return this.EffectsList[name.toUpperCase()];
	}

	static Initialize(effect)
	{
		var keyWord = "Effect_";
		var name = effect.name.replace(keyWord, "").toUpperCase();
		this.EffectsList = this.EffectsList || {};

		this.EffectsList[name] = effect;
	}


	GetActiveEffectById(id)
	{
		id = id.toUpperCase();
		
		for(var effectName in this.effectList)
			if(effectName.toUpperCase() == id) return this.effectList[effectName];
	}

	Apply(effect, owner)
	{
		if(this.effectList[effect.constructor.name] && effect.keepStrongest)
		{
			var current = this.effectList[effect.constructor.name];
			if(current.Strength > effect.Strength) return;
		}

		this.effectList[effect.constructor.name] = effect;
		effect.onApply(owner);
	}

	Clear(effect)
	{
		if(isString(effect)) effect = this.effectList[Effects.GetEffect(effect).name];
		if(!effect) return;
		
		effect.onClear();
		delete this.effectList[effect.constructor.name];
		effect.Owner.UpdateCooltime?.(effect.getId(), 1, 1, effect.Icon, true);
	}

	Update(owner)
	{
		for(var effectName in this.effectList)
		{
			var effect = this.effectList[effectName];

			effect.Update(owner, this);
			if(effect.toClear) this.Clear(effect)
		}
	}

	Render(context, owner)
	{
		for(var effectName in this.effectList)
		{
			var effect = this.effectList[effectName];

			effect.Render(context, owner);
		}
	}
}class Entity
{
	constructor(x = 0, y = 0)
	{
		this.x = x;
		this.y = y;
		this.lastPos = {x: x, y: y};
		this.width = 64;
		this.height = 64;
		this.ageInTicks = 0;
		this.Scale = 1;
		this.additionalScaleMultiplier = 1;
		this.Rotation = 0;
		this.defaultRotation = 0;
		this.TextureRotation = 0;
		this.Origin = {x: 0, y: 0};
		this.TextureData = {};

		this.Hands = null;
		this.Transparency = 1;
		this.Model = null;
		this.isBouncing = false;
		this.Bounce = false;
		this.bounceTimes = 0;
		this.bounceTime = 2;
		this.isHurtAble = true;
		this.isAggressive = false;
		this.isAggressiveOnHurt = false;
		this.aggressive = false;
		this.isNPC = false;
		this.quote = null;
		this.description = '';

		this.maxCollisionStep = 20;
		
		this.level = 0;
		this.oxygen = null;
		this.oxygenMultiplier = 1;
		
		this.moveX = 0;
		this.moveY = 0;
		
		this.AI = new AI(this);
		this.NoAI = false;
		this.lockAI = false;
		this.unlockAI = '';
		this.preRenderFunctions = [];
		this.onRenderFunctions = [];

		this.Effects = new Effects();

		this.MAXHP = 1;
		this.AD = 0;
		this.SPD = 0;
		this.ATTACK_RANGE = 0;
		this.ATTACK_SPEED = 0;
		this.BULLETS_COUNT = 0;
		this.BULLET_SERIES = 0;
		this.BULLET_SPEED = 0;

		this.HP = this.MAXHP;

		this.lockMove = 
		{
			Top: false,
			Down: false,
			Right: false,
			Left: false
		};

		//calkowita odpornosc na dany zywiol
		this.Immunity = {};

		//slabosc na dany zywiol (2x obrazenia)
		this.Weakness = {};

		//odpornosc na zywiol (2x mniejsze obrazenia)
		this.Resistance = {};

		for(var name in ELEMENT)
		{
			this.Immunity[name] = false;
			this.Weakness[name] = false;
			this.Resistance[name] = false;
		}
		this.knockBackResistance = 0;
		this.canBeKnockedBack = true;

		this.lastHurtBy = null;

		this.DeathSound = "";
		this.HurtSound = "";
		this.LivingSound = "";
		this.moveParticle = null;
		this.moveParticleDelay = 5;
		this.moveParticleDiff = MathHelper.randomInRange(0, this.moveParticleDelay);

		this.isAlive = true;
		this.LootTable = new LootTable();
		
		this.HitBox = new HitBox();
		this.advancedHitBox = [];
		this.allowMove = true;

		this.Color = null;
		this.coloredTexture = {color: null, texture: null};
		this.showHpBar = true;
		this.alwaysRenderHpBar = false;
		this.showDamageReceived = true;

		this.allowRotationChange = true;

		this.RenderTransitions = {};
		this.UpdateTransitions = {};

		this.dropLoot = true;
		this.dropOxygen = true;

		this.Tier = 0;
		this.Slow = 0;

		this.isHidden = false;

		this.isPoisoned = false;
		this.ignoreBorder = false;
		this.killOnBorderOut = true;
		this.isStunned = false;

		this.invincibleScale = 1;
		this.lightRadius = 0;

		this.heartDropChance = 5;
		this.heartDropValue = 1;

		this.mustBeKilled = true;		//this entity has to be killed to clear room

		this.setScale(1);
	}

	static GetAvailableTargets(owner, distance = owner.ATTACK_RANGE)
	{
		for(var i in World.Entities)
		{
			var e = World.Entities[i];
			if(!e.isOnScreen) continue;
			if(e.isFromPlayer) continue;
			if(e instanceof Oxygen) continue;
			if(e.isNPC) continue;
			if(!e.isHurtAble) continue;

			if(MathHelper.GetDistance([e.x, e.y], [owner.x, owner.y]) <= distance) return e;
		}
	}

	onHeal(){}
	Heal(amount, percent = false, showIndicator = true)
	{
		if(percent) amount = Math.ceil(this.MAXHP * amount / 100);
		var healed = amount;

		if(this.HP >= this.MAXHP) return;

		this.HP += amount;
		if(this.HP > this.MAXHP)
		{
			healed -= (this.MAXHP - this.HP);
			this.HP = this.MAXHP;
		}

		if(showIndicator) DamageIndicator.AddObject(this.x, this.y, healed, "HEAL");
		this.onHeal();
	}

	onSummon(){}

	getSPD()
	{
		return this.SPD * ((100-this.Slow) / 100);
	}

	getId()
	{
		return this.constructor.name.toUpperCase();
	}

	getDisplayName()
	{
		if(this.displayName) return Lang.Get(this.displayName);
		if(this.name) return Lang.Get(this.name);
		return null;
	}

	getDescription()
	{
		return Lang.Get(this.description);
	}

	getOxygen()
	{
		if(this.oxygen != null) return this.oxygen;
		return this.level * 3 * this.oxygenMultiplier;
	}

	setLevel(level)
	{
		if(this.level) return;
		this.level = level;
		if(this.isBoss) this.level += 3;
		else this.level += this.Tier;
	}

	gotAI(id)
	{
		if(this.AI[id]) return true;
		return false;
	}

	setScale(new_scale)
	{
		this.baseScale = new_scale;
		this.Scale = new_scale;
	}

	Update()
	{
		this.isBouncing = false;
		this.ageInTicks++;

		for(var name in this.UpdateTransitions)
		{
			set(this, name, this.UpdateTransitions[name].Update(), true);
		}

		this.Width = this.width;
		this.Height = this.height;

		if(!this.NoAI)
		{
			this.AI.Update(this);
		}	
		this.Effects.Update(this);

		this.CheckCollisions();

		var distanceFromLastPosition = MathHelper.GetDistance([this.x, this.y], this.lastPos);
		if(distanceFromLastPosition > this.maxCollisionStep && this.ageInTicks > 1)
		{
			var steps = Math.ceil(distanceFromLastPosition / this.maxCollisionStep);
			var moveX =  this.x - this.lastPos.x;
			var moveY =  this.y - this.lastPos.y;

			var x = this.x;
			var y = this.y;

			for(var i = 1; i <= steps; i++)
			{
				if(!this.isAlive) break;
				this.x = this.lastPos.x + (moveX * (i / steps));
				this.y = this.lastPos.y + (moveY * (i / steps));

				this.CheckCollisions();
			}

			this.x = x;
			this.y = y;
		}

		
		if(this.isAggressive) this.aggressive = true;
		
		if(this.isHurtAble && this.HP <= 0)
		{
			this.Kill();
			return;
		}

		if(this.isBoss) if(isFunction(this.onBossUpdate)) this.onBossUpdate();

		this.HitBox.Update(this);
		for(var i in this.advancedHitBox)
		{
			this.advancedHitBox[i].Update(this);
		}

		if(this.Model)
		{
			this.Model.Update();
		}
		this.allowMove = true;
		this.disableObserve = false;
		this.allowFollow = true;

		this.lastPos = {x: this.x, y: this.y};
	}

	isLeavingBorder()
    {
        var dist = MathHelper.GetDistance(this, World.CenterPoint);
        var next_dist = MathHelper.GetDistance([this.x + this.moveX, this.y+this.moveY], World.CenterPoint);

        return dist < next_dist;
    }

	CheckCollisions()
	{
		Collision.Check(this);

		var distance = MathHelper.GetDistance([this.x, this.y], [World.CenterPoint.x, World.CenterPoint.y]);
		if(distance >= World.Radius && this.isLeavingBorder()) this.onCollision?.();
		if(this.killOnBorderOut && distance > World.Radius * 1.5) 
		{
			this.Kill();
		}

		var player = World.Player;
		if(Collision.AreColliding(player, this))
		{
			if(isFunction(this.onPlayerCollision))
			{
				this.onPlayerCollision(player);
			}
			
			if(this.AI.AttackMelee)
			{
				this.AI.AttackMelee.Hurt(this, player);
			}
		}

		if(this instanceof ProjectileLaserBeam)
		{
			this.checkForCollision(player);
		}



		if(isFunction(this.onEntityCollision) || (this.AI.AttackMelee && this.isFromPlayer))
		{
			for(var i = 0; i < World.Entities.length; i++)
			{
				var entity = World.Entities[i];

				//pomija sprawdzanie kolizji miedzy tlenkami
				if(entity instanceof Oxygen) continue;
				if(entity == this) continue;

				if(this instanceof ProjectileLaserBeam)
				{
					this.checkForCollision(entity);
					continue;
				}

				if( (this instanceof Projectile) && !this.lockApplyMove && this.followRange)
				{
					//tylko pociski gracza moga naprowadzac sie na przeciwnikow
					if(this.source instanceof Player)
					{
						if(!this.piercedEntities.includes(entity))
						{
							if(MathHelper.isInRange(this, entity, this.followRange))
							{
								var motion = Motion.Get(this, entity, this.spd);
								this.Rotation = motion.angle + 90;
								this.lockApplyMove = true;
								// this.ApplyMove(motion);
								this.moveX = motion.x;
								this.moveY = motion.y;
							}
						}
					}
				}

				if(Collision.AreColliding(entity, this))
				{
					this.onEntityCollision?.(entity);
					
					if(this.AI.AttackMelee) 
					{
						this.AI.AttackMelee.Hurt(this, entity);
					}

					//przerywa petle jesli byt juz umarl
					if(!this.isAlive) break;
				}
			}
		}
	}

	RenderHpBar(context)
	{
		var percent = this.HP / this.MAXHP;
		if(percent == 1 && !this.alwaysRenderHpBar) return;

		var size = 2;
		var width = this.Width * this.Scale;
		var height = 8;

		var x = this.x - Camera.xView - (width / 2);
		var y = this.y - Camera.yView - (this.Height / 2 * this.Scale) - height - 5;	

		var color = (this.isPoisoned) ? '#02fa40' : 'red';
		context.save();
		context.fillStyle = color;
		context.strokeStyle = 'white';
		context.lineWidth = size;
		Graphic.roundRect(ctx, x - (size / 2), y - (size / 2), (width * percent) + size, height + size, height, true, false);
		Graphic.roundRect(ctx, x - (size / 2), y - (size / 2), width + size, height + size, height, false, true);
		context.restore();
	}

	Render(context)
	{
		if(this.isHidden) return;
		if(this.additionalScaleMultiplier <= 0) this.additionalScaleMultiplier = 1;

		for(var i in this.preRenderFunctions)
		{
			this.preRenderFunctions[i](context, this);
		}
		
		for(var name in this.RenderTransitions)
		{
			var value = this.RenderTransitions[name].Update();
			if(name == 'Scale') value *= this.baseScale * this.additionalScaleMultiplier ?? this.Scale * this.additionalScaleMultiplier;

			set(this, name, value, true);
		}

		if(!this.RenderTransitions.Scale)
		{
			this.Scale = this.baseScale * this.additionalScaleMultiplier;
		}

		

		if(this.moveParticle)
		{
			var spd = MathHelper.GetMovementSpeed(this.moveX, this.moveY);
			if(spd >= 350)
			{
				if((this.ageInTicks - this.moveParticleDiff) % this.moveParticleDelay == 0)
				{
					var x = this.x + (this.width / 4 * this.Scale);
					var y = this.y + (this.height / 4 * this.Scale);


					Particle.SummonCirclePattern(this.moveParticle, x, y, 0.4, 2, 1, 11, null, null, false, 10, {Rotation: this.Rotation});
				}
			}
		}

		if(this.Model)
		{
			this.Model.Render(context);
		}
		else
		{
			if(this.Color)
			{
				if(this.coloredTexture.color != this.Color.toString())
				{
					if(this.Color == 'none') this.coloredTexture.texture = TextureManager.Get(this.Texture);
					else this.coloredTexture.texture = Graphic.ApplyMask(TextureManager.Get(this.Texture), this.Color);

					this.coloredTexture.color = this.Color.toString();
					this.coloredTexture.src = this.Texture;
				}
			}

			if(!this.coloredTexture.texture)
			{
				this.coloredTexture.texture = TextureManager.Get(this.Texture);
			}

			if(this.coloredTexture.src != this.Texture)
			{
				this.coloredTexture.color = 'none';
				this.coloredTexture.texture = TextureManager.Get(this.Texture);
				this.coloredTexture.src = this.Texture;
			}

			if(this.Hands) this.RenderHands(context);
			this.RenderTexture(context);
		}

		this.HitBox.Render();
		for(var i in this.advancedHitBox)
		{
			this.advancedHitBox[i].Render();
		}
		
		if(this.isHurtAble && this.showHpBar)
		{
			this.RenderHpBar(context);
		}

		if(this.quote)
		{
			this.style = Style.GetDefault();
			this.style.textAlign = 'center';
			Style.FillText(context, this, this.quote, this.x - Camera.xView, this.y - ((this.height / 2) * this.Scale) - 10  - Camera.yView, null, null, this.Transparency);
		}

		if(this.isBoss)
		{
			if(isFunction(this.onBossRender)) this.onBossRender();
		}

		for(var i in this.onRenderFunctions)
		{
			this.onRenderFunctions[i](context, this);
		}

		this.Effects.Render(context, this);

		if(this.lightRadius) Graphic.addLightSource(this.x - Camera.xView, this.y - Camera.yView, this.lightRadius*this.Scale);
	}

	RenderHands(context)
	{
		var hands = this.Hands;
		var handY = this.HandMove?.Update() ?? 0;

		for(var i = 0; i < hands.length; i++)
		{
			var hand = hands[i];
			var texture = TextureManager.Get(hand[0]);
			var tX = hand[1] ?? 0;
			var tY = hand[2] ?? 0;
			var width = hand[3] ?? 32;
			var height = hand[4] ?? 32;
			var rotation = hand[5] ?? 0;

			if(this.moveX != 0 || this.moveY != 0)
			{
				if(i%2 == 0) tY += handY*height;
				else tY -= handY*height;
			}

			context.save();
			context.translate(this.x - Camera.xView, this.y - Camera.yView);
			context.rotate((this.Rotation + rotation) * Math.PI/180);
			context.globalAlpha = this.Transparency;
			context.drawImage(
				texture, 0, 0, texture.width, texture.height,
				-((this.width / 2) + tX) * this.Scale, -((this.height / 2) + tY) * this.Scale,
				(width * this.Scale), (height * this.Scale)
			);
			context.restore();
		}
	}

	RenderTexture(context)
	{
		var texture = this.coloredTexture.texture;

		// context.save();
		// context.translate(this.x - Camera.xView, this.y - Camera.yView);
		// context.rotate((this.Rotation + this.TextureRotation) * Math.PI/180);
		// context.globalAlpha = this.Transparency;
		// context.drawImage(
		// 	texture, 0, 0, texture.width, texture.height,
		// 	-(this.width / 2 + this.Origin.x) * this.Scale, -(this.height / 2 + this.Origin.y) * this.Scale,
		// 	(this.width * this.Scale), (this.height * this.Scale)
		// );
		// context.restore();

        var x = this.x - Camera.xView;
        var y = this.y - Camera.yView;
        var height = this.height;
        var width = this.width;

        var rotation = this.Rotation + this.TextureRotation;
        var scale = this.Scale;
        var alpha = this.Transparency;

		var frame = this.TextureData.frame ?? 0;
		var frames = this.TextureData.frames ?? 1;
		var direction = this.TextureData.direction ?? 'Y';


		Graphic.DrawRotatedAnimatedImage(context, frame, frames, direction, 
            texture, x, y, width, height, scale, rotation, alpha, this.Origin.x, this.Origin.y);
	}
	
	/**
	 * 
	 * @param {Number} damage Amount of damage to deal.
	 * @param {Entity} source Entity which hurt this.
	 */
	Hurt(damage, source, data)
	{
		if(!this.isHurtAble) return;
		if(this.isInvincible) return;
		if(damage == 0) return;

		var type = data.ELEMENT;


		if(this.Resistance[type]) damage = Math.floor(damage / 2);
		if(this.Weakness[type]) damage *= 2;
		if(this.Immunity[type]) damage = 1;
		if(this.DefBreak) damage = Math.ceil(damage * (100 + this.DefBreak) / 100);

		
		this.lastHurtBy = source;

		if(isFunction(this.onHurt))
		{
			if(this.onHurt()) return;
		}

		if(this.isAggressiveOnHurt) this.aggressive = true;
		
		SoundManager.Play(this.HurtSound, "EFFECT");
		this.HP -= Math.round(damage);

		if(data.isCritical) Camera.Shake(5);
		else Camera.Shake(0.5);

		if(Settings.General.ShowDamageDealt && this.showDamageReceived)
		{
			DamageIndicator.AddObject(this.x, this.y, damage, "DEALT", null, data.isCritical);
		}

		if(this.HP <= 0) this.Kill();
	}

	ApplyMove(motion)
	{
		if(motion)
		{
			this.x += motion.x * Main.DELTA;
			this.y += motion.y * Main.DELTA;
		}
	}

	isMoving()
	{
		if(!this.allowMove) return false;
		if(this.moveX || this.moveY) return true;
		return false;
	}

	onKill(){return;}
	
	Kill()
	{
		if(this.lastHurtBy === World.Player)
		{
			//zostal zabity przez gracza
			if(this.isBoss)
			{
				World.Player.RunStats.defeatedBosses++;
			}
			else
			{
				World.Player.RunStats.defeatedEnemies++;
			}
		}


		this.isAlive = false;
		this.onKill();

		if(this.isBoss)
		{
			if(this.AI.Boss)
			{
				this.AI.Boss.onDeath(this);
			}
		}

		var oxygen = this.getOxygen();
		if(oxygen && this.dropOxygen) 
		{
			World.AddEntity(new Oxygen(this.x, this.y, oxygen, this.level, false, this.isBoss));

			if(MathHelper.GetChance(this.heartDropChance))
			{
				World.AddEntity(new Oxygen(this.x, this.y, this.heartDropValue, 1, true));
			}
		}

		if(this.LootTable && this.dropLoot)
		{
			var item = this.LootTable.GetItem();
			if(item)
			{
				World.AddEntity(new EntityItem(item, this.x, this.y));
			}
		}

		QuestList.CheckEntityDeath(this);

		SoundManager.Play(this.DeathSound, "EFFECT", this);
		
		if(!this.isAlive) World.Kill(this);
	}
}class EntityItem extends Entity
{
	constructor(item, x, y, dirX = 1)
	{
		super(x, y);

		this.width = 64;
		this.height = 64;
		this.PickUpDelay = 2 * Main.FPS;
		this.isHurtAble = false;
		this.Visible = true;
		this.value = 1;

		this.item = item;
		this.Texture = item.Texture;
		this.item.showNewItemInfo = true;
		this.Scale = 0.5;
		this.dirX = dirX;

		this.onPlayerCollision = function(player)
		{
			if(this.ageInTicks > this.PickUpDelay)
			{
				if(this.hover) ItemInfo.Hide();
				this.item.Pick(player, this);
				this.item = null;
			}
		};

		this.SPD = 350;
		this.FOLLOW_RANGE = 50;
		this.AI.Apply(new AI_Follow(World.Player));
		this.AI.Apply(new AI_Walk());


		if(dirX == -1)
		{
			this.x -= this.width * this.Scale;
		}

		this.fX = function(x, p, q)
		{
			return 0.125 * ((x - p) * (x - p)) + q;
		};

		this.throwDistance = 40;
		this.p = this.x + ((this.throwDistance / 2) * this.dirX);
		this.q = this.y - 60;
		

		this.alphaTransition = new Transition(0.2, 1, 0.15, true, 0.02, 0.02);
		this.yTransition = new Transition(1, 10, 1.5, true, 0.1, 0.1);
		this.HitBox = new HitBox();
		this.HitBox.Scale = 1.75;

		this.AI.Apply(new AI_MouseEvents());
	}

	Update()
	{
		super.Update();

		if(this.ageInTicks < this.throwDistance)
		{
			this.x += this.dirX;
			this.y = this.fX(this.x, this.p, this.q);
		}

		if(this.ageInTicks < this.PickUpDelay) this.NoAI = true;
		else this.NoAI = false;

		if(this.hover && this.item) 
		{
			ItemInfo.Hide();
			ItemInfo.Show(this.item, null, null, null, true);
		}
		else if(this.lastHover) ItemInfo.Hide();

		this.lastHover = this.hover;
	}

	Render()
	{
		var alpha = 1;
		if(this.ageInTicks < this.PickUpDelay)
		{
			alpha = this.alphaTransition.Update();
		}

		if(this.Visible)
		{
			var scale = this.Scale * this.item.onFloorScale;
			var y = this.y - Camera.yView - (this.height * scale / 2);
			var x = this.x - Camera.xView - (this.width * scale / 2);

			if(this.ageInTicks > this.throwDistance + 10)
			{
				y += this.yTransition.Update();
			}


			ctx.save();
			ctx.globalAlpha = alpha;
			ctx.drawImage(TextureManager.Get(this.Texture), x, y, this.width * scale, this.height * scale);
			ctx.restore();

			this.item.DrawShine(x + (15 * scale), y + (15 * scale), scale);


			if(this.item?.showInBubble)
			{
				ctx.save();
				ctx.globalAlpha = alpha - 0.15;
				var sc = 0.2;
				ctx.drawImage(TextureManager.Get("bubble"), x- this.width * sc, y - this.height * sc, this.width * (scale + 2 * sc), this.height * (scale + 2 * sc));
				ctx.restore();
			}

			// if(this.hover)
			// {
			// 	// var grade = Lang.Get(this.item.Grade) +' ';
			// 	// var color = 'white';

			// 	// if(this.item.Grade == GRADE.NORMAL) grade = '';
			// 	// else 
			// 	// {
			// 	// 	color = getCssVariable(document.body, '--color-grade-'+this.item.Grade.toLowerCase());
			// 	// }
			// 	// var name = "[" + grade + ItemInfo.GetItemName(this.item).name + "]";

			// 	// Style.FillText(ctx, this, name, Mouse.x, Mouse.y, color);

			// 	// ItemInfo.Hide();
			// 	console.log('show');
			// 	ItemInfo.Show(this.Item);
			// }
			// else if(this.lastHover) ItemInfo.Hide();

			// this.lastHover = this.hover;

			var r = this.HitBox.Radius || this.HitBox.Width / 2;
			Graphic.addLightSource(this.x - Camera.xView, this.y - Camera.yView, r * 2);

			this.HitBox.Render();
		}
	}
}class Obstacle extends Entity
{
	constructor(x, y, stats)
	{
		super(x, y);
        this.canBeKnockedBack = false;
        this.showHpBar = false;

		this.knockBack = 1;
        this.knockBackTime = 5/60;
        this.isObstacle = true;
        this.blockPierce = true;

        this.Immunity.ALL = true;
		this.setStats(stats);

        this.setScale(10);
	}

	onPlayerCollision(player)
	{
        if(this.knockBack)
        {
            var spd;
            var angle = MathHelper.getAngle2([player.x, player.y], [this.x, this.y]);
            if(player.isDashing || (player.ageInTicks - player.dashEnd < 5)) spd = player.GetSPD() * player.stats[STAT.DASH_DISTANCE];
            else spd = MathHelper.GetMovementSpeed(player.velocityX, player.velocityY);
            
            var strength = (spd / 300) * 1.1;
            if(strength < .1) strength = 5;

            ApplyEffect(player, 'KnockBack', this.knockBack * strength, this.knockBackTime, angle-180);
        }
	}
		
	onEntityCollision(entity)
	{
		if(this.knockBack)
        {
            var angle = MathHelper.getAngle2([entity.x, entity.y], [this.x, this.y]);
            var spd = MathHelper.GetMovementSpeed(entity.moveX, entity.moveY);
            var strength = (spd / 300) * 1.1;

            ApplyEffect(entity, 'KnockBack', this.knockBack * strength, this.knockBackTime, angle-180);
        }
	}

	setStats(stats)
	{
		if(!stats) return;

		for(var property in stats)
		{
			this[property] = stats[property];
		}
	}

    Hurt()
    {
        return;
    }
}class Projectile extends Entity
{
	constructor(x, y, stats)
	{
		super(x, y);
		this.moveX = 0;
		this.moveY = 0;
		this.Texture = "bullet.bubble.base";
		
		this.width = 0;
		this.height = 0;
		
		this.source = null;
		this.target = null;
		this.dontDespawnTime = 9999999999;
		this.timeToDespawn = this.dontDespawnTime;
		this.from = {x: null, y: null};

		this.isHurtAble = false;
		this.damage = 1;
		this.criticalChance = 0;
		this.criticalDamage = 0;
		this.hurtEntities = false;
		this.Pierce = 0;
		this.pierceTimes = 0;
		this.piercedEntities = [];
		this.knockBack = 1;
		this.knockOnPierce = false;
		this.spd = 0;
		

		this.followRange = 0;
		this.followSPD = 350;
		this.followTimes = 0;
		this.followTime = 5;
		this.missed = true;
		this.element = ELEMENT.PHYSICAL;

		this.killOnBorderHit = true;

		this.canBeLightSource = true;
		this.moveParticle = "bulletParticle";
		
		this.setStats(stats);

		
		var texture = TextureManager.Get(this.Texture);
		if(texture)
		{
			if(!this.width) this.width = texture.width;
			if(!this.height) this.height = texture.height;
		}

		this.timeSinceVectorChange = Main.FPS * 2;
		this.onPlayerCollisionEffects = [];
		this.onEntityCollisionEffects = [];

		this.playerEffectChance = 100;
		this.entityEffectChance = 100;
	}


	onCollision()
	{
		if(this.Bounce) this.isBouncing = true;

		if(!this.Bounce && this.killOnBorderHit) this.Kill();
	}

	getDamageData()
	{
		var data = {damage: 0, isCritical: false, ELEMENT: this.element};
		var damage = this.damage;
		if(isNaN(this.damage))
		{
			damage = MathHelper.randomInRange(this.damage.min, this.damage.max);
		}

		if(this.criticalChance)
		{
			if(MathHelper.GetChance(this.criticalChance))
			{
				damage *= (100 + this.criticalDamage) / 100;
				data.isCritical = true;
			}
		}

		data.damage = damage;

		return data;
	}
	
	onPlayerCollision(player)
	{
		if( (player.canBeHurt()) && !(this.source instanceof Player))
		{
			var data = this.getDamageData();

			if(this.Pierce)
			{
				if(!this.piercedEntities.includes(player))
				{
					this.pierceTimes++;
					this.piercedEntities.push(player);
					player.Hurt(data.damage, this.source, data);
				}
				else
				{
					return;
				}
			}
			else
			{
				player.Hurt(data.damage, this.source, data);
				this.Kill();
			}

			if(this.knockBack && (!this.Pierce || this.knockOnPierce))
			{
				var angle = MathHelper.getAngle2([this.x, this.y], [this.x+this.moveX, this.y+this.moveY]);
				ApplyEffect(player, 'KnockBack', this.knockBack, .2, angle);
			}

			for(var i in this.onPlayerCollisionEffects)
			{
				if(!MathHelper.GetChance(this.playerEffectChance)) continue;

				var e = this.onPlayerCollisionEffects[i];
				ApplyEffect(player, e[0], e[1], e[2], e[3]);
			}
		}
	}
		
	onEntityCollision(entity)
	{
		//projectiles from player cannot collide with player`s entities
		if(entity.isFromPlayer && this.source == World.Player) return;

		this.missed = false;
		if( (entity.isHurtAble) && ((World.Player === this.source) || this.hurtEntities || entity.isFromPlayer))
		{
			var data = this.getDamageData();

			if(this.Pierce)
			{
				if(!this.piercedEntities.includes(entity))
				{
					this.pierceTimes++;
					this.piercedEntities.push(entity);
					entity.Hurt(data.damage, this.source, data);

					if(entity.blockPierce || entity.isObstacle) return this.Kill();

					if(this.Item && this.MP) this.Item.currentMP += this.MP;
				}
				else
				{
					if(entity.blockPierce || entity.isObstacle) return this.Kill();
					return;
				}
			}
			else
			{
				entity.Hurt(data.damage, this.source, data);
				if(this.Item && this.MP) this.Item.currentMP += this.MP;
				
				this.Kill();
			}

			if(this.knockBack && (!this.Pierce || this.knockOnPierce))
			{
				var angle = MathHelper.getAngle2([this.x, this.y], [this.x+this.moveX, this.y+this.moveY]);
				ApplyEffect(entity, 'KnockBack', this.knockBack, .2, angle);
			}

			for(var i in this.onEntityCollisionEffects)
			{
				if(!MathHelper.GetChance(this.entityEffectChance)) continue;

				var e = this.onEntityCollisionEffects[i];
				ApplyEffect(entity, e[0], e[1], e[2], e[3]);
			}
		}	
	}

	setStats(stats)
	{
		if(!stats) return;

		for(var property in stats)
		{
			this[property] = stats[property];
		}


		this.setScale(this.Scale);
	}
	
	static Types(type)
	{
		if(type)
		{
			if(!this.types) this.types = {};
			var p = new type();
			this.types[p.constructor.name] = type;
		}
		else
		{
			return this.types;
		}
	}
	
	Shoot(source, target)
	{
		if(source && target)
		{			
			this.source = source;
			this.target = target;
			
			// var endX = target.x - Camera.xView;
			// var endY = target.y - Camera.yView;
			
			// if(target === Mouse)
			// {
			// 	endX = target.x;
			// 	endY = target.y + 7.5;
			// }
			
			var spd = this.spd || 10;

			var angle = MathHelper.getAngle2([this.x, this.y], [target.x, target.y]);
			var end = MathHelper.lineToAngle([this.x, this.y], spd, angle);

			this.from = {x: this.x, y: this.y};
			
			this.moveX = end.x - this.x;
			this.moveY = end.y - this.y;
			
			this.Rotation = angle + 90;

			this.onShoot();
			super.Update();
		}
	}
	
	Update()
	{
		this.x += this.moveX * Main.DELTA;
		this.y += this.moveY * Main.DELTA;
		this.lockApplyMove = false;

		super.Update();

		if(!this.lockApplyMove && this.followRange)
		{
			//tylko pociski przeciwnikow moga naprowadzac sie na gracza
			if(this.source instanceof Entity)
			{
				if(MathHelper.isInRange(this, player, this.followRange))
				{
					var motion = Motion.Get(this, player, this.followSPD);
					this.followTimes++;
					this.Rotation = motion.angle + 90;
					this.lockApplyMove = true;
					this.moveX = motion.x;
					this.moveY = motion.y;
				}
			}
		}
		
		this.timeSinceVectorChange++;
		
		if((this.isBouncing) && (this.timeSinceVectorChange > 3))
		{
			if(this.Pierce)
			{
				//po odbiciu moze ponownie uderzyc obiekty
				this.piercedEntities = [];
			}
			this.bounceTimes++;
			this.onBounce();

			this.timeSinceVectorChange = 0;

			var distX = (this.x - World.CenterPoint.x);
            var distY = (this.y - World.CenterPoint.y);
            if(distX == 0) this.moveY *= -1;
            if(distY == 0) this.moveX *= -1;

            if(distX == 0 || distY == 0) 
            {
                if(this.allowRotationChange) this.Rotation -= 180;
                return;
            }


			var prev = 
			[
				this.x - (this.moveX / 10),
				this.y - (this.moveY / 10)
			];

			var a1 = (this.y - World.CenterPoint.y) / (this.x - World.CenterPoint.x);
			var b1 = -(a1 * this.x) + this.y;

			var a2 = - (1 / a1);
			var b2 = -(a2 * prev[0]) + prev[1];

			var crossPoint = [];
			crossPoint[0] = (b2 - b1) / (a1 - a2);
			crossPoint[1] = (a1 * crossPoint[0]) + b1;

			var ViewPoint = [];
			ViewPoint[0] = crossPoint[0] - (prev[0] - crossPoint[0]);
			ViewPoint[1] = crossPoint[1] - (prev[1] - crossPoint[1]);

			var motion =  Motion.Get([this.x, this.y], ViewPoint, this.spd);
			this.moveX = motion.x;
			this.moveY = motion.y;
			this.Rotation = motion.angle + 90;

			// Main.postRender[0] = [
			// 	function(params)
			// 	{
			// 		ctx.save()
			// 		ctx.fillStyle = "red";
			// 		ctx.fillRect(params[0] - Camera.xView, params[1] - Camera.yView, 5, 5);
			// 		ctx.restore();
			// 	},
			// 	prev
			// ];
			// Main.postRender[1] = [
			// 	function(params)
			// 	{
			// 		ctx.save()
			// 		ctx.fillStyle = "green";
			// 		ctx.fillRect(params[0] - Camera.xView, params[1] - Camera.yView, 5, 5);
			// 		ctx.restore();
			// 	},
			// 	crossPoint
			// ];

			// Main.postRender[3] = [
			// 	function(params)
			// 	{
			// 		ctx.save()
			// 		ctx.fillStyle = "yellow";
			// 		ctx.fillRect(params[0] - Camera.xView, params[1] - Camera.yView, 5, 5);
			// 		ctx.restore();
			// 	},
			// 	ViewPoint
			// ];

			// Main.postRender[2] = [
			// 	function(params)
			// 	{
			// 		ctx.save();
			// 		ctx.beginPath();
			// 		ctx.moveTo(params[0] - Camera.xView, params[1] - Camera.yView);
			// 		ctx.lineTo(params[2] - Camera.xView, params[3] - Camera.yView);
			// 		ctx.stroke();
			// 		ctx.restore();
			// 	},
			// 	[this.x, this.y, World.CenterPoint.x, World.CenterPoint.y]
			// ];
		}

		if(this[STAT.ATTACK_RANGE] && !this.isLaser)
		{
			var distance = MathHelper.GetDistance([this.x, this.y], this.from);
			if(distance >= this[STAT.ATTACK_RANGE]) this.onRangeOut();
		}

		if(this.timeToDespawn <= this.ageInTicks)
		{
			this.Kill();
		}

		if(this.followTimes >= this.followTime * Main.FPS)
		{
			this.Kill();
		}
		
		if(this.Bounce && (this.bounceTimes > this.Bounce))
		{
			this.Kill();
		}

		if(this.Pierce)
		{
			if(this.pierceTimes > this.Pierce)
			{
				this.Kill();
			}
		}
	}

	onBounce(){}

	onRangeOut()
	{
		this.Kill();
	}

	onShoot(){}

	Render(ctx)
	{
		super.Render(ctx);

		if(World.Player === this.source && this.canBeLightSource)
		{
			var r = this.HitBox.Radius || this.HitBox.Width / 2;
			Graphic.addLightSource(this.x - Camera.xView, this.y - Camera.yView, r * 2);
		} 
	}

	Kill()
	{
		if(this.missed && !World.currentRoom.isCleared && World.Player === this.source) World.Player.RunStats.missedShots++;
		super.Kill();
	}
}class ProjectileBoomerang extends Projectile
{
	constructor(x, y, stats)
	{
		super(x, y, stats);

        this.isReturning = false;

        this.bounceTime = 999;
        this.Pierce = 999;
        this.Bounce = true;

        this.Hits = 10;

        this.returnDeepInside = false;  //true: projectile will get killed when it reach source x,y, not when colliding with source
    }

    onBounce()
    {
        this.onRangeOut();
    }

    onRangeOut()
    {
        this.isReturning = true;
        this.piercedEntities = [];
    }

    Update()
    {
        var hurtDelay = Math.round(Main.FPS / this.Hits);
        if(this.ageInTicks%hurtDelay == 0)
        {
            this.piercedEntities = [];
        }

        if(this.isReturning)
        {
            var target = this.source;
            var spd = this.spd;

            var angle = MathHelper.getAngle2([this.x, this.y], [target.x, target.y]);
            var end = MathHelper.lineToAngle([this.x, this.y], spd, angle);

            this.from = {x: this.x, y: this.y};
            
            this.moveX = end.x - this.x;
            this.moveY = end.y - this.y;
        }
        super.Update();
    }

    onPlayerCollision(player)
    {
        if(!this.source instanceof Player) return super.onPlayerCollision(player);

        if(this.isReturning && this.source == player)
        {
            if(!this.returnDeepInside) this.Kill();
            else
            {
                var spd = MathHelper.GetMovementSpeed(this.moveX, this.moveY);
                if(MathHelper.GetDistance([this.x, this.y], [this.source.x, this.source.y]) <= spd / Main.DELTA)
                {
                    this.Kill();
                }
            }
        }
    }

    onEntityCollision(entity)
    {
        if(this.source instanceof Player) return super.onEntityCollision(entity);
 
        if(this.isReturning && this.source == entity)
        {
            if(!this.returnDeepInside) this.Kill();
            else
            {
                var spd = MathHelper.GetMovementSpeed(this.moveX, this.moveY);
                if(MathHelper.GetDistance([this.x, this.y], [this.source.x, this.source.y]) <= spd * Main.DELTA)
                {
                    this.Kill();
                }
            }
        }
    }

    onKill()
    {
        this.Item.Throws--;
    }


    Shoot(source, target)
	{
		if(source && target)
		{	
			super.Shoot(source, target);

			// this[STAT.ATTACK_RANGE] = MathHelper.GetDistance([source.x, source.y], [target.x, target.y]);
            this.Rotation = 0;
		}
	}
}class Explosion extends Projectile
{
	constructor(x, y, source, damage = 1, radius = 100, time = 1)
	{
		super(x, y);


		this.source = source;
		this.width = radius;
		this.height = radius;
		this.Pierce = 999;

		this.Scale = 0;
		this.timeToDespawn = time * Main.FPS;
		this.scaleTime = this.timeToDespawn;
		this.damage = damage;

		this.killOnBorderHit = false;
		this.knockBack = 0;
		this.scaleTransition = true;
	}


	Update()
	{
		if(this.ageInTicks <= this.scaleTime && this.scaleTransition)
		{
			this.Scale = this.ageInTicks / this.scaleTime;
		}

		if(this.ageInTicks >= this.timeToDespawn) this.Kill();

		super.Update();
	}
	
	Shoot(source, target)
	{
		return;
	}
}class ProjectileHook extends ProjectileBoomerang
{
	constructor(x, y, stats)
	{
		super(x, y, stats);

        this.Hits = 1;
        this.Hooked = null;
        this.knockBack = 0;
        this.canHookWhileReturning = true;
    }


    Update()
    {
        if(this.isReturning && this.Hooked)
        {
            this.Hooked.x = this.x;
            this.Hooked.y = this.y;
        }
        super.Update();
    }

    onPlayerCollision(player)
    {
        if(!(this.source instanceof Player) && !this.source.isFromPlayer) 
        {
            if(player.canBeHurt() && (this.canHookWhileReturning || (!this.canHookWhileReturning && !this.isReturning)))
            {
                this.isReturning = true;
                player.allowControl = false;
                player.allowMove = false;
                this.Hooked = player;
            }

            return super.onPlayerCollision(player);
        }
    }


    onEntityCollision(entity)
    {
        if(entity.isHurtAble && ((World.Player === this.source) || this.hurtEntities || this.source.isFromPlayer))
        {
            if(this.canHookWhileReturning || (!this.canHookWhileReturning && !this.isReturning))
            {
                this.isReturning = true;
                entity.allowMove = false;
                this.Hooked = entity;
            }
        }

        super.onEntityCollision(entity);
    }

    onKill()
    {
        if(this.Hooked)
        {
            this.Hooked.allowControl = true;
            this.Hooked.allowMove = true;
        }
    }


    Shoot(source, target)
	{
		if(source && target)
		{	
			super.Shoot(source, target);

			// this[STAT.ATTACK_RANGE] = MathHelper.GetDistance([source.x, source.y], [target.x, target.y]);
            this.Rotation = 0;
		}
	}
}class ProjectileLaserBeam extends Projectile
{
	constructor(x, y, stats)
	{
		super(x, y);

		this.Textures = 
		{
			start: 'projectile.laser.base.start',
			mid: 'projectile.laser.base.mid',
			end: 'projectile.laser.base.end'
		};
		this.BeamImage = null;
		this.BeamTexture = null;
		// this.Texture = "laser_part";
		
		this.width = 0;
		
		this.alwaysRender = true;
		this.isLaser = true;
		this.element = ELEMENT.PHYSICAL;

		this.moveParticle = "bulletParticle";
		this.hurtDelay = 5;
		this.end = {x: 0, y: 0};
		this.hurted = [];
		this.maxAllowedTargets = 9999;
		this.entitiesToCollide = [];
		this.killOnTargetReach = false;
		
		this.size = 50;
		this.visibleSize = this.size;
		this.visibleSizeTransition = true;
		this.resizeTick = 0;
		this.resizeTime = Main.FPS / 3;
		this.startPosDistance = 20;
		this.timeToDespawn = Main.FPS;
		this.laserDuration = this.dontDespawnTime;

		this.allowedAngleDifference = 90;
		this.allowSelfRotationChange = true;

		

		this.rotationSpeed = 180;
		this.dir = 1;

		this.laserSizeTransition = new Transition(0.95, 1.05, 0.05, true, 0.05, 0.05);
		this.laserAlphaTransition = new Transition(0.8, 1, 0.1, true, 0.05, 0.05);

		this.setStats(stats);
		this.Radius = (this[STAT.ATTACK_RANGE]) ? this[STAT.ATTACK_RANGE] : World.Radius * 2;

		this.isControlAble = true;
		this.DeathSound = null;

		this.knockBack = 0;
		this.selfRotation = 0;
	}

	onCollision()
	{
		return;
	}
		
	onPlayerCollision(player)
	{
		super.onPlayerCollision(player);
	}
		
	onEntityCollision(entity)
	{
		if( (entity.isHurtAble) && ((World.Player === this.source) || this.hurtEntities))
		{
			var available = this.getAvailableTargets();
			if(available == 0) return;
			if(this.killOnTargetReach && available == 1) this.Kill();

			this.missed = false;
			var data = this.getDamageData();

			//laser needs to warm up to deal damage
			if(this.ageInTicks < this.hurtDelay) return;

			//there is cooldown only at already damaged entities
			if(this.hurted.indexOf(entity) != -1)
			{
				if(this.ageInTicks % this.hurtDelay == 0)
				{
					entity.Hurt(data.damage, this.source, data);
				}
			}
			else
			{
				entity.Hurt(data.damage, this.source, data);
				this.hurted.push(entity);
			}
		}	
	}

	getAvailableTargets()
	{
		return (this.maxAllowedTargets + this.Pierce) - this.hurted.length;
	}

	setStats(stats)
	{
		super.setStats(stats);

		this.timeToDespawn = this.laserDuration;

		if(this.timeToDespawn < Main.FPS)
		{
			this.resizeTime = this.timeToDespawn / 3;
		}
	}

	onShoot()
	{
		this.Rotate();
		// console.log(this.Pierce)
	}

	Rotate()
	{
		var rot_step = this.rotationSpeed / Main.FPS;

		var sR = MathHelper.ToAllowedAngle(this.source.Rotation + 270);

		var diff = (sR - (this.Rotation-this.selfRotation));

		if(this.ageInTicks <= 1)
		{
			this.Rotation = sR + this.selfRotation;
			this.source.laserRotation = sR + 90;
			return;
		}

		if(!this.isControlAble) return;

		if(Math.abs(diff) > rot_step)
		{
			var dir = 1;

			
			if(diff > 0)
			{
				dir = 1;
				if(diff > 180)
				{
					dir = -1;
				}
			}
			else
			{
				dir = -1;
				if(diff < -180)
				{
					dir = 1;
				}
			}

			this.Rotation += rot_step * dir;

			this.Rotation = MathHelper.ToAllowedAngle(this.Rotation);
		}
		else
		{
			this.Rotation = sR + this.selfRotation;
		}

		this.source.laserRotation = this.Rotation + 90;
	}

	checkForCollision(entity)
	{
		if(this.ageInTicks <= 1) return;
		if(entity instanceof EntityItem) return;
		if(entity instanceof Oxygen) return;
		// console.log(this.Rotation);

		// var xDiff = this.end.x - this.x;
		// var xDiffe = entity.HitBox.x - this.x;

		// var yDiff = this.end.y - this.y;
		// var yDiffe = entity.HitBox.y - this.y;

		// if(
		// 	!(((xDiff > 0 && xDiffe > 0) || (xDiff < 0 && xDiffe < 0)) &&
		// 	((yDiff > 0 && yDiffe > 0) || (yDiff < 0 && yDiffe < 0)))
		// )
		// {
		// 	return;
		// }



		var isInRange = (MathHelper.GetDistance([entity.HitBox.x, entity.HitBox.y], [this.x, this.y]) <= this.Radius) ? true : false;
		if(!isInRange) return;


		var distance, size, hitBox, angleToEnemy, angleDiff;
		var hitBoxes = ([entity.HitBox]).concat(entity.advancedHitBox ?? []);
		for(var i in hitBoxes)
		{
			hitBox = hitBoxes[i];
			angleToEnemy = (MathHelper.getAngle2([this.x, this.y], [hitBox.x, hitBox.y])+360)%360;
			angleDiff = Math.abs(angleToEnemy - this.Rotation)%360;

			if(angleDiff >= this.allowedAngleDifference) break;

			distance = MathHelper.GetPointDistanceFromLine([hitBox.x, hitBox.y], [this.x, this.y], [this.end.x, this.end.y]);

			if(hitBox.Type == HITBOX.ROUND) size = hitBox.Radius;
			else size = hitBox.Width;

			if(distance <= size + (this.size / 2))
			{
				this.entitiesToCollide.push(entity);
				break;
			}
		}
	}

	applyEntitiesCollisions()
	{
		//can hurt every enemy, no need to sort them
		var availableTargets = this.getAvailableTargets();
		if(availableTargets >= this.entitiesToCollide.length)
		{
			for(var i in this.entitiesToCollide)
			{
				var e = this.entitiesToCollide[i];
				if(e instanceof Entity) this.onEntityCollision(e);
				if(e instanceof Player) this.onPlayerCollision(e);
			}
		}
		else if(availableTargets > 0)
		{
			var sorted = {};
			for(var i in this.entitiesToCollide)
			{
				var target = this.entitiesToCollide[i];
				var distance = Math.round(MathHelper.GetDistance([this.x, this.y], [target.x, target.y]));
				sorted[distance] = target;
			}

			// console.log(availableTargets);	
			for(var j in sorted)
			{
				var e = this.sorted[j];
				if(e instanceof Entity) this.onEntityCollision(e);
				if(e instanceof Player) this.onPlayerCollision(e);

				availableTargets--;
				if(availableTargets <= 0) break;
			}
		}

		this.entitiesToCollide = [];
	}
	
	Shoot(source, target)
	{
		if(source && target)
		{			
			this.source = source;
			this.target = target;

			if(this.shootAngle && this.allowSelfRotationChange) this.selfRotation = this.shootAngle;
		}
	}
	
	Update()
	{
		super.Update();
		
		if(this.timeToDespawn < this.dontDespawnTime)
		{
			if(this.ageInTicks + this.resizeTime < this.timeToDespawn)
			{
				this.resizeTick++;
			}
			else
			{
				this.resizeTick--;
			}	
		}
		else
		{
			if(this.source.isAttacking || this.source instanceof Entity)
			{
				this.resizeTick++;
			}
			else
			{
				this.resizeTick--;
			}
		}


		if(this.ageInTicks % this.hurtDelay == 0) this.piercedEntities = [];


		this.resizeTick = (this.resizeTick < 0) ? 0 : this.resizeTick;
		this.resizeTick = (this.resizeTick > this.resizeTime) ? this.resizeTime : this.resizeTick;

		if(this.visibleSizeTransition)
		{
			this.visibleSize = this.size * (this.resizeTick / this.resizeTime);
		}
		else
		{
			this.visibleSize = this.size;
		}
		

		this.Rotate();
		this.end = MathHelper.lineToAngle([this.x, this.y], this.Radius, this.Rotation);

		this.applyEntitiesCollisions();

		// if(this.resizeTick == 0)
		if(this.ageInTicks >= this.timeToDespawn)
		{
			this.Kill();
		}
	}

	Render(context)
	{
		if(this.startPosDistance)
		{
			var startPos = MathHelper.lineToAngle([this.source.x, this.source.y], this.startPosDistance, this.Rotation);
			this.x = startPos.x;
			this.y = startPos.y;
		}
		else
		{
			this.x = this.source.x;
			this.y = this.source.y;
		}

		if(this.visibleSize < 2) return;


		var size = this.visibleSize;
		var alpha = 0.9;

		if(this.visibleSize == this.size)
		{
			if(this.visibleSizeTransition) size *= this.laserSizeTransition.Update();
			alpha = this.laserAlphaTransition.Update();
		}
	

		var img_start = TextureManager.Get(this.Textures.start);
		var img_mid = TextureManager.Get(this.Textures.mid);
		var img_end = TextureManager.Get(this.Textures.end);
		var rotation = this.Rotation - 90;

		var x = this.x - Camera.xView;
		var y = this.y - Camera.yView;
		var scale = this.Scale;
		var mid_length = this.Radius - 2 * this.size;

		var startTranslationY = -this.size;
		var midTranslationY = startTranslationY - this.size/2 + .5;
		var endTranslationY = midTranslationY - mid_length - this.size/2 + .5;

		var cropFunc = function(ctx)
		{
			ctx.beginPath();
			ctx.arc(World.CenterPoint.x - Camera.xView, World.CenterPoint.y - Camera.yView, World.Radius, 0, Math.PI * 2);
			ctx.closePath();
			ctx.clip();
		};



		if(this.RENDER_LAYER!=null) 
		{
			ChangeLayer(this.RENDER_LAYER);
			context = ctx;
		}

			Graphic.DrawRotatedImage(context, img_start, x, y, size, this.size, scale, rotation, alpha, 0, startTranslationY);
			Graphic.DrawRotatedImage(context, img_mid, x, y, size, mid_length, scale, rotation, alpha, 0, midTranslationY - mid_length/2, cropFunc);
			Graphic.DrawRotatedImage(context, img_end, x, y, size, this.size, scale, rotation, alpha, 0, endTranslationY, cropFunc);

		if(this.RENDER_LAYER!=null) RestoreLayer();



		if(World.Player === this.source)
		{
			Graphic.addLightSource(this.x - Camera.xView, this.y - Camera.yView, this.Radius, 'LINE', size * 2, this.end.x - Camera.xView, this.end.y - Camera.yView);
		}

		return;

		var texture = TextureManager.Get(this.Texture);

		//poczatek lasera (polokrag)
		var tCanvas = document.createElement('canvas');
			tCanvas.width = size;
			tCanvas.height = size / 2;
		var tCtx = tCanvas.getContext('2d');

		tCtx.save();
		tCtx.beginPath();
		tCtx.arc(size / 2, size / 2, size / 2, 0, Math.PI * 2);
		tCtx.closePath();
		
		tCtx.clip();

		tCtx.drawImage(texture, 0, 0, size, size / 2);
		tCtx.restore();

		//clip laser inside world bubble
		ctx.save();
		ctx.beginPath();
		ctx.arc(World.CenterPoint.x - Camera.xView, World.CenterPoint.y - Camera.yView, World.Radius, 0, Math.PI * 2);
		ctx.closePath();	
		ctx.clip();
		
		ctx.translate(this.x - Camera.xView, this.y - Camera.yView);
		ctx.rotate((this.Rotation - 90) * Math.PI/180);
		ctx.globalAlpha = alpha;

		ctx.drawImage(
			tCanvas, 0, 0, tCanvas.width, tCanvas.height,
			-(size / 2), 0,
			size, size / 2
		);

		ctx.drawImage(
			texture, 0, 0, texture.width, texture.height,
			-(size / 2), size / 2 - 1,
			size, this.Radius - size / 2
		);


		ctx.restore()
		
	}

	Kill()
	{
		this.source.laserRotation = null;

		super.Kill();
	}
}class ProjectileRocket extends Projectile
{
	constructor(x, y, stats)
	{
		super(x, y);
		
		if(stats)
		{
			for(var property in stats)
			{
				this[property] = stats[property];
			}
		}
		
		var texture = TextureManager.Get(this.Texture);
		if(texture)
		{
			if(!this.width) this.width = texture.width;
			if(!this.height) this.height = texture.height;
		}

		this.explosionDamage = this.damage;
		this.damage = 0;
	}
	
	Shoot(source, target)
	{
		if(source && target)
		{	
			super.Shoot(source, target);

			this[STAT.ATTACK_RANGE] = MathHelper.GetDistance([source.x, source.y], [target.x, target.y]);
		}
	}
}class HitBox
{
	constructor(type = HITBOX.ROUND, translationX = 0, translationY = 0, Scale)
	{
		this.x = 0;
		this.y = 0;
		this.width = 0;
		this.Width = 0;
		this.height = 0;
		this.Height = 0;
		this.Scale = Scale || 1;
		this.Type = type;
		
		this.translationX = translationX;
		this.translationY = translationY;
	}
	
	Update(owner)
	{
		var width = owner.width || owner.Width;
		var height = owner.height || owner.Height;
		
		var x = (width * owner.Scale / 2);
		var y = (height * owner.Scale / 2);

		var scale = owner.Scale * this.Scale;

		this.x = owner.x - (x * this.Scale);
		this.y = owner.y - (y * this.Scale);

		if(this.translationX || this.translationY)
		{
            var endPoints = [
                this.x + (this.translationX * width * scale),
                this.y + (this.translationY * height * scale)
            ];
            var pos = MathHelper.RotatePoint([this.x, this.y], owner.Rotation, endPoints);
			this.x = pos.x;
			this.y = pos.y;
		}
		
		

		if(this.Type == HITBOX.RECTANGLE)
		{
			this.endX = this.x + (width * scale);
			this.endY = this.y + (height * scale);
			
			this.width = this.Width = width * scale;
			this.height = this.Height = height * scale;
		}
		else if(this.Type == HITBOX.ROUND)
		{
			this.Radius = (width * scale) / 2;
			this.x += this.Radius;
			this.y += this.Radius;
		}
	}

	ApplyRotation(owner, rotation)
	{
		rotation = (rotation) ? rotation : owner.Rotation;
		var end = MathHelper.lineToAngle([owner.x, owner.y], owner.Scale, rotation);
		this.x = end.x;
		this.y = end.y;
	}
	
	Render()
	{
		if(Main.ShowHitbox)
		{
			if(this.Type == HITBOX.RECTANGLE)
			{
				ctx.save();
				ctx.globalAlpha = 0.5;
				ctx.fillStyle = "red";
				ctx.fillRect(this.x - Camera.xView, this.y - Camera.yView, this.width, this.height);
				ctx.restore();
			}
			else if(this.Type == HITBOX.ROUND)
			{
				ctx.save();
				ctx.globalAlpha = 0.5;
				ctx.fillStyle = "red";
				ctx.beginPath();
				ctx.arc(this.x - Camera.xView, this.y - Camera.yView, this.Radius, 0, Math.PI * 2);
				ctx.fill();
				ctx.closePath();
				ctx.restore();
			}
		}
		
	}
}class LootTable
{
	/**
	 * 
	 * @param {Array} itemList Array of LootTableItemData
	 */
	constructor(itemList = [])
	{
		this.itemList = itemList;
	}

	GetItem()
	{
		for(var i = 0; i < this.itemList.length; i++)
		{
			var ItemData = this.itemList[i];

			if(MathHelper.GetChance(ItemData.Chance))
			{
				var count = MathHelper.randomInRange(ItemData.Min, ItemData.Max);

				var item = ItemHelper.getInstanceOfItem(ItemData.Type);
				if(item)
				{
					if(item.stackAble)
					{
						item.count = count;
					}

					return item;
				}
			}
		}

		return null;
	}
}

class LootTableItemData
{
	/**
	 * 
	 * @param {Item} type Type of item
	 * @param {Number} chance Chance of drop in %
	 * @param {Number} min Minimal count
	 * @param {Number} max Maximal count
	 */
	constructor(type, chance = 0, min = 1, max)
	{
		if(typeof type === "function")
		{
			type = type.name;
		}
		this.Type = type;
		this.Chance = chance;
		this.Min = min;
		this.Max = max ?? min;
	}
}class Particle
{
	constructor(type, x, y, liveTime, width, height, scale, onRender, onKill, data)
	{
		this.type = type;
		this.Texture = type;
		this.x = x || 0;
		this.y = y || 0;
		this.onUpdate = null;
		
		this.ageInTicks = 0;
		this.Frame = 0;
		this.Scale = scale;
		this.globalAlpha = 1;

		this.Origin = {x: 0, y: 0};
		
		var texture = TextureManager.Get(this.Texture);
		this.Frames = texture.height / texture.width;
		this.FrameDir = 1;
		
		this.liveTime = liveTime;
		this.frameDelay = (this.liveTime / this.Frames);
		
		this.onRender = onRender;
		this.onKill = onKill;
		
		this.width = width;
		this.height = height;

		this.moveX = 0;
		this.moveY = 0;

		this.opacity = 1;
		this.Rotation = 0;
		this.lightLevel = Particle.getLightLevel(type);

		if(data)
		{
			for(var i in data)
			{
				this[i] = data[i];
			}
		}
	}

	static getLightLevel(type)
	{
		switch(type)
		{
			
		}

		return 0;
	}

	static SilkShade()
	{
		var time = this.silkShade;
		if(this.ageInTicks <= time)
		{
			this.opacity = this.ageInTicks / time;
		}
		else if(this.ageInTicks >= this.liveTime - time)
		{
			this.opacity = 1 - ((this.ageInTicks - (this.liveTime - time)) / time);
		}

		if(this.opacity < 0) this.opacity = 0;
		if(this.opacity > 1) this.opacity = 1;
	}

	static Summon(type, x, y, destX, destY, scale = 1, spd = 0, count = 1, silkShade = 10, data = null)
	{
		var onRender = (!silkShade) ? null : Particle.SilkShade;
		
		if(!destX) destX = x;
		if(!destY) destY = y;

		for(var i = 0; i < count; i++)
		{
			var dist = MathHelper.GetDistance([x, y], [destX, destY]);
			var liveTime = ((dist - silkShade) / spd) * Main.FPS;

			var motion = Motion.Get([x, y], [destX, destY], spd);
			var particle = new Particle(type, x, y, liveTime, 32, 32, scale, onRender, null, data);
				particle.moveX = motion.x;
				particle.moveY = motion.y;
				particle.silkShade = silkShade;
				
			World.AddParticle(particle);
		}
	}

	/**
	 * 
	 * @param {String} type Texture to render
	 * @param {Number} x 
	 * @param {Number} y 
	 * @param {Number} spd 
	 * @param {Number} count 
	 * @param {Number} range 
	 * @param {Number} angle 
	 * @param {Number} angleStep 
	 * @param {Bool} moveOut 
	 * @param {Bool} silkShade 
	 */
	static SummonCirclePattern(type, x, y, scale = 1, spd = 0, count = 1, range = 1, angle = null, angleStep = null, moveOut = true, silkShade = 10, data = null)
	{
		if(angle == null)
		{
			angle = MathHelper.randomInRange(0, 360);
		}
		if(angleStep == null)
		{
			angleStep = (360 / count);
		}

		var onRender = (!silkShade) ? null : Particle.SilkShade;

		for(var i = 0; i < count; i++)
		{
			var pos = MathHelper.lineToAngle([x, y], range, angle + (i * angleStep) );
			var liveTime = ((range - silkShade) / spd) * Main.FPS;

			var motion = Motion.Get(pos, [x, y], spd);
			var particle = new Particle(type, pos.x, pos.y, liveTime, 32, 32, scale, onRender, null, data);
				particle.moveX = motion.x;
				particle.moveY = motion.y;
				particle.silkShade = silkShade;
				if(moveOut)
				{
					particle.moveX *= -1;
					particle.moveY *= -1;
					particle.x = x;
					particle.y = y;
				}
				
			World.AddParticle(particle);
		}
	}
	
	Render(context)
	{
		this.ageInTicks++;
		this.onUpdate?.();

		this.x += this.moveX * Main.DELTA;
		this.y += this.moveY * Main.DELTA;

		if(isFunction(this.onRender))
		{
			this.onRender();
		}
		

		if(this.liveTime)
		{
			if(this.ageInTicks % this.frameDelay == 0)
			{
				this.Frame+=this.FrameDir;
			}
			
			if(this.ageInTicks > this.liveTime)
			{
				this.Kill();
			}
		}

		if(!this.isOnScreen) return;
		
		var texture = TextureManager.Get(this.Texture);
		var x = this.x - Camera.xView;
		var y = this.y - Camera.yView;

		if(this.RENDER_LAYER!=null) 
		{
			ChangeLayer(this.RENDER_LAYER);
			context = ctx;
		}

			Graphic.DrawRotatedAnimatedImage(context, this.Frame, this.Frames, 'Y', 
				texture, x, y, this.width, this.width, this.Scale, this.Rotation, this.opacity * this.globalAlpha, this.Origin.x, this.Origin.y);


		if(this.RENDER_LAYER!=null) RestoreLayer();

		if(this.lightLevel)
		{
			var r = this.width * this.Scale / 2;
			Graphic.addLightSource(x, y, r * 2 * this.lightLevel);
		} 
	}
	
	Kill()
	{
		if(isFunction(this.onKill))
		{
			this.onKill();
		}
		World.RemoveParticle(this);
	}
}class Commands
{
	static Initialize()
	{
		if(!DEVELOPER_MODE && (!ALLOW_COMMANDS))
		{
			return;
		}

		var methods = getAllMethods(this);
		
		for(var i = 0; i < methods.length; i++)
		{
			var method = methods[i];
			window[method] = this[method];
		}
	}

	
	/**
	 * Give specific item to Player.
	 * @param {Item} item Item to be added.
	 * @param {Number} count Count of items.
	 */
	static Give(item, count = 1, itemInfo = null)
	{
		if(item)
		{
			if(typeof item === "function")
			{
				item = item.name;
			}

			item = ItemHelper.getInstanceOfItem(item);

			if(itemInfo)
			{
				for(var property in itemInfo)
				{
					item[property] = itemInfo[property];
				}
			}

			World.Player.addItemToInventory(item, count, true);
		}
		else
		{
			var result = "Available Items:\n";
			var i = 0;
			for(var itemName in Main.ItemHelper.Items)
			{
				i++;
				result += "\n"+i+". " + itemName;
			}
			return result;
		}
	}

	/**
	 * Kill specific Entity, or all of entities on map.
	 * @param {Entity} entity Entity to be killed.
	 */
	static Kill(entity)
	{
		if(!entity)
		{
			World.Entities = [];
			World.Boss = null;
			document.getElementById('boss_rage_meter')?.remove();
		}
		else
		{
			World.Kill(entity);
		}
	}
	

	/**
	 * Summon specific Entity.
	 * @param {Entity} entity Entity to be summoned.
	 * @param {Number} x x-coordinate.
	 * @param {Number} y y-coordinate.
	 */
	static Summon(entity, x, y, noAI = false)
	{
		if(entity)
		{
			try
			{
				x = x || World.CenterPoint.x;
				y = y || World.CenterPoint.y;
				var e = new entity(x, y);
				if(noAI) e.NoAI = true;
				World.AddEntity(e);
			}
			catch(error)
			{
				console.error("Invalid Entity.\n  Enter Summon() to get more information.");
			}
		}
		else
		{
			var result = "Available Entities:\n";
			var i = 0;
			for(var entityName in World.EntityList)
			{
				i++;
				var isBoss = (World.EntityList[entityName].isBoss) ? " (Boss)" : "";
				result += "\n" + i +". " + entityName + isBoss;
			}
			return result;
		}
	}

	static GoToRoom(y, x, time = 2)
	{
		if((x == undefined) || (y == undefined)) return;
		if(!World) return;
		if(!World.Location) return;
		if(!World.Location.Rooms) return;

		var room = World.Location.Rooms[y][x];
		if(room)
		{
			World.Player.Recall(time, room);
		}
	}

	static GoToLocation(name, time = 2, canInterrupt = true)
	{
		if(name)
		{
			if(typeof name === "function")
			{
				name = name.name;
			}

			if(World.LocationList[name])
			{
				if(World.Location.constructor.name != name)
				{
					World.Player.Recall(time, null, name, canInterrupt);
					return true;
				}
				return "Cannot change location to current.";
			}
			return "Invalid Location Name.";
		}

		var result = "Available Locations:\n";
		var i = 0;
		for(var location in World.LocationList)
		{
			i++;
			result += "\n" + i +". " + location;
		}
		return result;

	}
	

	/**
	 * 
	 * @param {Number} stage Stage to be loaded.
	 */
	static GoToStage(stage)
	{
		if(World.Location.Stage)
		{
			Kill();
			World.Location.StageClear();
			World.Location.Stage = stage - 1;
		}
	}


	static ApplyEffect(entity, effectName, strength, time, hideParticles)
	{
		var effect = Effects.GetEffect(effectName);
		if(effect)
		{
			if(entity.Effects)
			{
				entity.Effects.Apply(new effect(strength, time, hideParticles), entity);
			}
		}
	}




	static GiveAllUpgrades()
	{
		for(var i = 0; i < World.Player.Upgrades.length; i++)
		{
			var up = World.Player.Upgrades[i];
			if(!up.active)
			{
				up.Active(World.Player);
			}
		}
	}
}
Commands.Initialize();class AI_AttackMelee
{
	constructor(target, damage, damageMultiplier, data = {})
	{
		this.name = "AttackMelee";
		this.target = target;
		this.attackDelay = 120;
		this.damage = damage || 1;
		this.damageMultiplier = damageMultiplier;
		this.element = ELEMENT.PHYSICAL;
		this.collisionEffectTrigger = null;
		this.onCollisionEffects = [];
		this.onlyOnAggressive = false;
		// this.passive = true;

		for(var i in data)
		{
			this[i] = data[i];
		}
	}

	Update(owner)
	{
		this.attackDelay += owner.ATTACK_SPEED;
		if(this.damageMultiplier) this.damage = owner.AD * this.damageMultiplier;
		if(!this.damage) this.damage = owner.AD;
	}

	getDamageData()
	{
		var data = {damage: 0, ELEMENT: this.element};
		var damage = this.damage;
		if(isNaN(this.damage))
		{
			damage = MathHelper.randomInRange(this.damage.min, this.damage.max);
		}

		data.damage = damage;

		return data;
	}

	isProperTarget(target)
	{
		return (target instanceof this.target && target.isAlive);
	}
	
	Hurt(owner, target)
	{
		if(owner.NoAI || owner.lockAI) return;
		if(this.onlyOnAggressive && !owner.aggressive) return;

		if(this.isProperTarget(target))
		{
			if(this.attackDelay >= Main.FPS)
			{
				owner.onMeleeAttack?.(target);
				var data = this.getDamageData();
				this.attackDelay = 0;
				target.Hurt(data.damage, owner, data);

				if(!this.collisionEffectTrigger || this.collisionEffectTrigger?.(owner, target))
				{
					for(var i in this.onCollisionEffects)
					{
						var e = this.onCollisionEffects[i];
						ApplyEffect(target, e[0], e[1], e[2], e[3]);
					}
				}
			}
		}
	}
}class AI_AttackRange
{
	constructor(target, bulletStats, stats)
	{
		this.name = "AttackRange";
		this.bulletSery = 0;
		this.attackCharge = 30;
		this.target = target;
		this.bulletStats = {};
		this.rangeFromCenter = false;

		this.maximalAngle = 45;
		this.angleDiff = 10;
		this.requiredCharge = Main.FPS;
		this.updateTrigger = null;
		this.shootTrigger = null;
		
		for(var stat in bulletStats)
		{
			this.bulletStats[stat] = bulletStats[stat];
		}

		for(var stat in stats)
		{
			this[stat] = stats[stat];
		}
	}

	GetTarget(owner)
	{
		if(this.target == World.Player) return World.Player;
		if(World.Entities.indexOf(this.target) != -1) return this.target;

		return Entity.GetAvailableTargets(owner);
	}
	
	Update(owner)
	{
		if(!this.target) return;
		if(this.updateTrigger && !this.updateTrigger(owner)) return;
		if(!owner.aggressive && !owner.isFromPlayer) return;
		
		if(owner.bulletStats) this.bulletStats = owner.bulletStats;
		if(owner.rangeFromCenter) 
		{
			this.rangeFromCenter = owner.rangeFromCenter;
			if(owner.scaleRangeFromCenter)
			{
				this.rangeFromCenter *= owner.Scale;
			}
		}

		var target = this.GetTarget(owner);
		if(!target) return;

		owner.AttackRangeCharge = this.attackCharge / this.requiredCharge * 100;
		
		var distance = MathHelper.GetDistance([owner.x, owner.y], [target.x, target.y]);
		if(distance > owner.ATTACK_RANGE || (owner.ATTACK_RANGE_MIN && distance < owner.ATTACK_RANGE_MIN)) return;
		
		if (this.attackCharge >= this.requiredCharge)
		{
			this.Shoot(owner);
			this.bulletSery++;

			if(this.bulletSery >= owner.BULLET_SERIES)
			{
				this.attackCharge = 0;
				this.bulletSery = 0;
			}
			else
			{
				if(owner.BULLET_SERY_DELAY) this.attackCharge -= owner.BULLET_SERY_DELAY;
			}
		}
		else
		{
			this.attackCharge += owner.ATTACK_SPEED;
		}
	}
	
	Shoot(owner)
	{
		if(this.shootTrigger && !this.shootTrigger(owner)) return;

		var type = Projectile.Types();
		if(!this.bulletStats.Type) this.bulletStats.Type = "BulletBubbleEnemy";
		if(!type[this.bulletStats.Type]) return;

		var target = this.GetTarget(owner);
		if(!target.isAlive) return;
		
		this.bulletStats.spd = owner.BULLET_SPEED;
		this.bulletStats.damage = owner.AD;
		
		
		var shotCount = owner.BULLETS_COUNT || 1;
		
		var x, y;
		
		x = owner.x;
		y = owner.y;
		
		var minAngle = shotCount * this.angleDiff;
		if(minAngle > this.maximalAngle)
		{
			minAngle = this.maximalAngle;
		}
		
		var targetAngle = MathHelper.getAngle2([owner.x, owner.y], [target.x, target.y]);
		var angle = targetAngle - (minAngle / 2);
		if(shotCount == 1)
		{
			angle = targetAngle;
		}

		var angleStep = minAngle / (shotCount - 1);
		
		for(var i = 0; i < shotCount; i++)
		{
			
			if(this.rangeFromCenter)
			{
				var center = MathHelper.lineToAngle([owner.x, owner.y], this.rangeFromCenter, angle);
				x = center.x;
				y = center.y;
			}
			
			var _target = MathHelper.lineToAngle([x, y], 300, angle);
			
			var bullet = new type[this.bulletStats.Type](x, y, this.bulletStats);
				bullet.Shoot(owner, _target);
				
			World.AddProjectile(bullet);
				
			angle += angleStep;
		}
		
	}
}class AI_Boss
{
	constructor(owner, preventAnimation = false)
	{
		this.name = "Boss";

		owner.isBoss = true;
		owner.spawnHeart = true;
		owner.isAggressive = true;
		owner.oxygenMultiplier = 10;
		if(owner.knockBackResistance == 0) owner.knockBackResistance = .5;

		if(!preventAnimation)
		{
			owner.lockAI = true;
			owner.HP = 1;
			owner.isHurtAble = false;
			owner.Transparency = 0.5;

			owner.onBossUpdate = function()
			{
				this.AI.Boss.Update(this);

				var prepareTime = 6 * Main.FPS;
				var prepareDelay = 2 * Main.FPS;

				if(this.HP >= this.MAXHP)
				{
					this.HP = this.MAXHP;
					this.onBossRender = null;
					this.Transparency = 1;

					if(this.ageInTicks >= prepareDelay + prepareTime)
					{
						this.onBossUpdate = null;
						this.lockAI = false;
						this.isHurtAble = true;
						this.onBossAnimationEnd?.();
					}
				}
				else
				{
					var hp_step = this.MAXHP / prepareTime;
					this.HP += hp_step;

					this.Transparency = 0.5 + ((this.HP / this.MAXHP) / 2);
				}
			};

			owner.onBossRender = function()
			{
				var angle = MathHelper.randomInRange(0, 360);
				var count = 1;

				if(this.ageInTicks % 2 == 0)
				{
					Particle.SummonCirclePattern("bubble", this.x, this.y, 0.4, 500, count, 
						World.Radius, angle, null, false);
				}
			};
		}
	}

	Update(owner)
	{
		World.Boss = owner;
		if(!this.createdIcon) 
		{
			owner.AI.Enrage?.CreateEnrageIcon();
			this.createdIcon = true;
		}

		if(owner.BossTheme)
		{
			if(SoundManager.Playing.Background)
			{
				if((SoundManager.Playing.Background.name != owner.BossTheme) && !SoundManager.isPlayingBossTheme)
				{
					if(SoundManager.GetAudio(owner.BossTheme))
					{
						SoundManager.Play(owner.BossTheme, "BACKGROUND");
					}
				}
			}
		}
	}

	onDeath(owner)
	{
		// Upgrade.Spawn(World.Player, owner.x, owner.y);
		World.Boss = null;

		if(owner.spawnHeart)
		{
			World.AddEntity(new Oxygen(owner.x, owner.y, 4, owner.level, true, true));
		}

		if(owner.BossTheme)
		{
			if(SoundManager.Playing.Background)
			{
				if(SoundManager.Playing.Background.name == owner.BossTheme)
				{
					setTimeout(function(){SoundManager.Play(World.Location.BackgroundTheme, "BACKGROUND"); SoundManager.isPlayingBossTheme = false}, 2000);
				}
			}
		}
	}
}class AI_Bounce
{
	constructor(owner, startAngle = 0, getStartAngle, bounceTowardTarget = null)
	{
		this.name = "Bounce";
        this.timeSinceVectorChange = 120;
        this.changeVector = false;
        this.startAngle = startAngle;
        this.getStartAngle = getStartAngle;
        this.bounceTowardTarget = bounceTowardTarget;
        this.Owner = owner;

        owner.onCollision = () => {this.onBorderHit()};
	}

    GetTarget(owner)
	{
		if(this.bounceTowardTarget == World.Player || this.bounceTowardTarget == Player) return World.Player;

		return Entity.GetAvailableTargets(owner);
	}

    getStartMotion(owner)
    {
        var angle = this.startAngle;
        if(isFunction(this.getStartAngle)) angle = this.getStartAngle(owner);
        var end = MathHelper.lineToAngle(owner, 3000, angle);

        var motion =  Motion.Get([owner.x, owner.y], end, owner.getSPD());
            owner.moveX = motion.x;
            owner.moveY = motion.y;

        if(owner.allowRotationChange) owner.Rotation = motion.angle + 90 + owner.defaultRotation;
    }

    onBorderHit()
    {
        this.changeVector = true;
    }
	
	Update(owner)
	{	
        this.timeSinceVectorChange++;
        if(!owner.moveX && !owner.moveY) this.getStartMotion(owner);
        if(!this.changeVector) return;

        
        this.changeVector = false;
        if(this.bounceTowardTarget)
        {
            if(this.timeSinceVectorChange < 5) return;
            owner.onBounce?.();
			this.timeSinceVectorChange = 0;

            var target = this.GetTarget(owner);
            var angle =  MathHelper.getAngle2([owner.x, owner.y], [target.x, target.y]);
            var end = MathHelper.lineToAngle(owner, 3000, angle);

            var motion =  Motion.Get([owner.x, owner.y], end, owner.getSPD());

			owner.moveX = motion.x;
			owner.moveY = motion.y;
			if(owner.allowRotationChange) owner.Rotation = motion.angle + 90 + owner.defaultRotation;
            return;
        }

		if(this.timeSinceVectorChange >= 60 || owner.isLeavingBorder())
		{
			owner.onBounce?.();
			this.timeSinceVectorChange = 0;

            var distX = (owner.x - World.CenterPoint.x);
            var distY = (owner.y - World.CenterPoint.y);
            if(distX == 0) owner.moveY *= -1;
            if(distY == 0) owner.moveX *= -1;

            if(distX == 0 || distY == 0) 
            {
                if(owner.allowRotationChange) owner.Rotation -= 180;
                return;
            }

			var prev = 
			[
				owner.x - (owner.moveX / 10),
				owner.y - (owner.moveY / 10)
			];

			var a1 = distY / distX;
			var b1 = -(a1 * owner.x) + owner.y;

			var a2 = - (1 / a1);
			var b2 = -(a2 * prev[0]) + prev[1];

			var crossPoint = [];
			crossPoint[0] = (b2 - b1) / (a1 - a2);
			crossPoint[1] = (a1 * crossPoint[0]) + b1;

			var ViewPoint = [];
			ViewPoint[0] = crossPoint[0] - (prev[0] - crossPoint[0]);
			ViewPoint[1] = crossPoint[1] - (prev[1] - crossPoint[1]);

			var motion =  Motion.Get([owner.x, owner.y], ViewPoint, owner.getSPD());
			owner.moveX = motion.x;
			owner.moveY = motion.y;

			if(owner.allowRotationChange) owner.Rotation = motion.angle + 90 + owner.defaultRotation;
		}
	}
}class AI_Dash
{
	constructor(owner, target, onlyOnAggressive = true, coolTimeMin = 10, coolTimeMax, additionalData = {})
	{
		this.name = "Dash";
        this.ageInTicks = 0;
		this.target = target;
		this.targetRange = null;
        this.onlyOnAggressive = onlyOnAggressive;
        this.coolTimeMin = coolTimeMin;
        this.coolTimeMax = coolTimeMax ?? coolTimeMin;

        this.dashStart = 0;
        this.dashDuration = (Main.FPS / 60) * 10;
		this.dashMultiplier = 5;
        this.dashesInRow = 1;
        this.dashedInRow = 0;
        this.dashesInRowDelay = 10;
		this.stopDashOnCollision = true;

        this.dashCoolTime = MathHelper.randomInRange(0, this.coolTimeMin * Main.FPS);
        this.timeToDash = this.dashCoolTime;

        for(var i in additionalData)
		{
			this[i] = additionalData[i];
		}

        owner.onRenderFunctions.push(function(context, owner)
        {
            if(!owner.isDashing) return;
            owner.AI?.Dash?.RenderDashShadows(context, owner);            
        });
	}

    GetTarget(owner)
	{
		if(this.target == World.Player || this.target == Player) return World.Player;
		if(World.Entities.indexOf(this.target) != -1) return this.target;

		return Entity.GetAvailableTargets(owner);
	}

    canDash(owner)
	{
		if(owner.isDashing) return false;
		if(this.ageInTicks < this.timeToDash) return false;
		return true;
	}

	Update(owner)
	{
		if(this.onlyOnAggressive && !owner.aggressive) return;
		if(this.updateTrigger && !this.updateTrigger(owner)) return;

        this.ageInTicks++;
		if(this.canDash(owner)) this.Dash(owner);
        if(owner.isDashing) this.UpdateDash(owner);

        var p = 100-((this.timeToDash - this.ageInTicks) / this.dashCoolTime * 100);
        if(p < 0) p = 0;
        if(p > 100) p = 100;
        owner.toDashProgress = p;
	}

    Dash(owner)
    {
        var target = this.GetTarget(owner);
        if(!target) return;

		if(this.targetRange)
		{
			if(MathHelper.GetDistance(owner, target) >= this.targetRange) return;
		}

        owner.isDashing = true;
        this.dashStart = this.ageInTicks;
        this.dashAngle = MathHelper.getAngle2([owner.x, owner.y], [target.x, target.y]);

		this.dashShadowsData = [];

		owner.onDashStart?.();
    }
    

    setCoolTime(fixedCoolTime = null, additionalCoolTime = 0)
    {
        this.dashCoolTime = MathHelper.randomInRange(this.coolTimeMin * Main.FPS, this.coolTimeMax * Main.FPS);
        if(fixedCoolTime) this.dashCoolTime = fixedCoolTime;
        if(additionalCoolTime) this.dashCoolTime += additionalCoolTime;
        this.dashedInRow = 0;
        this.timeToDash = this.ageInTicks + this.dashCoolTime;
    }

	UpdateDash(owner)
	{
		if(!owner.isDashing) return;

		if(this.dashStart + this.dashDuration < this.ageInTicks) 
		{
			owner.isDashing = false;
            this.dashedInRow++;

            if(this.dashedInRow < this.dashesInRow)
            {
                this.dashCoolTime = this.dashesInRowDelay;
                this.timeToDash = this.ageInTicks + this.dashCoolTime;
				owner.onDashEnd?.();
            }
            else
            {
                this.setCoolTime();
				owner.onDashEnd?.();
            } 
		}

		var spd = owner.getSPD();;
		var delta = Main.DELTA;

		spd *= this.dashMultiplier;

		var to = MathHelper.lineToAngle([owner.x, owner.y], spd * delta, this.dashAngle);
		if(MathHelper.GetDistance([to.x, to.y], World.CenterPoint) < World.Radius)
		{
			owner.x = to.x;
			owner.y = to.y;
		}
        else
        {
			if(this.stopDashOnCollision)
			{
				owner.isDashing = false;
				this.setCoolTime();
			}

			owner.onDashCollision?.();
        }

		this.dashShadowsData.push({x: owner.x, y: owner.y, Rotation: owner.Rotation, times: 0});
	}


    RenderDashShadows(context, owner)
	{
		if(this.dashShadowsData.length > 0)
		{
			var savedX = owner.x;
			var savedY = owner.y;
			var savedRot = owner.Rotation;
			var savedAlpha = owner.Transparency;
			var shadowsRendered = 0;

			for(var i = 0; i < this.dashShadowsData.length; i++)
			{
				var data = this.dashShadowsData[i];
				if(data.times > 10) continue;
				shadowsRendered++;

				owner.x = data.x;
				owner.y = data.y;
				owner.Rotation = data.Rotation;
				owner.Transparency = .25 - (data.times * .025);

                if(owner.Model) 
                {
                    owner.Model.Update(true);
                    owner.Model.Render(context);
                }
                else owner.RenderTexture(context);

				this.dashShadowsData[i].times++;
			}

			owner.x = savedX;
			owner.y = savedY;
			owner.Rotation = savedRot;
			owner.Transparency = savedAlpha;

            owner.Model?.Update(true);
			if(shadowsRendered == 0) this.dashShadowsData = [];
		}
	}
}class AI_Enrage
{
	constructor(owner, hp_lost = 50, data = {})
	{
		this.name = "Enrage";
		this.Owner = owner;
            owner.isEnraged = false;
        this.Brackets = [new HpBracketEvent(hp_lost, this.Enrage)];

        this.HP_lost = hp_lost;
        this.enragedAnimation = 0;
        this.summonParticles = true;

        this.showAnimation = true;
        this.invincibleOnRage = true;

        for(var i in data)
        {
            this[i] = data[i];
        }
	}

    CreateEnrageIcon()
    {
        var current = document.getElementById('boss_rage_meter');
        if(current)
        {
            current.style.left = this.HP_lost+'%';
            return;
        }

        var icon = document.createElement('div');
            icon.id = 'boss_rage_meter';
            icon.className = 'icon';
            icon.dataset.icon = 'icon_boss_rage_meter';
            icon.style.left = this.HP_lost+'%';
            icon.onanimationend = function(){if(this.dataset.hide == 'true') this.remove();}
        document.getElementById('boss_hp_bar_container').appendChild(icon);
    }
	
	Update(owner)
	{
		for(var name in this.Brackets)
        {
            this.Brackets[name].Update(owner);
        }

        if(owner.isEnraged) this.EnrageUpdate(owner);
	}

    EnrageUpdate(owner)
    {
        if(this.enragedAnimation < owner.enragedAnimationDuration)
        {
            owner.enrageAnimationProgress = this.enragedAnimation / owner.enragedAnimationDuration;
            owner.onEnrageAnimationProgress?.();
            
            if(this.showAnimation && this.summonParticles && this.enragedAnimation % 2 == 0 && this.enragedAnimation < owner.enragedAnimationDuration - 1 * Main.FPS)
            {
                var angle = MathHelper.randomInRange(0, 360);

                Particle.SummonCirclePattern("bubble", owner.x, owner.y, 0.4, 500, 1, 
                    World.Radius, angle, null, false);
            }

            this.enragedAnimation++;
            return;
        }

        if(this.enragedAnimation == owner.enragedAnimationDuration)
        {
            owner.lockAI = false;
            owner.unlockAI.replace(this.name, '');
            this.enragedAnimation++
            
            owner.onEnrageAnimationEnd?.();
        }

        owner.onEnrageUpdate?.();
    }

    Enrage(owner)
    {
        if(owner.isEnraged) return;

        owner.isEnraged = true;
        owner.lockAI = true;
        owner.unlockAI += 'Enrage/';

		if(owner.AI.Enrage?.invincibleOnRage) ApplyEffect(owner, 'Invincibility', 1, owner.enragedAnimationDuration/Main.FPS);

        owner.Enrage?.();

        document.getElementById('boss_rage_meter').dataset.hide = 'true';
        document.getElementById('boss_rage_meter').dataset.icon = 'icon_boss_rage_meter_2';
    }
}
class AI_Follow
{
	constructor(ToFollow, onlyOnAggressive, observationTrigger = null, data = {})
	{
		this.name = "Follow";
		this.toFollow = ToFollow;
		this.onlyOnAggressive = onlyOnAggressive;

		this.canActiveWander = false;
		this.observationTrigger = observationTrigger;
		this.keepDistance = 0;


		for(var i in data)
		{
			this[i] = data[i];
		}
	}
	
	GetTarget(owner)
	{
		if(this.toFollow == Player || this.toFollow == World.Player) return World.Player;
		if(World.Entities.indexOf(this.toFollow) != -1) return this.toFollow;
		return Entity.GetAvailableTargets(owner, owner.FOLLOW_RANGE);
	}
	
	Update(owner)
	{
		if(!this.toFollow) return;
		if(!this.toFollow.isAlive) return;
		if(this.disabled) return;
		if(!owner.allowFollow) return;
		if(isFunction(this.observationTrigger))
			if(!this.observationTrigger(owner)) return;

		if(this.onlyOnAggressive && !owner.aggressive) return;
		owner.dirX = 1;
		owner.dirY = 1;
		
		var target = this.GetTarget(owner);
		var followRange = owner.FOLLOW_RANGE || 500;
		var step = Main.DELTA * owner.getSPD();
		
		var distance = MathHelper.GetDistance([owner.x, owner.y], [target.x, target.y]);
			
		if((distance > followRange) || (distance < step))
		{
			if(owner.gotAI('Wander'))
			{
				if(this.canActiveWander) 
				{
					owner.AI.Wander.changeDir();
					this.canActiveWander = false;
				}
				return;
			}
			owner.moveX = 0;
			owner.moveY = 0;
			return;
		}

		if(this.keepDistance && this.keepDistance > distance)
		{
			var angle = MathHelper.getAngle2(owner, target);
			owner.moveX = 0;
			owner.moveY = 0;
			if(owner.allowRotationChange) owner.Rotation = angle + owner.defaultRotation + 90;
			return;
		}

		var tX = target.x;
		var tY = target.y;
		var rotation = null;

		// if(this.keepDistance && distance < this.keepDistance)
		// {
		// 	var angle = MathHelper.getAngle2(owner, target);
		// 	if(this.keepDistance-distance < step) 
		// 	{
		// 		owner.moveX = 0;
		// 		owner.moveY = 0;
		// 		if(owner.allowRotationChange) owner.Rotation = angle + owner.defaultRotation + 90;
		// 		return;
		// 	}

		// 	var new_target = MathHelper.lineToAngle(owner, distance, angle-180);

		// 	tX = new_target.x;
		// 	tY = new_target.y;

		// 	rotation = angle + owner.defaultRotation + 90;
		// }
		
		
		if(target === Mouse)
		{
			tX = target.x + Camera.xView;
			tY = target.y + Camera.yView;
		}


		var motion = Motion.Get([owner.x, owner.y], [tX, tY], owner.getSPD());
		if(owner.allowRotationChange) 
		{
			owner.Rotation = motion.angle + 90 + owner.defaultRotation;
			if(rotation) owner.Rotation = rotation;
		}

		owner.moveX = motion.x;
		owner.moveY = motion.y;

		this.canActiveWander = true;
	}
}class AI_HpBracketEvents
{
	constructor(owner, brackets = [])
	{
		this.name = "HpBracketEvents";
		this.Owner = owner;
        this.Brackets = brackets;
	}
	
	Update(owner)
	{
		for(var name in this.Brackets)
        {
            this.Brackets[name].Update(owner);
        }
	}
}

class HpBracketEvent
{
    constructor(value, event, onlyOnce = true)
    {
        this.Value = value;
        this.event = event;
        this.onlyOnce = onlyOnce;
        this.used = false;
    }

    Update(owner)
    {
        if(this.used) return;

        var hp_percentage = owner.HP / owner.MAXHP * 100;
        if(hp_percentage <= this.Value) this.Trigger(owner);
    }

    Trigger(owner)
    {
        this.event(owner);
        if(this.onlyOnce) this.used = true;
    }
}class AI_LayEgg
{
	constructor(layTimeMin, layTimeMax, layDuration, eggType, eggStats, stats = {})
	{
		this.name = "LayEgg";
        this.layTimeMin = layTimeMin;
        this.layTimeMax = layTimeMax;
        this.layDuration = layDuration * Main.FPS;
        this.eggType = eggType;
        this.eggStats = eggStats;

        this.time = 0;
        this.Egg = null;
        this.eggTranslateY = 0;
        
        for(var i in stats)
        {
            this[i] = stats[i];
        }
        this.SetLayTime();
	}

    SetLayTime()
    {
        this.timeToLayEgg = MathHelper.randomInRange(this.layTimeMin, this.layTimeMax) * Main.FPS;
    }
	
	Update(owner)
	{
		this.time++;
        owner.isLayingEgg = false;
        owner.canBeKnockedBack = true;

        if(this.time > this.timeToLayEgg)
        {
            var layProgress = ((this.time - this.timeToLayEgg) / this.layDuration);

            owner.isLayingEgg = true;
            owner.layProgress = layProgress;
            owner.canBeKnockedBack = false;

            if(!this.Egg) this.SpawnEgg(owner);

            if(layProgress >= 1)
            {
                owner.isLayingEgg = false;
                this.time = 0;
                this.SetLayTime();
                this.Egg = null;
            }
        }
	}

    SpawnEgg(owner)
    {
        var type = World.EntityList[this.eggType];
        if(!type) return;

        this.Egg = new type(owner.x, owner.y, owner, this.eggStats);
        this.Egg.y = owner.y + this.eggTranslateY + (this.Egg.height * this.Egg.Scale * .85);        //spawn egg under spider, not on it
        World.AddEntity(this.Egg, false);
    }
}class AI_MouseEvents
{
	constructor()
	{
		this.name = "MouseEvents";

		/*
			this.onMouseHover;
			this.onMouseClick;
			this.onMouseRightClick;
		*/
	}
	
	Update(owner)
	{
		owner.hover = false;
		owner.click = false;
		owner.rightClick = false;
		
		if(!Mouse.onCanvas) return;

		var state = Mouse.Check(owner.HitBox, true, true);
		var dist = MathHelper.GetDistance([owner.HitBox.x - Camera.xView, owner.HitBox.y - Camera.yView], Mouse);

		owner.hover = (dist <= owner.HitBox.Radius) ? true : false;
		owner.click = state.click;
		owner.rightClick = state.rightClick;

		if(owner.hover)
		{
			if(isFunction(owner.onMouseHover))
			{
				owner.onMouseHover();
			}
		}
		
		if (owner.click)
		{
			if(isFunction(owner.onMouseClick))
			{
				owner.onMouseClick();
			}
			Mouse.lockClick = true;
		}
		
		if (owner.rightClick)
		{
			if(isFunction(owner.onMouseRightClick))
			{
				owner.onMouseRightClick();
			}
			Mouse.lockRightClick = true;
		}
	}
}class AI_Observe
{
	constructor(target, r = 0, observationTrigger = null)
	{
		this.target = target;
		this.name = "Observe";
		this.Radius = r;
		this.observationTrigger = observationTrigger;
	}
	
	GetTarget(owner)
	{
		if(this.target == Player || this.target == World.Player) return World.Player;
		if(World.Entities.indexOf(this.target) != -1) return this.target;
		
		return Entity.GetAvailableTargets(owner, this.Radius);
	}

	Update(owner)
	{
		if(owner.disableObserve) return;
		if(!owner.allowRotationChange) return;
		if(isFunction(this.observationTrigger))
			if(!this.observationTrigger(owner)) return;

		var target = this.GetTarget(owner);
		if(!target) return;
		if(this.Radius)
		{
			var dist = MathHelper.GetDistance(target, owner);
			if(dist > this.Radius) return;
		}
		
		owner.Rotation = MathHelper.getAngle2([target.x, target.y], [owner.x, owner.y]) + 270 + owner.defaultRotation;
	}
}class AI_OrbitAround
{
	constructor(target, speed = 360, radius = 300, startAngle = 0, onTargetDeath = function(owner){owner.Kill()}, direction = 1)
	{
		this.name = "OrbitAround";
		this.target = target;
		this.spd = speed / Main.FPS;
		this.direction = direction;
		this.radius = radius;
		this.startAngle = startAngle;
		this.ageInTicks = 0;
		this.onTargetDeath = onTargetDeath;
	}

	Update(owner)
	{
		owner.allowMove = true;

		if(!this.target) return;
		if(!this.target.isAlive)
		{
			if(isFunction(this.onTargetDeath))
			{
				this.onTargetDeath(owner);
			}
		}

		var angle = this.startAngle + (this.ageInTicks * this.spd * this.direction);
		var radius = this.target.OrbitRadius ?? owner.OrbitRadius ?? this.radius;

		var pos = MathHelper.lineToAngle([this.target.x, this.target.y], radius, angle);

		owner.x = pos.x;
		owner.y = pos.y;

		this.ageInTicks++;
		owner.allowMove = false;
	}
}class AI_QuestIndicator
{
	constructor(owner)
	{
		this.name = "QuestIndicator";
        owner.QuestIndicatorTexture = 'effect.quest.indicator';
        owner.showQuestIndicator = false;
        owner.QuestIndicatorOpacityTransition = new Transition(1, 0.8, 1, true, 0.02, 0.02);

        owner.onRenderFunctions.push(function(context, owner)
        {
            if(!owner.showQuestIndicator) return;

            var texture = TextureManager.Get(owner.QuestIndicatorTexture);
            var alpha = owner.QuestIndicatorOpacityTransition.Update();
            var scale = 1.5;
            var tY = 64 * owner.Scale;
            var x =  owner.x - Camera.xView;
            var y = owner.y - Camera.yView;

            Graphic.DrawRotatedAnimatedImage(context, 0, 1, '', 
                texture, x, y - tY, 64, 64, scale, 0, alpha);
        });
	}
	
	Update(owner)
	{	
        owner.showQuestIndicator = false;

		var id = owner.constructor.name.toUpperCase();
        var quests = QuestList.GetAvailableQuests(id).concat(QuestList.GetQuestsToComplete(id));

        if(quests.length > 0) 
        {
            owner.showQuestIndicator = true;

            if(owner.ageInTicks%90 == 0)
            {
                var scale = 15 * owner.Scale;
                var x = owner.x;
                var y = owner.y;
                Particle.Summon('effect.quest.particle', x, y, 0, 0, scale, 0, 1, 20, 
                {
                    liveTime: 60, 
                    owner: owner,
                    baseScale: scale,
                    center: true,
                    globalAlpha: 0.5,
                    RENDER_LAYER: Graphic.Layer.Particle0,
                    onUpdate: function(){this.x = owner.x, this.y = owner.y;this.Scale = this.baseScale - (this.baseScale * (this.ageInTicks / this.liveTime))}
                });
            }
        }
	}
}class AI_ShotOnCircle
{
	constructor(stats, bulletStats, onlyOnaggressive, shotTrigger)
	{
		this.name = "ShotOnCircle";
		this.onlyOnaggressive = onlyOnaggressive;
		this.attackCharge = 30;
		
		this.shotDelayMin = 1;
		this.shotDelayMax = 5;
		this.shotCount = 4;
		this.bulletStats = {spd: 0};
		this.angle = 0;
		this.getStartAngleFromOwnerRotation = false;
		
		this.shotTrigger = shotTrigger;
		
		if(stats)
		{
			for(var stat in stats)
			{
				this[stat] = stats[stat];
			}
		}
		
		if(bulletStats)
		{
			for(var stat in bulletStats)
			{
				this.bulletStats[stat] = bulletStats[stat];
			}
		}
		
		this.shotDelay = MathHelper.randomInRange(this.shotDelayMin * Main.FPS, this.shotDelayMax * Main.FPS);
	}

	setShotDelay(min = this.shotDelayMin, max = this.shotDelayMax, resetCharge = true)
	{
		this.shotDelayMin = min;
		this.shotDelayMax = max;

		if(resetCharge)
		{
			this.attackCharge = 60;
			this.shotDelay = MathHelper.randomInRange(this.shotDelayMin * Main.FPS, this.shotDelayMax * Main.FPS);
		}
	}
	
	Update(owner)
	{
		if(this.onlyOnaggressive && !owner.aggressive)
		{
			return;
		}

		owner.shotOnCircleCharge = this.attackCharge / this.shotDelay * 100;
		
		if(this.shotTrigger)
		{
			if(!this.shotTrigger(owner))
			{
				return;
			}
		}
		
		if (this.attackCharge >= this.shotDelay)
		{
			this.Shoot(owner);
			this.attackCharge = 0;
			this.shotDelay = MathHelper.randomInRange(this.shotDelayMin * Main.FPS, this.shotDelayMax * Main.FPS);
		}
		else
		{
			this.attackCharge++;
		}
	}

	static StaticShoot(entity, bulletStats, bulletCount, stats = {})
	{
		stats.shotCount = bulletCount;
		
		var circle = new AI_ShotOnCircle(stats, bulletStats);
		circle.Shoot(entity);
	}
	
	Shoot(owner, stats)
	{
		var bulletStats = stats || {...this.bulletStats};
		
		bulletStats.damage = bulletStats.damage ?? owner.AD;
		if(!bulletStats.spd) bulletStats.spd = owner.BULLET_SPEED;

		var type = Projectile.Types();
		if(!bulletStats.Type) bulletStats.Type = "BulletBubbleEnemy";
		if(!type[bulletStats.Type]) return;

		var length = 300;
		var angle = this.angle;
		if(this.getStartAngleFromOwnerRotation) angle = owner.Rotation;
		var angleStep = 360 / this.shotCount;
		
		for(var i = 0; i < this.shotCount; i++)
		{
			var target = MathHelper.lineToAngle([owner.x, owner.y], length, angle);
			
			var bullet = new type[bulletStats.Type](owner.x, owner.y, bulletStats);
				bullet.shootAngle = angle;
				bullet.Shoot(owner, target);
				
			World.AddProjectile(bullet);
			
			angle += angleStep;
		}
	}
}class AI_SpecialAttack
{
	constructor(owner, data = {})
	{
		this.name = "SpecialAttack";
        this.Owner = owner;
		
        this.CoolTime = data.CoolTime || 8 * Main.FPS;
        this.PreparationTime = data.PreparationTime || 0;
        this.Duration = data.Duration || 5 * Main.FPS;

        this.lastCoolTime = this.CoolTime;

        this.ageInTicks = 0;
        this.startAt = data.Delay || 60;

        this.updateTrigger = data.updateTrigger ?? null;
	}
	
	Update(owner)
	{	
        if(!this.updateTrigger?.(owner)) return;

		this.ageInTicks++;
        owner.isUsingSpecialAttack = false;

        owner.specialAttackCoolTimeTick = this.ageInTicks - (this.startAt-this.lastCoolTime);

        if(this.ageInTicks >= this.startAt)
        {
            owner.isUsingSpecialAttack = true;
            owner.specialAttackCoolTimeTick = 0;
            var tick = this.ageInTicks - this.startAt;

            if(tick == 0) owner.specialAttackStart?.();

            if(tick <= this.PreparationTime)
            {
                owner.specialAttackPreparationProgress = tick / this.PreparationTime;
                owner.specialAttackPreparationTick = tick;
                owner.specialAttackPreparationUpdate?.();
                return;
            }

            tick -= this.PreparationTime;
            if(tick <= this.Duration)
            {
                owner.specialAttackProgress = tick / this.Duration;
                owner.specialAttackTick = tick;
                owner.specialAttackUpdate?.();
                return;
            }

            owner.specialAttackEnd?.();
            this.setCoolTime(this.CoolTime);
        }
	}

    setCoolTime(coolTime = this.CoolTime)
    {
        this.lastCoolTime = coolTime;
        this.startAt = this.ageInTicks + coolTime;
    }
}class AI_SummonEntities
{
	constructor(summonTypes, summonInfo, onlyOnaggressive)
	{
		this.name = "SummonEntities";
		this.onlyOnaggressive = onlyOnaggressive;
		this.summonTypes = summonTypes || null;
		
		var def_summonInfo = 
			{
				summonDelayMin: 5,
				summonDelayMax: 10,
				summonCountMin: 1,
				summonCountMax: 1,
				summonRange: 200,
				summonNumbers: 20,
				entityStats: null
			};
			
		this.summonCharge = 0;
		this.summonNumber = 0;
		
		for(var property in def_summonInfo)
		{
			this[property] = def_summonInfo[property];
		}
		
		if(summonInfo)
		{
			for(var property in summonInfo)
			{
				this[property] = summonInfo[property];
			}
		}
		this.summonDelay = MathHelper.randomInRange(this.summonDelayMin * Main.FPS, this.summonDelayMax * Main.FPS);
	}
	
	Update(owner)
	{
		if( (this.onlyOnaggressive && !owner.aggressive) || (this.summonNumber >= this.summonNumbers))
		{
			return;
		}
		var f = Main.FPS;
		
		if (this.summonCharge >= this.summonDelay)
		{
			if(this.summonTypes)
			{
				this.Summon(owner);
				this.summonCharge = 0;
				this.summonDelay = MathHelper.randomInRange(this.summonDelayMin * f, this.summonDelayMax * f);
			}
		}
		else
		{
			this.summonCharge++;
		}
	}
	
	Summon(owner)
	{
		var enemies = MathHelper.randomInRange(this.summonCountMin, this.summonCountMax);
		
		for(var i = 0; i < enemies; i++)
		{
			var entityType = MathHelper.randomInRange(0, this.summonTypes.length - 1);
			
			this.summonNumber++;
			while(true)
			{
				var pos = MathHelper.getRandomPointInRange([owner.x, owner.y], this.summonRange);
				var distance = MathHelper.GetDistance([pos.x, pos.y], [World.CenterPoint.x, World.CenterPoint.y]);

				if(distance < World.Radius - 30)
				{
					break;
				}
			}
			
			var entity = new this.summonTypes[entityType](pos.x, pos.y);
			if(this.entityStats)
			{
				for(var property in this.entityStats)
				{
					entity[property] = this.entityStats[property];
				}
			}
			World.AddEntity(entity);
		}
	}
}class AI_Talk
{
	constructor(owner)
	{
		this.name = "Talk";
		this.detectRadius = (owner.width * owner.Scale) + 100;

		owner.GetDialogLine = function(){return Dialog.DialogLines[this.dialogLine]};
		owner.onDialogStart = function()
		{
			var id = this.getId();
			var data = World.Player.NPCData[id];
			if(!data) data = Player.CreateNPCData();

			data.met = true;
			data.interactions++;

			World.Player.NPCData[id] = data;
			Save();
		}
	}
	
	Update(owner)
	{	
		if(owner.isTrading) return;

		var distance = MathHelper.GetDistance([owner.x, owner.y], [World.Player.x, World.Player.y]);
		owner.quote = null;

		if(distance <= this.detectRadius)
		{
			if(!World.Player.interactionWith)
			{
				owner.quote = ['Press [' + Settings.Controls.Interact + '] to talk.'];
			}
			World.Player.canInteractWith.push(owner);
		}
		else if(World.Player.interactionWith != owner)
		{
			var name = owner.getDisplayName();
			owner.quote = name;
		}
		
		if(World.Player.interactionWith == owner)
		{
			owner.allowMove = false;
			owner.moveX = 0;
			owner.moveY = 0;
			if(owner.allowRotationChange) owner.Rotation = MathHelper.getAngle2(owner, World.Player)+90;
		}
	}
}class AI_TradeAble
{
	constructor(owner, slots = 63)
	{
		this.name = "TradeAble";
		this.Owner = owner;

		owner.inventory = [];
		owner.transactionValue = 0;
		if(!owner.stats) owner.stats = {};
		owner.stats.availableSlots = slots;

		for(var i = 0; i < owner.stats.availableSlots; i++)
		{
			owner.inventory[i] = null;
		}

		owner.addItemToInventory = this.addItemToInventory;
		owner.Buy = this.Buy;
		owner.Sell = this.Sell;
		owner.sellCountable = this.sellCountable;
		owner.Trade = this.Trade;
		owner.endTrade = this.endTrade;
	}

	Trade()
	{
		this?.onTrade();
		this.isTrading = true;
		World.Player.interactionWith = this;

		this.transactionValue = 0;
	}

	endTrade()
	{
		this.isTrading = false;
		World.Player.interactionWith = null;

		if(this.transactionValue)
		{
			//particles
		}
	}

	Update(owner)
	{
		if(owner.isTrading)
		{
			owner.allowMove = false;
			owner.moveX = 0;
			owner.moveY = 0;
			if(owner.allowRotationChange) owner.Rotation = MathHelper.getAngle2(owner, World.Player)+90;
		}
	}

	Buy(item, itemOwner, fromHand = true, count = 0)
	{
		if(!item) return;
		if(!item.canBeSold) return;

		count = count || item.count;

		if(fromHand)
		{
			itemOwner.hand.count -= count;
			if(itemOwner.hand.count == 0) itemOwner.hand = null;
		}

		var priceInfo = ItemHelper.GetItemPrice(item, count);
		itemOwner.coins += priceInfo.sell;

		var new_item = ItemHelper.CopyItem(item);
			new_item.isInShop = true;
			new_item.count = count;

		this.addItemToInventory(new_item);

		this.transactionValue += priceInfo.sell;
	}

	Sell(slot, newOwner, toHand = false, count = 0)
	{
		var item = this.inventory[slot];
		if(!item) return;

		count = count || item.count;

		var price = ItemHelper.GetItemPrice(item, count).buy;
		if(newOwner.coins < price) return;


		var new_item = ItemHelper.CopyItem(item);
			new_item.isInShop = false;
			new_item.isFromMerchant = false;
			new_item.count = count;


		if(toHand)
		{
			newOwner.hand = new_item;
		}
		else
		{
			newOwner.addItemToInventory(new_item);
		}
		
		//only items from merchant are infinite
		if(!item.isFromMerchant)
		{
			this.inventory[slot].count -= count;
			if(this.inventory[slot].count == 0) this.inventory[slot] = null;
		}


		if(isNaN(price)) return;
		newOwner.coins -= price;

		this.transactionValue += price;
	}

	addItemToInventory(item, count = 0, fromMerchant = false)
	{
		if(typeof item === 'string')
		{
			//podano nazwe przedmiotu, a nie przedmiot
			item = Item.Get(item);
		}

		if(!item) return;
		item.count = count || item.count;
		if(fromMerchant) item.isFromMerchant = true;

		var stacked = false;

		if (item != null)
		{
			item.showNewItemInfo = false;
			
			for (var i = 0; i < this.stats.availableSlots; i++)
			{
				if (this.inventory[i] != null)
				{				//w danym slocie znajduje sie przedmiot
					if (item.constructor.name == this.inventory[i].constructor.name)
					{		//item from merchant cannot be stacked with ones sold by player
						if (item.stackAble && !this.inventory[i].isFromMerchant)
						{
							if (this.inventory[i].count < this.inventory[i].maxStackSize)
							{
								if ((this.inventory[i].count + item.count) <= this.inventory[i].maxStackSize)
								{
									this.inventory[i].count += item.count;
									this.inventory[i].showNewItemInfo = true;
									stacked = true;
									break;
								}
								else
								{
									this.inventory[i].count += item.count;
									item.count = Math.abs(this.inventory[i].count - this.inventory[i].maxStackSize);
									this.inventory[i].count = this.inventory[i].maxStackSize;
									continue;
								}
							}
						}
					}
				}
			}


			if (!stacked)
			{
				for (var i = 0; i < this.stats.availableSlots; i++)
				{
					if (this.inventory[i] == null)
					{		//wartosc w inventory jest pusta
						this.inventory[i] = item;
						break;
					}
				}
			}
		}
	}
}class AI_Walk
{
	constructor(BounceOnBorderHit = true)
	{
		this.name = "Walk";
		this.BounceOnBorderHit = BounceOnBorderHit;
	}
	
	Update(owner)
	{	
		if(!owner.allowMove) return;

		owner.x += owner.moveX * Main.DELTA;
		owner.y += owner.moveY * Main.DELTA;

		if(owner.ignoreBorder || !this.BounceOnBorderHit || owner.AI.Bounce) return;
		
		var distance = MathHelper.GetDistance([owner.x, owner.y], [World.CenterPoint.x, World.CenterPoint.y]);
		if( (distance > World.Radius-20) && (distance < World.Radius + 20)) 
		{
			owner.moveX *= -1;
			owner.moveY *= -1;
		}
	}
}class AI_Wander
{
	constructor(onlyOnPeaceful = true, directionChangeDelayMin = 10, directionChangeDelayMax, additionalData = {})
	{
		this.name = "Wander";
		this.directionChangeDelayMin = directionChangeDelayMin;
		this.directionChangeDelayMax = directionChangeDelayMax ?? directionChangeDelayMin;

		this.timeSinceChange = MathHelper.randomInRange(0, this.directionChangeDelayMin * Main.FPS);
		this.onlyOnPeaceful = onlyOnPeaceful;
		this.changeDelay = this.directionChangeDelayMin * Main.FPS;
		// this.maxDistance = 1000;
		this.end = null;
		this.lastUpdated = false;
		this.fixedSteps = null;
		this.SPD = null;

		this.firstChangeAwait = null;
		this.ageInTicks = 0;

		this.fixedAngle = null;

		this.R = null;
		this.r = null;

		for(var i in additionalData)
		{
			this[i] = additionalData[i];
		}
	}
	
	Update(owner)
	{
		this.ageInTicks++;
		if(!owner.allowMove) return;
		if(this.onlyOnPeaceful && owner.aggressive) 
		{
			if(this.lastUpdated) this.clearMove(owner);
			return;
		}
		if(this.firstChangeAwait && this.firstChangeAwait > this.ageInTicks) return;
		if(this.updateTrigger && !this.updateTrigger(owner)) return;
		
		this.timeSinceChange++;


		var spd = (this.SPD || owner.getSPD());
		var step = Main.DELTA * spd;
		
		if(this.timeSinceChange >= this.changeDelay || !this.end)
		{
			var r = this.r ?? 0;
			var R = this.R ?? World.Radius-100;

			if(!this.fixedSteps)
			{
				this.end = MathHelper.getRandomPointInRange(World.CenterPoint, R, r);
			}
			else
			{
				var tries = 0;
				var angle = this.fixedAngle ?? MathHelper.randomInRange(0, 360);
				
				//entity will wander by fixed distance
				while(true)
				{
					this.end = MathHelper.lineToAngle([owner.x, owner.y], this.fixedSteps, angle);

					//check if new destination is inside room
					if(MathHelper.GetDistance(this.end, World.CenterPoint) <= R + 50) break;
					tries++;

					angle = MathHelper.randomInRange(0, 360);

					if(tries >= 50)
					{
						//cannot set new point with fixed distance, so set any
						this.end = MathHelper.getRandomPointInRange(World.CenterPoint, R, r);
						break;
					}
				}
			}
			
			this.timeSinceChange = 0;
			this.setDelay();
			this.waitForNewPoint = false;
		}

		
		var motion = Motion.Get([owner.x, owner.y], [this.end.x, this.end.y], spd);
		if(owner.allowRotationChange) owner.Rotation = motion.angle + 90 + owner.defaultRotation;

		if(!this.waitForNewPoint)
		{
			owner.moveX = motion.x;
			owner.moveY = motion.y;
		}

		
		this.lastUpdated = true;

		var distance = MathHelper.GetDistance([owner.x, owner.y], [this.end.x, this.end.y]);	
		if(distance < step)
		{
			this.clearMove(owner);
			owner.onWanderDestination?.();
			return;
		}

		distance = MathHelper.GetDistance([owner.x, owner.y], [World.CenterPoint.x, World.CenterPoint.y]);
		if(distance >= World.Radius - 50)
		{
			owner.moveX *= -1;
			owner.moveY *= -1;
			this.changeDir();
		}
	}

	clearMove(owner)
	{
		owner.moveX = 0;
		owner.moveY = 0;
		this.waitForNewPoint = true;
	}

	changeDir()
	{
		this.timeSinceChange = this.changeDelay * Main.FPS;
		this.setDelay();
	}

	setDelay()
	{
		var min = this.directionChangeDelayMin * Main.FPS;
		var max = this.directionChangeDelayMax * Main.FPS;
		this.changeDelay = MathHelper.randomInRange(min, max);
	}
}class AI_Jump extends AI_Wander
{
	constructor(onlyOnPeaceful = true, directionChangeDelayMin = 10, directionChangeDelayMax, focusIfAggressive, data)
	{
		super(onlyOnPeaceful, directionChangeDelayMin, directionChangeDelayMax, data);

		this.name = "Jump";
		this.lastJump = false;

		this.focus = focusIfAggressive;
		this.focusPlayerOnPeaceful = data?.focusPlayerOnPeaceful ?? false;

		this.firstChangeAwait = MathHelper.randomInRange(5, this.directionChangeDelayMin * Main.FPS);
	}
	
	Update(owner)
	{
		owner.isJumping = false;
		this.fixedAngle = null;

		this.directionChangeDelayMin = owner.JumpDelay;
		this.directionChangeDelayMax = owner.JumpDelay;

		if(!this.fixedSteps) this.fixedSteps = owner.JumpDistance || owner.getSPD();
		this.SPD = this.fixedSteps / owner.JumpDuration;

		if(this.focus == Player && (owner.aggressive || this.focusPlayerOnPeaceful)) this.fixedAngle = MathHelper.getAngle2([owner.x, owner.y],[World.Player.x, World.Player.y]);
		if(this.focus == Entity) 
		{
			var entity = Entity.GetAvailableTargets(owner, this.fixedSteps);

			if(entity) this.fixedAngle = MathHelper.getAngle2([owner.x, owner.y],[entity.x, entity.y]);
		}

		super.Update(owner);

		if(this.timeSinceChange <= owner.JumpDuration*Main.FPS) owner.isJumping = true;
		if(this.timeSinceChange == 0)
		{
			owner.onJumpStart?.();
		}

		owner.toJumpProgress = this.timeSinceChange / this.changeDelay * 100;


		this.setOwnerScale(owner);

		if(this.lastJump && !owner.isJumping && this.ageInTicks > 5) 
		{
			if(owner.shakeOnJump) Camera.Shake(owner.shakeOnJump, false, 20);
			owner.onJumpEnd?.();
		}
		

		//add shadows

		this.lastJump = owner.isJumping;
	}

	setOwnerScale(owner)
	{
		if(!owner.isJumping)
		{
			owner.additionalScaleMultiplier = 1;
			return;
		}

		var s = 1;
		var additional_scale = .25;
		var jump_progress = this.timeSinceChange / (owner.JumpDuration * Main.FPS);
		var inc_scale_time = .4;
		var inc_scale_duration = (owner.JumpDuration * Main.FPS * inc_scale_time);
		
		if(jump_progress <= inc_scale_time) s += (this.timeSinceChange / inc_scale_duration) * additional_scale;
		if(jump_progress > inc_scale_time) s += additional_scale;
		if(jump_progress >= 1-inc_scale_time) s = 1 + (((owner.JumpDuration * Main.FPS) - this.timeSinceChange) / inc_scale_duration) * additional_scale;

		owner.additionalScaleMultiplier = s;
	}
}class Effect_DefBreak extends Effect
{
	constructor(strength, time, hideParticles)
	{
		super(strength, time, hideParticles);
		this.Icon = 'effect_dec_def';
	}

	Update(owner, effects)
	{
		super.Update(owner, effects);
        if(owner.Immunity.DEF_BREAK || owner.Immunity.ALL) return;

		owner.DefBreak = this.Strength;
	}

	onClear()
	{
		if(this.Owner) this.Owner.DefBreak = 0;
	}
}
Effects.Initialize(Effect_DefBreak);class Effect_Invincibility extends Effect
{
	constructor(strength, time, hideParticles)
	{
		super(strength, time, hideParticles);

        this.keepStrongest = false;
	}

	Update(owner, effects)
	{
		super.Update(owner, effects);

        owner.isInvincible = true;
        owner.canBeKnockedBack = false;

        var t = (owner == World.Player) ? 3 * Main.FPS : Main.FPS;
        this.shield.isEnding = (this.ageInTicks >= this.Time - t) ? true : false;
	}

    onApply(owner)
    {
        this.shield = new EntityInvincibleShield(owner.x, owner.y, owner);
        if(owner == World.Player) this.shield.isFromPlayer = true;

        this.ownerKnock = owner.canBeKnockedBack;
        World.AddEntity(this.shield);
    }

    onClear()
	{
		if(this.Owner)
        {
            this.Owner.isInvincible = false;
            this.Owner.canBeKnockedBack = this.ownerKnock;
        }

        this.shield.Kill();
	}
}
Effects.Initialize(Effect_Invincibility);class Effect_KnockBack extends Effect
{
	constructor(strength, time, direction)
	{
		super(strength, time * 2, true);

        this.Direction = direction;
        this.keepStrongest = false;
        this.showIcon = false;
	}

	Update(owner, effects)
	{
		super.Update(owner, effects);
        if(!owner.canBeKnockedBack) return;

        if(this.ageInTicks == 1) owner.onKnockBack?.();

        var resistance = owner.knockBackResistance ?? 0;
        var s = Math.sqrt(100 - this.durationPercent) / 10;

        var spd = 300 * this.Strength * s * (1-resistance);

        var move = Motion.Get([owner.x, owner.y], MathHelper.lineToAngle([owner.x, owner.y], spd, this.Direction), spd);

        var x = owner.x + move.x * Main.DELTA;
        var y = owner.y + move.y * Main.DELTA;

        var distance = MathHelper.GetDistance([x, y], [World.CenterPoint.x, World.CenterPoint.y]);
        if(distance > World.Radius - 20) return;

        owner.x = x;
        owner.y = y;
	}
}
Effects.Initialize(Effect_KnockBack);class Effect_Poisoning extends Effect
{
	constructor(strength, time, hideParticles)
	{
		super(strength, time, hideParticles);
		this.Icon = 'effect_poisoning';
	}

	Update(owner, effects)
	{
		super.Update(owner, effects);
		if(owner.Immunity[ELEMENT.POISON] || owner.Immunity.ALL) return;

		owner.isPoisoned = true;

		var time = Main.FPS / 2;

		if(this.Strength && this.ageInTicks % time == 0)
			owner.Hurt(this.Strength, this, {ELEMENT: ELEMENT.POISON, IGNORE_REDUCTION: true, ALWAYS_HURT: true});

		if(!this.hideParticles && this.ageInTicks % 5 == 0) this.SummonParticle();
	}

	SummonParticle()
	{
		var owner = this.Owner;
		var scale = 1 * MathHelper.randomInRange(75, 125) / 100 * owner.Scale;
		var r = (owner.Width / 2 * owner.Scale);
		var x = owner.x + MathHelper.randomInRange(-r, r);
		var y = owner.y + MathHelper.randomInRange(-r, r);
		var spd = 50;

		Particle.Summon('effect.poison', x, y, x, y-500, scale, spd, 1, 20, 
		{
			liveTime: 60, 
			// owner: owner,
			baseScale: scale,
			center: true,
			// globalAlpha: 0.5,
			// RENDER_LAYER: Graphic.Layer.Particle0,
			onUpdate: function(){this.Scale = (this.baseScale * (this.ageInTicks / this.liveTime))}
		});
	}

	onClear()
	{
		if(this.Owner) this.Owner.isPoisoned = false;
	}
}
Effects.Initialize(Effect_Poisoning);class Effect_Regeneration extends Effect
{
	constructor(strength, time, hideParticles)
	{
		super(strength, time, hideParticles);
		this.Icon = 'effect_regeneration';
	}

	Update(owner, effects)
	{
		super.Update(owner, effects);

		var time = Main.FPS;
		var showIndicator = false;

		if(this.ageInTicks % time == 0)
		{
			owner.Heal(this.Strength, false, !this.hideParticles);
		}
	}
}
Effects.Initialize(Effect_Regeneration);class Effect_Slow extends Effect
{
	constructor(strength, time, hideParticles)
	{
		super(strength, time, hideParticles);
		this.Icon = 'effect_slow';
	}

	Update(owner, effects)
	{
		super.Update(owner, effects);
        if(owner.Immunity.SLOW || owner.Immunity.ALL) return;

		owner.Slow = this.Strength;

		if(!this.hideParticles && this.ageInTicks % 5 == 0) this.SummonParticle();
	}

	onApply(owner)
    {
		if(owner == World.Player)
		{
			owner.velocityX = 0;
			owner.velocityY = 0;
		}
    }

	SummonParticle()
	{
		var owner = this.Owner;
		var scale = .5 * MathHelper.randomInRange(75, 125) / 100 * owner.Scale;
		var r = (owner.Width / 2 * owner.Scale);
		var x = owner.x + MathHelper.randomInRange(-r, r);
		var y = owner.y + MathHelper.randomInRange(-r, r);
		var spd = 30;

		Particle.Summon('effect.slow', x, y, x, y+500, scale, spd, 1, 20, 
		{
			liveTime: 60, 
			// owner: owner,
			baseScale: scale,
			center: true,
			// globalAlpha: 0.5,
			// RENDER_LAYER: Graphic.Layer.Particle0,
			// onUpdate: function(){this.Scale = (this.baseScale * (this.ageInTicks / this.liveTime))}
		});
	}

	onClear()
	{
		if(this.Owner) this.Owner.Slow = 0;
	}
}
Effects.Initialize(Effect_Slow);class Effect_Stun extends Effect
{
	constructor(strength, time, hideParticles)
	{
		super(strength, time, hideParticles);

        this.keepStrongest = false;
	}

	Update(owner, effects)
	{
		super.Update(owner, effects);
        if(owner.Immunity.STUN || owner.Immunity.ALL) 
        {
            this.toClear = true;
            return;
        }

        owner.allowMove = false;
        owner.allowControl = false;
        owner.isStunned = true;
	}

    onClear()
	{
		if(this.Owner)
        {
            this.Owner.allowMove = true;
            this.Owner.allowControl = true;
            this.Owner.isStunned = false;
        }
	}

    Render(context, owner)
    {
        if(this.hideParticles) return;

        var texture = TextureManager.Get('effect.stun');
        var alpha = 1;
        var scale = 1 * owner.Scale;
        var tY = 32 * owner.Scale;
        var x =  owner.x - Camera.xView;
        var y = owner.y - Camera.yView;
        var speed = 4;
        var frame = Math.floor((owner.ageInTicks%(15*speed))/speed);

        Graphic.DrawRotatedAnimatedImage(context, frame, [5, 3], 'XY', 
            texture, x, y - tY, 64, 64, scale, 0, alpha);
    }
}
Effects.Initialize(Effect_Stun);class Graphic
{
    static Initialize()
    {
        this.tCanvas = document.createElement("canvas");
        this.tCtx = this.tCanvas.getContext("2d");
        this.canvasList = [];
        this.contextList = [];

        this.postRenderFunctions = [];
        this.lightSources = [];

        this.layersInfo = {};

        this.Layer = 
        {
            BackgroundDecoration: 0,
            Background: 1,
            Particle0: 2,
            Main: 3,
            Particle: 4,
            LightLevel: 5,
            LightLevel2: 6,
            GUI: 7
        };


        this.mainCanvas = document.getElementById('canvas');
        this.mainCanvas.style.setProperty('--index', this.Layer.Main);
        this.mainCtx = this.mainCanvas.getContext('2d');

        this.canvasList[this.Layer.Main] = this.mainCanvas;
        this.contextList[this.Layer.Main] = this.mainCtx;
        this.layersInfo[this.Layer.Main] = 
        {
            visible: true,
            scale: 1,
            opacity: 1,
            name: 'Main'
        };

        this.usedLayers = [];
        this.activeLayer = 0;
        this.lastLayer = this.activeLayer;

        window.canvas = this.mainCanvas;
		window.ctx = this.mainCtx;

        this.ChangeLayer();
    }

    static createEntityPreview(entity)
    {
        var size = 1024;
        if(entity.scale > 5) size = 2048;
        this.setTempCanvas(size, size);

        var _ctx = this.tCtx;

        entity.x = 512 + Camera.xView;
        entity.y = 512 + Camera.yView;
        entity.NoAI = true;
        entity.isBoss = false;
        entity.HP = entity.MAXHP;

        entity.Model?.Update();
        entity.Render(_ctx);

        return this.cropEntityPreview(_ctx, entity);
    }

    static cropEntityPreview(ctx, entity)
    {
        var data = this.cropImageFromCanvas(ctx, true);

        entity.x -= data.cropStart.x;
        entity.y -= data.cropStart.y;
        entity.Transparency = 1;
        entity.cropData = data;
        

        return data.canvas;
    }

    static cropImageFromCanvas(ctx, getData = false) 
    {
        var data = {};
        var canvas = ctx.canvas, 
          w = canvas.width, h = canvas.height,
          pix = {x:[], y:[]},
          imageData = ctx.getImageData(0,0,canvas.width,canvas.height),
          x, y, index;

        for (y = 0; y < h; y++) {
          for (x = 0; x < w; x++) {
            index = (y * w + x) * 4;
            if (imageData.data[index+3] > 0) {
              pix.x.push(x);
              pix.y.push(y);
            } 
          }
        }
        pix.x.sort(function(a,b){return a-b});
        pix.y.sort(function(a,b){return a-b});
        var n = pix.x.length-1;
        
        w = 1 + pix.x[n] - pix.x[0];
        h = 1 + pix.y[n] - pix.y[0];

        if(isNaN(w) || isNaN(h)) return canvas;

        data.cropStart = {x: pix.x[0], y: pix.y[0]};
        data.newSize = {width: w, height: h};

        var cut = ctx.getImageData(pix.x[0], pix.y[0], w+1, h+1);
      
        canvas.width = w;
        canvas.height = h;
        ctx.putImageData(cut, 0, 0);

        if(!getData) return canvas;
        
        data.canvas = canvas;
        return data;
      }

    static DrawRotatedAnimatedImage(context, frame = 0, frames = 1, axis = 'Y', texture, x, y, width, height, scale = 1, rotation = 0, alpha = 1, tX = 0, tY = 0, ctxFunc = null, data = {})
    {
        axis = axis.toUpperCase();
        if(!isInt(frame)) frame = Math.round(frame);

        var clipWidth = (axis == 'X') ? texture.width / frames : texture.width;
        var clipHeight = (axis == 'Y') ? texture.height / frames : texture.height;

        var startX = (axis == 'X') ? clipWidth * frame : 0;
        var startY = (axis == 'Y') ? clipHeight * frame : 0;


        if(axis == 'XY')
        {
            clipWidth = texture.width / frames[0];
            clipHeight = texture.height / frames[1];

            var fX = frame%frames[0];
            var fY = Math.floor(frame/frames[0]);

            startX = clipWidth * fX;
            startY = clipHeight * fY;
        }

        if(data.clipWidth) clipWidth += data.clipWidth;
        if(data.clipHeight) clipHeight += data.clipHeight;

        if(data.startX) startX += data.startX;
        if(data.startY) startY += data.startY;


        context.save();
        if(isFunction(ctxFunc)) ctxFunc(context);
		context.translate(x, y);
		context.rotate(rotation * Math.PI/180);
		context.globalAlpha = alpha;

        context.drawImage(
            texture, startX, startY, clipWidth, clipHeight,
            -((width / 2) + tX) * scale, -((height / 2)  + tY) * scale,
            (width * scale), (height * scale)
        );

        context.restore();
    }

    static DrawRotatedImage(context, texture, x, y, width, height, scale = 1, rotation = 0, alpha = 1, tX = 0, tY = 0, ctxFunc = null)
    {
        Graphic.DrawRotatedAnimatedImage(context, 0, 1, 'Y', texture, x, y, width, height, scale, rotation, alpha, tX, tY, ctxFunc);
    }

    static ApplyShineEffect(x, y, size = 40, alpha = 1, rotation = 0)
    {
        var texture = TextureManager.Get('particleShine');

        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(rotation * Math.PI/180);
        ctx.globalAlpha = alpha;
        ctx.drawImage(texture, 0, 0, texture.width, texture.height, -size / 2, -size / 2, size, size);
        ctx.restore();
    }

    static Clear()
    {
        if(this.usedLayers.length > 0)
        {
            this.usedLayers.sort();

            for(var i = 0; i < this.usedLayers.length; i++)
            {
                var layer = this.usedLayers[i];
                if(this.canvasList[layer].width != this.mainCanvas.width) this.canvasList[layer].width = this.mainCanvas.width;
                if(this.canvasList[layer].height != this.mainCanvas.height) this.canvasList[layer].height = this.mainCanvas.height;
                
                this.contextList[layer].clearRect(0, 0, this.mainCanvas.width, this.mainCanvas.height);
            }
        }

        this.ChangeLayer();
    }

    static Render()
    {
        for(var layer in this.postRenderFunctions)
        {
            for(var i = 0; i < this.postRenderFunctions[layer].length; i++)
            {
                this.postRenderFunctions[layer][i][0](this.postRenderFunctions[layer][i][1]);
            }
        }

        this.postRenderFunctions = [];
    }

    static addPostRenderFunction(layer = this.activeLayer, method, params)
    {
        if(!this.postRenderFunctions[layer]) this.postRenderFunctions[layer] = [];
        this.postRenderFunctions[layer].push([method, params]);
    }

    static CreateLayer(layer)
    {
        this.canvasList[layer] = document.createElement("canvas");
        this.canvasList[layer].style.setProperty('--index', layer);
        this.canvasList[layer].width = this.mainCanvas.width;
        this.canvasList[layer].height = this.mainCanvas.height;
        this.layersInfo[layer] = 
        {
            visible: true,
            scale: 1,
            opacity: 1,
            name: layer
        };
        document.getElementById('render_layers').appendChild(this.canvasList[layer]);

        for(var name in this.Layer)
        {
            if(this.Layer[name] == layer)
            {
                this.layersInfo[layer].name = name;
                this.canvasList[layer].dataset.id = name;
                break;
            }
        }

        if(!this.contextList[layer]) this.contextList[layer] = this.canvasList[layer].getContext("2d");
    }

    static ChangeLayer(layer = this.Layer.Main)
    {
        this.lastLayer = this.activeLayer;
        this.activeLayer = layer;
        
        if(!this.canvasList[layer]) this.CreateLayer(layer);

        canvas = this.canvasList[layer];
        ctx = this.contextList[layer];

        if(!this.usedLayers.includes(layer)) this.usedLayers.push(layer);  
    }

    static RestoreLayer()
    {
        this.ChangeLayer(this.lastLayer);
    }
	
	 /**
	 * Draws a rounded rectangle using the current state of the canvas.
	 * If you omit the last three params, it will draw a rectangle
	 * outline with a 5 pixel border radius
	 * @param {CanvasRenderingContext2D} ctx
	 * @param {Number} x The top left x coordinate
	 * @param {Number} y The top left y coordinate
	 * @param {Number} width The width of the rectangle
	 * @param {Number} height The height of the rectangle
	 * @param {Number} [radius = 5] The corner radius; It can also be an object 
	 *                 to specify different radii for corners
	 * @param {Number} [radius.tl = 0] Top left
	 * @param {Number} [radius.tr = 0] Top right
	 * @param {Number} [radius.br = 0] Bottom right
	 * @param {Number} [radius.bl = 0] Bottom left
	 * @param {Boolean} [fill = false] Whether to fill the rectangle.
	 * @param {Boolean} [stroke = true] Whether to stroke the rectangle.
	 */
	static roundRect(context, x, y, width, height, radius = 5, fill = false, stroke = true)
	{		
		var size = height;
		if(width < height)
		{
			size = width;
		}
		size += context.lineWidth;

		if(radius > size / 2)
		{
			//zapobiega rysowaniu obramowania wiekszego niz maksymalne
			radius = Math.floor(size / 2);
		}
	
		if (typeof radius === 'number')
		{
			radius = {tl: radius, tr: radius, br: radius, bl: radius};
		}
		else
		{
			var defaultRadius = {tl: 0, tr: 0, br: 0, bl: 0};
			for (var side in defaultRadius)
			{
				radius[side] = radius[side] || defaultRadius[side];
			}
		}
		
		context.beginPath();
		context.moveTo(x + radius.tl, y);
		context.lineTo(x + width - radius.tr, y);
		context.quadraticCurveTo(x + width, y, x + width, y + radius.tr);
		context.lineTo(x + width, y + height - radius.br);
		context.quadraticCurveTo(x + width, y + height, x + width - radius.br, y + height);
		context.lineTo(x + radius.bl, y + height);
		context.quadraticCurveTo(x, y + height, x, y + height - radius.bl);
		context.lineTo(x, y + radius.tl);
		context.quadraticCurveTo(x, y, x + radius.tl, y);
		context.closePath();
		
		if (fill)
		{
			context.fill();
		}
		
		if (stroke)
		{
			context.stroke();
		}
    }
    
    static ApplyMask(image, color, alpha = 1)
    {
        if(typeof image === "string") 
        {
            image = TextureManager.Get(image);
        }
        this.setTempCanvas(image.width, image.height);

        if(color instanceof Color)
        {
            color = color.toString();
        }

        this.tCtx.save();
        this.tCtx.globalAlpha = alpha;
        this.tCtx.fillStyle = color;
        this.tCtx.fillRect(0, 0, image.width, image.height);
        this.tCtx.globalCompositeOperation = "destination-atop";
        this.tCtx.drawImage(image, 0, 0);
        this.tCtx.restore();

        return this.tCanvas;
    }

    static addLightSource(x, y, r, type = 'CIRCLE', width, endX, endY)
    {
        this.lightSources.push({x, y, r, type, width, endX, endY});
    }

    static RenderLightLevelShader(lightLevelInfo)
	{
        if(!lightLevelInfo) return;

        var x, y, r, width;

        var overallDarkness = lightLevelInfo.overallDarkness;
        var lightSourcesRange = lightLevelInfo.lightSourcesRange;
        var lightSourcesStrength = 1 * lightLevelInfo.lightSourcesStrength;

        overallDarkness -= (1 - lightSourcesStrength) / 5;

        ChangeLayer(this.Layer.LightLevel);

            ctx.save();
            ctx.globalAlpha = overallDarkness;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.restore();


            for(var i = 0; i < this.lightSources.length; i++)
            {
                var source = this.lightSources[i];
                x = source.x;
                y = source.y;
                r = source.r * lightSourcesRange;
                width = source.width * lightSourcesRange;

                if(source.type == 'CIRCLE')
                {
                    ctx.save();
                    ctx.globalCompositeOperation = "destination-out";
                    ctx.beginPath();
                    ctx.arc(x, y, r, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.closePath();
                    ctx.restore();
                }
                else if(source.type == 'LINE')
                {
                    ctx.save();
                    ctx.globalCompositeOperation = "destination-out";
                    ctx.beginPath();

                    ctx.moveTo(x, y);
                    ctx.lineTo(source.endX, source.endY);
                    ctx.lineWidth = width * 2;
                    ctx.stroke();

                    ctx.closePath();
                    ctx.restore();
                }

                
            }


            if(lightSourcesStrength < 1)
            {
                ctx.save();
                ctx.globalAlpha = 1 - lightSourcesStrength;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.restore();
            }

		RestoreLayer();


        if(lightLevelInfo.overallDarkness < 1)
        {
            //hide enemies
            ChangeLayer(this.Layer.Main);
            
                ctx.save();
                ctx.globalCompositeOperation = "destination-out";
                ctx.drawImage(this.canvasList[this.Layer.LightLevel], 0, 0, canvas.width, canvas.height);
                ctx.restore();

            RestoreLayer();
        }

        this.lightSources = [];
	}

    static hideShaders()
    {
        var shaders = document.querySelectorAll('.shader');
        shaders.forEach(e => e.dataset.open = 'false');
    }

    static showShader(id)
    {
        var shader = document.getElementById('shader_' + id);
        if(shader) shader.dataset.open = true;
    }

    static ApplyFullscreen()
    {
        if(Settings.Video.isFullscreen)
		{
			var element = document.body;

			element.requestFullscreen()
			.then(function() {
				// element has entered fullscreen mode successfully
			})
			.catch(function(error) {
				// element could not enter fullscreen mode
				// error message
				console.log(error.message);
			});
		}
		else
		{
			if(document.fullscreenElement)
			{
				document.exitFullscreen()
				.then(function() {
					// element has exited fullscreen mode
				})
				.catch(function(error) {
					// element could not exit fullscreen mode
					// error message
					console.log(error.message);
				});
			}
		}
    }

    static ModelToImage(model)
    {
        var width = model.Width;
        var height = model.Height;

        this.setTempCanvas(width, height);

        model.Update();
        model.Render(this.tCtx);

        var img = new Image(width, height);
            img.src = this.tCanvas.toDataURL();

        document.body.appendChild(img);

        return img;
    }

    static setTempCanvas(width, height)
    {
        this.tCanvas = document.createElement("canvas");
        this.tCtx = this.tCanvas.getContext("2d");
        this.tCanvas.width = width;
        this.tCanvas.height = height;

        this.tCtx.clearRect(0, 0, width, height);
    }


    static MatchPattern(imageData, pattern, returnAsData = false)
    {
        if(isImage(imageData))
        {
            imageData = this.getImageData(imageData);
        }
        if(isImage(pattern))
        {
            pattern = this.getImageData(pattern);
        }

        var color = new Color(0, 255, 255, 255);

        var borderData = this.GetImageBorder(imageData, color, true);
        var shadowData = this.GetImageShadow(imageData, color, true);

        var patternData = new ImageData
        (
            new Uint8ClampedArray(imageData.width * imageData.height * 4),
            imageData.width,
            imageData.height
        );

        var result = this.CompareImageData(borderData, shadowData);

        for(var i = 0; i < result.length; i++)
        {
            if(!result[i])
            {
                var id = i * 4;

                patternData.data[id] = pattern.data[id];
                patternData.data[id+1] = pattern.data[id+1];
                patternData.data[id+2] = pattern.data[id+2];
                patternData.data[id+3] = pattern.data[id+3];
            }
        }


        imageData = patternData;

        if(returnAsData)
        {
            return imageData;
        }
        return this.ImageDataToImage(imageData);
    }

    static CreatePattern(type, data)
    {
        if(typeof Pattern[type] === "function")
        {
            return Pattern[type](this.tCanvas, data);
        }
    }

    static CompareImageData(imageData1, imageData2)
    {
        var result = [];

        for(var i = 0; i < imageData1.data.length; i+=4)
        {
            var r = imageData1.data[i];
            var g = imageData1.data[i+1];
            var b = imageData1.data[i+2];
            var a = imageData1.data[i+3];

            var r2 = imageData2.data[i];
            var g2 = imageData2.data[i+1];
            var b2 = imageData2.data[i+2];
            var a2 = imageData2.data[i+3];

            if(r == r2 && g == g2 && b == b2 && a == a2)
            {
                result.push(true);
            }
            else
            {
                result.push(false);
            }
        }

        return result;
    }

    static ReplaceImageColors(imageData, colors, colorsToReplace, twoWayReplace = false, returnAsData = false)
    {
        if(isImage(imageData))
        {
            imageData = this.getImageData(imageData);
        }
        imageData = this.CopyImageData(imageData);

        for(var i = 0; i < colors.length; i++)
        {
            var color = colors[i];
            var replaceColor = colorsToReplace[i];

            for(var j = 0; j < imageData.data.length; j+=4)
            {
                var r = imageData.data[j];
                var g = imageData.data[j+1];
                var b = imageData.data[j+2];
                var a = imageData.data[j+3];

                if(r == color.r && g == color.g && b == color.b && a == color.a)
                {
                    imageData.data[j] = replaceColor.r;
                    imageData.data[j+1] = replaceColor.g;
                    imageData.data[j+2] = replaceColor.b;
                    imageData.data[j+3] = replaceColor.a;
                }
                else if(twoWayReplace)
                {
                    if(r == replaceColor.r && g == replaceColor.g && b == replaceColor.b && a == replaceColor.a)
                    {
                        imageData.data[j] = color.r;
                        imageData.data[j+1] = color.g;
                        imageData.data[j+2] = color.b;
                        imageData.data[j+3] = color.a;
                    }
                }
            }
        }

        if(returnAsData)
        {
            return imageData;
        }
        return this.ImageDataToImage(imageData);
    }

    static CopyImageData(imageData)
    {
        var copy = new ImageData
        (
            new Uint8ClampedArray(imageData.data),
            imageData.width,
            imageData.height
        );

        return copy;
    }


    static GetImageBorder(imageData, color = new Color(0, 255, 255, 255), returnAsData = false)
    {
        if(isImage(imageData))
        {
            imageData = this.getImageData(imageData);
        }

        imageData = this.CopyImageData(imageData);


        var width = imageData.width;
        var height = imageData.height;

        var toCut = [];

        for(var i = 0; i < height; i++)
        {
            for(var j = 0; j < width; j++)
            {
                var id = (i * width + j) * 4;

                var r = imageData.data[id];
                var g = imageData.data[id+1];
                var b = imageData.data[id+2];
                var a = imageData.data[id+3];

                var leftR, leftG, leftB, leftA,
                    rightR, rightG, rightB, rightA,
                    upR, upG, upB, upA,
                    downR, downG, downB, downA;

                if(j > 0)
                {
                    var leftId = (i * width + j - 1) * 4;

                    leftR = imageData.data[leftId];
                    leftG = imageData.data[leftId+1];
                    leftB = imageData.data[leftId+2];
                    leftA = imageData.data[leftId+3];
                }

                if(j < width - 1)
                {
                    var rightId = (i * width + j + 1) * 4;

                    rightR = imageData.data[rightId];
                    rightG = imageData.data[rightId+1];
                    rightB = imageData.data[rightId+2];
                    rightA = imageData.data[rightId+3];
                }

                if(i > 0)
                {
                    var upId = ((i - 1) * width + j) * 4;

                    upR = imageData.data[upId];
                    upG = imageData.data[upId+1];
                    upB = imageData.data[upId+2];
                    upA = imageData.data[upId+3];
                }

                if(i < height - 1)
                {
                    var downId = ((i + 1) * width + j) * 4;

                    downR = imageData.data[downId];
                    downG = imageData.data[downId+1];
                    downB = imageData.data[downId+2];
                    downA = imageData.data[downId+3];
                }
  

                if(
                    (r != 0 || g != 0 || b != 0 || a != 0) &&
                    (
                        (
                            (j == 0) ||
                            (i == 0) ||
                            (i == height - 1) ||
                            (j == width - 1)
                        ) ||
                        (
                            (leftR == 0 && leftG == 0 && leftB == 0 && leftA == 0) ||
                            (rightR == 0 && rightG == 0 && rightB == 0 && rightA == 0) ||
                            (upR == 0 && upG == 0 && upB == 0 && upA == 0) ||
                            (downR == 0 && downG == 0 && downB == 0 && downA == 0)
                        )
                    )
                )
                {
                    imageData.data[id] = color.r;
                    imageData.data[id+1] = color.g;
                    imageData.data[id+2] = color.b;
                    imageData.data[id+3] = color.a;
                }
                else
                {
                    toCut.push(id);
                }
            }
        }

        for(var i = 0; i < toCut.length; i++)
        {
            id = toCut[i];

            imageData.data[id] = 0;
            imageData.data[id+1] = 0;
            imageData.data[id+2] = 0;
            imageData.data[id+3] = 0;
        }

        if(returnAsData)
        {
            return imageData;
        }
        return this.ImageDataToImage(imageData);
    }

    static GetImageShadow(imageData, color = new Color(255, 0, 0, 255), returnAsData = false)
    {
        if(isImage(imageData))
        {
            imageData = this.getImageData(imageData);
        }
        imageData = this.CopyImageData(imageData);

        for(var i = 0; i < imageData.data.length; i+=4)
        {
            var r = imageData.data[i];
            var g = imageData.data[i+1];
            var b = imageData.data[i+2];
            var a = imageData.data[i+3];

            if(r != 0 || g != 0 || b != 0 || a !=0)
            {
                imageData.data[i] = color.r;
                imageData.data[i+1] = color.g;
                imageData.data[i+2] = color.b;
                imageData.data[i+3] = color.a;
            }
        }

        if(returnAsData)
        {
            return imageData;
        }
        return this.ImageDataToImage(imageData);
    }

    static getImageData(image)
    {
        var width = image.width;
        var height = image.height;

        this.setTempCanvas(width, height);
        this.tCtx.drawImage(image, 0, 0, width, height);

        return this.tCtx.getImageData(0, 0, width, height);
    }


    static ImageDataToImage(imageData)
    {
        this.setTempCanvas(imageData.width, imageData.height);
        this.tCtx.putImageData(imageData, 0, 0);

        var img = new Image(imageData.width, imageData.height);
            img.src = this.tCanvas.toDataURL();

        return img;
    }

    static drawCircleWithBreaks(ctx, centerX, centerY, radius, breaks, breakSize, stroke, fill, startAngle = 0)
    {
        var angleStep = (360 - (breakSize * breaks) ) / breaks;

        var startAngle = startAngle + breakSize / 2;
        var endAngle = 0;

        
        for(var i = 0; i < breaks; i++)
        {
            endAngle = startAngle + angleStep;

            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, MathHelper.ToRadians(startAngle), MathHelper.ToRadians(endAngle));
            

            if (fill)
            {
                ctx.fill();
            }
            
            if (stroke)
            {
                ctx.stroke();
            }

            startAngle += angleStep + breakSize;
        }
        ctx.closePath();
    }


    static drawCircleWithBreaksOnSides(ctx, centerX, centerY, radius, Sides, breakSize, stroke, fill)
    {
        this.drawCircleWithBreaks(ctx, centerX, centerY, radius, 4, breakSize, stroke, fill);

        var startAngle = 0;
        var endAngle = 360;
        var angles = [];

        if(!Sides.top)
        {
            angles.push(270 - (breakSize / 2));
        }

        if(!Sides.left)
        {
            angles.push(180 - (breakSize / 2));
        }

        if(!Sides.bottom)
        {
            angles.push(90 - (breakSize / 2));
        }

        if(!Sides.right)
        {
            angles.push(0 - (breakSize / 2));
        }

        for(var i = 0; i < angles.length; i++)
        {
            startAngle = angles[i];
            endAngle = startAngle + breakSize;

            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, MathHelper.ToRadians(startAngle), MathHelper.ToRadians(endAngle));

            if (fill)
            {
                ctx.fill();
            }
            
            if (stroke)
            {
                ctx.stroke();
            }
        }
        ctx.closePath();
    }

    static WrapText(text, maxWidth, style)
    {
        var words = text.split(' '),
            lines = [],
            line = "";

        if (Style.GetTextSize(text, style).width < maxWidth) 
        {
            return [text];
        }

        while (words.length > 0) 
        {
            var split = false;
            while (Style.GetTextSize(words[0], style).width >= maxWidth) 
            {
                var tmp = words[0];
                words[0] = tmp.slice(0, -1);
                if (!split) 
                {
                    split = true;
                    words.splice(1, 0, tmp.slice(-1));
                } else 
                {
                    words[1] = tmp.slice(-1) + words[1];
                }
            }

            if (Style.GetTextSize(line + words[0], style).width < maxWidth) 
            {
                line += words.shift() + " ";
            } 
            else 
            {
                lines.push(line);
                line = "";
            }

            if (words.length === 0) 
            {
                lines.push(line);
            }
        }

        return lines;
    }

    static Shade(image, x, y, time, onEnd = null)
    {
        var step = 1 / time;

        var img = 
        {
            img: image,
            x: x,
            y: y,
            step: step,
            time: time,
            frame: 0,
            onEnd: onEnd
        };

        this.toShade.push(img);
    }
}

class Color
{
    constructor(r, g, b, a = 1)
    {
        this.r = r;
        this.g = g;
        this.b = b;
        this.a = a;
    }

    toString()
    {
        var a = this.a;
        if(this.a > 1)
        {
            a = this.a / 255;
        }
        return "rgba(" + this.r + ", " + this.g + ", " + this.b + ", " + a + ")";
    }
}

class Transition
{
    constructor(from, to, time, reverse = false, reverseDelay = 0, unreverseDelay, repeat = false)
    {
        this.ageInTicks = 1;
        this.reverseTicks = 0;
        this.dir = 1;
        this.To = to;
        this.From = from;
        this.Time = time * Main.FPS;
        this.step = (to - from) / this.Time;
        this.Reverse = reverse;
        this.Repeat = repeat;
        this.ReverseDelay = reverseDelay * Main.FPS;
        this.unreverseDelay = (unreverseDelay != undefined) ? unreverseDelay * Main.FPS : this.ReverseDelay;
        this.isReverseTick = false;
        this.isUnreverseTick = false;
    }

    RandomizeTicks()
    {
        this.ageInTicks = MathHelper.randomInRange(0, this.Time);
    }

    RandomizeDelay(useUnreverseDelay, percentage)
    {
        this.RandomizeStartUpDelay(useUnreverseDelay);
        this.RandomizeInTickDelay(useUnreverseDelay, percentage);
    }

    RandomizeInTickDelay(useUnreverseDelay = false, percentage = 10)
    {
        if(useUnreverseDelay)
        {
            this.randomUnreverseDelayPercentage = percentage;
        }
        else
        {
            this.randomReverseDelayPercentage = percentage;
        }  
    }

    RandomizeStartUpDelay(useUnreverseDelay = false)
    {
        if(useUnreverseDelay)
        {
            this.reverseTicks = MathHelper.randomInRange(0, this.unreverseDelay);
            this.dir = -1;
        }
        else
        {
            this.reverseTicks = MathHelper.randomInRange(0, this.ReverseDelay);
            this.dir = 1;
        }
    }

    Update()
    {
        this.isReverseTick = false;
        this.isUnreverseTick = false;

        if( (this.ageInTicks < this.Time) && (this.ageInTicks > 0))
        {
            this.ageInTicks += this.dir;
        }
        else
        {
            if(this.Repeat)
            {
                this.ageInTicks = 1;
                this.isReverseTick = true;
            }
            else if(this.Reverse)
            {
                if(this.dir == 1)
                {
                    if(this.reverseTicks > this.ReverseDelay)
                    {
                        this.ageInTicks = this.Time - 1;
                        this.reverseTicks = 0;
                        this.dir = -1;
                        this.isUnreverseTick = true;

                        if(this.randomUnreverseDelayPercentage)
                        {
                            var value = Math.round(this.unreverseDelay * this.randomUnreverseDelayPercentage / 100);
                            this.reverseTicks = MathHelper.randomInRange(0, value);
                        }
                    }
                    else
                    {
                        this.reverseTicks++;
                    }
                }
                else
                {
                    if(this.reverseTicks > this.unreverseDelay)
                    {
                        this.ageInTicks = 1;
                        this.reverseTicks = 0;
                        this.dir = 1;
                        this.isReverseTick = true;


                        if(this.randomReverseDelayPercentage)
                        {
                            var value = Math.round(this.ReverseDelay * this.randomReverseDelayPercentage / 100);
                            this.reverseTicks = MathHelper.randomInRange(0, value);
                        }
                    }
                    else
                    {
                        this.reverseTicks++;
                    }
                }
            }
        }
        
        return this.Get();
    }

    Get()
    {
        if(this.dir == 1)
        {
            return this.From + (this.step * this.ageInTicks);
        }
        return this.To - (this.step * (this.Time - this.ageInTicks));
    }
}

class Pattern
{
    static Grid(tCanvas, data, returnAsData)
    {
        var width = data.width || 0;
        var height = data.height || 0;
        var size = data.size || 0;
        var color = data.color || new Color(0, 0, 0, 0);
        var backgroundColor = data.backgroundColor || false;

        Graphic.setTempCanvas(width, height);
        var tCtx = tCanvas.getContext("2d");

        if(backgroundColor)
        {
            tCtx.save();
            tCtx.fillStyle = backgroundColor.toString();
            tCtx.fillRect(0, 0, width, height);
            tCtx.restore();
        }

        for(var i = 0; i < height; i+= size)
        {
            tCtx.save();
            tCtx.fillStyle = color.toString();
            tCtx.fillRect(0, i, width, 1);
            tCtx.restore();
        }

        for(var j = 0; j < width; j+= size)
        {
            tCtx.save();
            tCtx.fillStyle = color.toString();
            tCtx.fillRect(j, 0, 1, height);
            tCtx.restore();
        }

        var img = new Image(width, height);
            img.src = tCanvas.toDataURL();

        if(returnAsData)
        {
            return Graphic.getImageData(img);
        }
        return img;
    }
}




class LightLevel
{
    constructor(overallDarkness = .9, lightSourcesRange = 1, lightSourcesStrength = 1)
    {
        this.overallDarkness = overallDarkness;
        this.lightSourcesRange = lightSourcesRange;
        this.lightSourcesStrength = lightSourcesStrength;
    }
}class Helper
{
    static getDarkerColor(color, percentage = 20, toString = true)
    {
        if(color[0] == '#') color = Helper.hexToRgb(color);
        else if(color.includes('rgb'))
        {
            color = Helper.getRGBValues(color);
        }

        var darkerR = color.r - (color.r * percentage / 100);
        var darkerG = color.g - (color.g * percentage / 100);
        var darkerB = color.b - (color.b * percentage / 100);

        darkerR = Helper.toAllowedValue(darkerR, 'RGB');
        darkerG = Helper.toAllowedValue(darkerG, 'RGB');
        darkerB = Helper.toAllowedValue(darkerB, 'RGB');


        if(toString)
        {
            return 'rgb(' + darkerR + ', ' + darkerG + ', ' + darkerB + ')';
        }

        return {r: darkerR, g: darkerG, b:darkerB}
    }

    static GetLinesNumber(text)
    {
        var arr = text.split('\n');
        return arr.length;
    }

    static replaceAll(str, find, replace)
    {
        return str.replace(new RegExp(find, 'g'), replace);
    }

    static ApplyArguments(text, args = {})
    {
        var value;
        for(var name in args)
        {
            value = args[name];
            if(isFunction(value)) value = value();
            text = Helper.replaceAll(text, '{' + name + '}', value);
        }

        return text;
    }

    static toAllowedValue(value, type)
    {
        switch(type)
        {
            case 'RGB':
                if(value > 255) return 255;
                if(value < 0) return 0;
        }

        return Math.round(value);
    }

    static hexToRgb(color)
    {
        color = color.replace('#', '');

        var r = parseInt(color[0] + color[1], 16);
        var g = parseInt(color[2] + color[3], 16);
        var b = parseInt(color[4] + color[5], 16);

        return {r: r, g: g, b:b}
    }

    static getRGBValues(color)
    {
        if(!color.includes('rgb')) return {r: 0, g: 0, b: 0}

        color = color.replace('rgb', '');
        color = color.replace('a', '');
        color = color.replace('(', '');
        color = color.replace(')', '');

        var colors = color.split(',');

        return {r: colors[0].trim(), g: colors[1].trim(), b:colors[2].trim()}
    }

    static FuseObjectsValues()
    {
        var keys = [];
        for(var arg in arguments)
            keys = keys.concat(Object.keys(arguments[arg]));

        var obj = {};

        for(var i = 0; i < keys.length; i++)
        {
            var key = keys[i];
            obj[key] = 0;

            for(var arg in arguments)
                if(arguments[arg][key]) obj[key] += arguments[arg][key];
        }

        return obj;
    }

    static getEaster(year) {
        var f = Math.floor,
            // Golden Number - 1
            G = year % 19,
            C = f(year / 100),
            // related to Epact
            H = (C - f(C / 4) - f((8 * C + 13)/25) + 19 * G + 15) % 30,
            // number of days from 21 March to the Paschal full moon
            I = H - f(H/28) * (1 - f(29/(H + 1)) * f((21-G)/11)),
            // weekday for the Paschal full moon
            J = (year + f(year / 4) + I + 2 - C + f(C / 4)) % 7,
            // number of days from 21 March to the Sunday on or before the Paschal full moon
            L = I - J,
            month = 3 + f((L + 40)/44),
            day = L + 28 - 31 * f(month / 4);
    
        return {m: month, d: day};
    }

    static GetDeathQuote(killedBy = null)
    {
        var quote = "Omae wa mou shindeiru";
        if(killedBy?.deathQuote) return Lang.Get(killedBy.deathQuote);
        return Lang.Get(quote);
    }

    static isPercentageValue(value)
    {
        if(value[value.length - 1] == '%') return {is: true, value: value.replace('%', '') * 1};
        return {is: false, value: value};
    }
}

/**
 * Check for current difficulty level
 * @param {*} level 
 * @returns 
 * level = 0;   //Easy
 * level = 1;   //Medium
 * level = 2;   //Hard
 */
function Difficulty(level = null)
{
    if(level == null) return World.GetDifficultyLevel();
    return World.GetDifficultyLevel() == level;
}

function GetDifficultyInfo(difficulty = Difficulty())
{
    var info = {};
    
    switch(difficulty)
    {
        case 0:
            info.Name = 'Easy';
            info.DeathPenaltyXp = 0;
            info.DeathPenaltyOxygen = 0;
            info.DamageMultiplier = .5;
            break;

        case 1:
            info.Name = 'Medium';
            info.DeathPenaltyXp = 20;
            info.DeathPenaltyOxygen = 0;
            info.DamageMultiplier = 1;
            break;

        case 2:
            info.Name = 'Hard';
            info.DeathPenaltyXp = 50;
            info.DeathPenaltyOxygen = 20;
            info.DamageMultiplier = 1.5;
            break;
    }

    info.DamageMultiplierP = info.DamageMultiplier * 100;       //percentage


    return info;
}



function Save()
{
    Settings.Save();
    World.Player.Save();
}




function isObject(variable)
{
	if(variable.constructor === Object)
	{
		return true;
	}
	else
	{
		return false;
	}
}

function isString(variable)
{
	if(variable.constructor === String)
	{
		return true;
	}
	else
	{
		return false;
	}
}

function isArray(variable)
{
	if(variable.constructor === Array)
	{
		return true;
	}
	else
	{
		return false;
	}
}

function isImage(variable)
{
	return variable instanceof HTMLImageElement;
}

function isJSON(variable)
{
	try
	{
		JSON.parse(variable);
	}
	catch(ex)
	{
		return false;
	}
	return true;
}

function isFunction(variable)
{
	return typeof variable === "function";
}

function isInt(variable)
{
	return (Math.floor(variable) == variable);
}


PREVENT_STATE = false;
function preventDefault(new_state)
{
	if(new_state != null)
	{
		PREVENT_STATE = new_state;
	}
	
	return PREVENT_STATE;
}

function getAllMethods(object)
{
    return Object.getOwnPropertyNames(object).filter(function(property) {
        return typeof object[property] == 'function';
    });
}

function isOnScreen(entity)
{
	if(!entity) return false;
	var x = entity.x;
	var y = entity.y;
	var width =  entity.width;
	var height = entity.height;
	var scale = entity.Scale;

    if(entity.Model)
    {
        var s = entity.Model.Scale;
        width = entity.Model.Width * s;
        height = entity.Model.Height * s;
    }

	var sizeX = width * scale;
	var sizeY = height * scale;
	var sX = x - sizeX - Camera.xView;
	var sY = y - sizeY - Camera.yView;
	var eX = sX + (2 * sizeX);
	var eY = sY + (2 * sizeY);

	if((eX >= 0 && sX <= canvas.width) && (eY >= 0 && sY <= canvas.height))
	{
		return true;
	}
	return false;
}

function canSoundPlay(sound, onEnd)
{
	sound.volume = 0;
	var promise = sound.play();

	if(promise !== undefined)
	{
		promise.then(
			() =>
			{
				if(isFunction(onEnd))
				{
					onEnd();
				}
			}
		)
		.catch(
			error =>
			{
				// window.dispatchEvent(new KeyboardEvent('keydown', {'key':'e'}));
				setTimeout(canSoundPlay.bind(canSoundPlay, sound, onEnd), 1000);
			}
		)
	}
}

function ChangeLayer(layer)
{
	Graphic.ChangeLayer(layer);
}

function RestoreLayer()
{
	Graphic.RestoreLayer();
}

function Sleep(miliseconds)
{
	var start = performance.now();

	while(true)
	{
		if(Math.round(performance.now() - start) >= miliseconds) break;

	}
}


function TicksToTime(ticks)
{
	var seconds = Math.floor(ticks / Main.FPS);
	var miliseconds = ticks - (seconds * Main.FPS);
	var minutes = Math.floor(seconds / 60);
		seconds -= minutes * 60;
	var hours = 0;

	if(minutes >= 60)
	{
		hours = Math.floor(minutes / 60);
		minutes -= hours * 60;
	}

	return {h: hours, m: minutes, s: seconds, ms: miliseconds};
}


function getLocationsFamilyOrder()
{
    var families = 
    [
        'Village',
        'Tutorial',
        'Lake',
        'River',
        'Swamp',
        'Cove',
        'Cavern'
    ];
    return families;
}

function getLocationOrder(onlyId = false, ignore = {})
{
    var families = getLocationsFamilyOrder();
	var list = World.LocationList;
    var familiesOrder = [];
	var order = [];
    var id;

	for(var name in list)
	{
        id = families.indexOf(list[name].LocationFamily);
        if(id == -1) continue;
        if(ignore.VILLAGE && list[name].isVillage) continue;

        if(!familiesOrder[id]) familiesOrder[id] = [];
        if(!onlyId) familiesOrder[id].push(list[name]);
        else familiesOrder[id].push(name);
	}

    id = 0;

    for(var i = 0; i < familiesOrder.length; i++)
    {
        if(!familiesOrder[i]) continue;
        for(var j = 0; j < familiesOrder[i].length; j++)
        {
            order[id] = familiesOrder[i][j];
            id++;
        }
    }

	return order;
}

function getLocationLevel(location)
{
    var id = location;
    if(!isString(location)) id = location.name ?? location.constructor.name;

    var order = getLocationOrder(true, {VILLAGE: true});
    var level = order.indexOf(id);

    return level + 1;
}


function isNPCMet(id)
{
    id = id.toUpperCase();
    var data = World.Player.NPCData;
    if(!data[id]) return false;
    if(!data[id].met) return false;

    return true;
}


function getObj(obj)
{
    if(isString(obj))
         if(obj[0] == '#') return document.querySelector(obj);
         else return null;
    return obj;
}

function getCssVariable(obj, variable, toInt = false)
{
    obj = getObj(obj);
    if(!obj) return undefined;

    var s_prop = obj.style.getPropertyValue(variable);
    if(s_prop) 
    {
        if(toInt) return parseFloat(s_prop.replace('px', '').replace('%', ''));
        return s_prop; 
    }

    var css_prop = getComputedStyle(obj).getPropertyValue(variable);
    if(toInt) return parseFloat(css_prop.replace('px', '').replace('%', ''));
    return css_prop; 
}

function get(obj, path, separator='.')
{
    obj = getObj(obj);
    if(!obj) return null;

    var properties = Array.isArray(path) ? path : path.split(separator);
    return properties.reduce((prev, curr) => prev && prev[curr], obj);
}

function set(obj, path, value, onlyIfDifferent = false) 
{
    obj = getObj(obj);
    if(!obj) return false;

    var pList = path.split('.');
    var len = pList.length;
    for(var i = 0; i < len-1; i++) 
    {
        var elem = pList[i];
        if( !obj[elem] ) obj[elem] = {}
        obj = obj[elem];
    }

    if(onlyIfDifferent)
    {
        if(obj[pList[len-1]] != value) 
        {
            obj[pList[len-1]] = value;
            return true;
        }
        return false;
    }

    obj[pList[len-1]] = value;
    return true;
}


function toBool(value)
{
    if(!value) return false;
    if(value?.toLowerCase() == 'true') return true;
    return false;
}

function filter(search, filters, strict = true)
{
    if(!filters && !strict) return true;
    if(!filters) return false;
    if(strict) return filters.includes(search);

    return false;
}
	const RUNNING =
	{
		MENU: "RUNNING_MENU",
		LOADING: "RUNNING_LOADING",
		INGAME: "RUNNING_INGAME",
		SPECIAL_EFFECTS: "RUNNING_SPECIAL_EFFECTS"
	};
	
	const STATE =
	{
		HOVER: "STATE_HOVER",
		DISABLED: "STATE_DISABLED"
	};

	const SKIN = {};
	
	const GRADE =
	{
		NORMAL: "GRADE_NORMAL",
		COMMON: "GRADE_COMMON",
		RARE: 'GRADE_RARE',
		MYTHICAL: 'GRADE_MYTHICAL',
		LEGENDARY: "GRADE_LEGENDARY",
		ANGELIC: "GRADE_ANGELIC",
		DEMONIC: "GRADE_DEMONIC",
		DIVINE: "GRADE_DIVINE",		
		TRANSCENDENTAL: 'GRADE_TRANSCENDENTAL'
	};

	const HITBOX =
	{
		ROUND: "HITBOX_ROUND",
		RECTANGLE: "HITBOX_RECTANGLE"
	};

	const SIDE =
	{
		LEFT: "SIDE_LEFT",
		RIGHT: "SIDE_RIGHT",
		TOP: "SIDE_TOP",
		BOTTOM: "SIDE_BOTTOM"
	};

	const SLOT =
	{
		CANNON: "EQUIPMENT_SLOT_CANNON",
		CORE: "EQUIPMENT_SLOT_CORE",
		DRIVE: "EQUIPMENT_SLOT_DRIVE",
		COVER: 'EQUIPMENT_SLOT_COVER',
		SPECIAL: "EQUIPMENT_SLOT_SPECIAL"
	};

	const STAT =
	{
		ATTACK_DAMAGE: "AD",

		DAMAGE_ELECTRO: "DAMAGE_ELECTRO",
		DAMAGE_FIRE: "DAMAGE_FIRE",
		DAMAGE_POISON: "DAMAGE_POISON",
		DAMAGE_ICE: "DAMAGE_ICE",
		ELEMENTAL_MASTERY: "ELEMENTAL_MASTERY",

		SUMMON_DAMAGE: "SD",
		MAGIC_DAMAGE: "AP",
		DEFENSE: "DEFENSE",
		MAX_HP: "MAXHP",
		DEXTERITY: "DEXTERITY",
		MOVEMENT_SPEED: "SPD",
		ACCELERATION: "ACCELERATION",
		BRAKE: "BRAKE",
		ATTACK_SPEED: "ATTACK_SPD",
		BLOCK_CHANCE: "BLOCK",
		LIFE_REGENERATION: "LIFE_REGEN",
		MANA_REGENERATION: "MANA_REGEN",
		HP: "HP",
		LEVEL: "LEVEL",
		ATTACK_SPEED: "ATTACK_SPEED",
		BULLET_SPEED: "BULLET_SPEED",
		BULLET_SERIES: "BULLET_SERIES",
		BULLET_SERY_DELAY: 'BULLET_SERY_DELAY',
		ATTACK_RANGE: "ATTACK_RANGE",
		FOLLOW_RANGE: "FOLLOW_RANGE",
		BULLETS_COUNT: "BULLETS_COUNT",

		CHARGE: "CHARGE",
		DAMAGE_REDUCTION: "DAMAGE_REDUCTION",

		COOLTIME: 'COOLTIME',
		DURATION: 'DURATION',

		CR: 'CR',
		CD: 'CD',

		LIGHT_RANGE: 'LIGHT_RANGE',
		LIGHT_STRENGTH: 'LIGHT_STRENGTH',

		PIERCE: 'PIERCE',

		HARDNESS: 'HARDNESS',
		POWER: 'POWER',
		AMMO_COST: 'AMMO_COST',

		DASH_DURATION: 'DASH_DURATION',
		DASH_COOLTIME: 'DASH_COOLTIME',
		DASH_DISTANCE: 'DASH_DISTANCE'
	};

	const ELEMENT =
	{	
		PHYSICAL: 'PHYSICAL',
		THUNDER: 'THUNDER',
		POISON: 'POISON',
		ICE: 'ICE'
	};
	
	const TYPE =
	{
		ITEM: "TYPE_ITEM",
		CANNON: "TYPE_CANNON",
		DRIVE: "TYPE_DRIVE",
		SPECIAL: "TYPE_SPECIAL",
		ENCHANT: "TYPE_ENCHANT",
		UPGRADE: "TYPE_UPGRADE",
		CORE: "TYPE_CORE",
		BLESSING: "TYPE_BLESSING",
		F_KEY_MOVEMENT: "TYPE_F_KEY_MOVEMENT",
		SPACE_KEY: 'TYPE_SPACE_KEY',
		Q_KEY: 'TYPE_Q_KEY',
		APPEARANCE_BOX: 'TYPE_APPEARANCE_BOX',
		RIFFLE: 'TYPE_RIFFLE',
		QUEST_ITEM: 'QUEST_ITEM',
		ITEM_DASH: 'TYPE_ITEM_DASH'
	};

	const LOOP =
	{
		BREAK: "END_ANIMATION",
		RETURN: "BACK_ANIMATION_FRAMES",
		CONTINUE: "CONTINUE_ANIMATION"
	};

	const SECURITY_PROBLEM = 
	{
		SP: "Too many SP used!"
	};class Lang
{
    static Initialize(language)
    {
        this.lang = LANGS[language] || LANGS["EN"];
    }

    static Translate(key, split = false)
    {
        if(this.lang[key])
        {
            if(split)
            {
                return this.lang[key].split("\n");
            }
            
            return this.lang[key];
        }

        if(split)
        {
            return ["undefined"];
        }

        return "undefined";
    }

    static GetCurrentLanguage()
    {
        return this.lang;
    }

    static SetGlobalParams(params)
    {
        // params['PLAYER_NAME'] = Champions.List.player.getDisplayName();

        return params;
    }

    static Get(key, params)
    {
        if(!params) params = {};
        params = Lang.SetGlobalParams(params);

        var language = Lang.GetCurrentLanguage();
        if(language[key]) return Helper.ApplyArguments(language[key], params);
        return Helper.ApplyArguments(key, params);
    }
}

var LANGS = {};class MathHelper
{
	/**
	 * Return End point of specific angle and length.
	 * @param {Array} pos Start position [x, y].
	 * @param {*} length Distance from start position.
	 * @param {*} angle Angle of rotation.
	 */
    static lineToAngle(pos, length, angle)
    {
		var x1, y1;
		
        angle *= Math.PI / 180;
		
		if(isArray(pos))
		{
			x1 = pos[0];
			y1 = pos[1];
		}
		else
		{
			x1 = pos.x;
			y1 = pos.y;
		}

        var x2 = x1 + length * Math.cos(angle),
            y2 = y1 + length * Math.sin(angle);

        return {x: x2, y: y2};
	}
	
	static ToRadians(angle)
	{
		return angle * Math.PI / 180;
	}

	static ToAngle(radians)
	{
		return radians * 180 / Math.PI;
	}

	static GetDelta(a, b, c)
	{
		var delta = (b**2) - 4 * a * c;

		return delta;
	}

	static GetCirclePoints(x, y, circleCenter, r)
	{
		//(x-a)2 + (y-b)2 = r2

		circleCenter = this.PosToCoords(circleCenter);
		if(y)
		{
			var a = 1;
			var b = -2 * circleCenter.x;
			var c = (circleCenter.x**2) + Math.pow(y - circleCenter.y, 2) - (r**2);

			var delta = this.GetDelta(a, b, c);
			var delta_sqrt = Math.sqrt(delta);

			var x1 = (-b - delta_sqrt) / (2*a);
			var x2 = (-b + delta_sqrt) / (2*a);

			return [{x: x1, y}, {x: x2, y}];
		}
	}

	// static GetIntersectionWithCircle2(circle1Pos, r, circle2Pos, r2)
	// {
	// 	circle1Pos = this.PosToCoords(circle1Pos);
	// 	circle2Pos = this.PosToCoords(circle2Pos);

	// 	var x1 = circle1Pos.x;
	// 	var y1 = circle1Pos.y;

	// 	var x2 = circle2Pos.x;
	// 	var y2 = circle2Pos.y;

	// 	var dl = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
	// 	var cosA = (dl * dl + r * r - r2 * r2) / (2 * dl * r);
	// 	var sinA = Math.sqrt(1 - Math.pow(cosA, 2));
	// 	var vpx = (x2 - x1) * r / dl;
	// 	var vpy = (y2 - y1) * r / dl;
	// 	var V1x = vpx * cosA - vpy * sinA + x1;
	// 	var V1y = vpx * sinA + vpy * cosA + y1;

	// 	console.log(V1x, V1y);
	// }

	static GetIntersectionWithCircle(startPoint, angle, circleCenter, r, precision = 100)
	{
		r = Math.round(r * precision) / precision;
		
		startPoint = this.PosToCoords(startPoint);
		circleCenter = this.PosToCoords(circleCenter);

		var current_r = 0;
		var dir = 1;
		var i = 0;
		var lastPose, new_pos, dist_from_center;
		while(true)
		{
			i++;
			lastPose = new_pos;

			current_r += dir * (r / (2**i));
			new_pos = MathHelper.lineToAngle(startPoint, current_r, angle);
			dist_from_center = Math.round(MathHelper.GetDistance(new_pos, circleCenter) * precision) / precision;

			if(dist_from_center > r) dir = -1;
			else dir = 1;

			if(dist_from_center == r) return lastPose;
		}
	}


    static getAngle2(pos1, pos2)
    {
		var pos1 = this.PosToArray(pos1);
		var pos2 = this.PosToArray(pos2);

        var dx = pos2[0] - pos1[0];
        var dy = pos2[1] - pos1[1];
        
        return Math.atan2(dy, dx) * 180 / Math.PI;
    }

	static PosToArray(position)
	{
		if(isArray(position)) return position;
		return [position.x, position.y];
	}

	static PosToCoords(position)
	{
		if(isArray(position)) return {x: position[0], y: position[1]};
		return position;
	}

    static GetDistance(Point1, Point2)
    {
        var result;

		var p1 = this.PosToArray(Point1);
		var p2 = this.PosToArray(Point2);

        var x = p2[0] - p1[0];
        var y = p2[1] - p1[1];

        result = Math.pow( (x*x) + (y*y) , 0.5);

        return result;
    }
	
	static tg(a, b) 
	{
		var kat = a / b;
		
		return kat;
	}
	
	static getRandomPoint()
	{
		var end = {};
		
		end.x = MathHelper.randomInRange(0, World.Width);
		end.y = MathHelper.randomInRange(0, World.Height);
		
		return end;
	}

	static GetRandomSide(Sides)
	{
		var sidesCount = 4;
		var side = null;

		if(!(Sides.top || Sides.bottom || Sides.left || Sides.right))
		{
			return null;
		}

		while(true)
		{
			var side = MathHelper.randomInRange(0, sidesCount - 1);

			switch(side)
			{
				case 0:
					if(Sides.top) return "top";
				
				case 1:
					if(Sides.left) return "left";
				
				case 2:
					if(Sides.bottom) return "bottom";
				
				case 3:
					if(Sides.right) return "right";
			}
		}
	}
	
	static GetRoomByIndex(rooms, index)
	{
		var height = rooms.length;
		var width = rooms[0].length;

		var pos = {x: 0, y: 0};
		pos.x = index % width;
		pos.y = Math.floor(index / height);
		pos.room = rooms[pos.y][pos.x];

		return pos;
	}

	static RotatePoint(originPoint, angle, point)
	{
		originPoint = this.PosToCoords(originPoint);
		point = this.PosToCoords(point);
		angle = angle * Math.PI/180;

	  	var s = Math.sin(angle);
	  	var c = Math.cos(angle);
		
		// translate point back to origin:
		point.x -= originPoint.x;
		point.y -= originPoint.y;
		
		// rotate point
		var newX = point.x * c - point.y * s;
		var newY = point.x * s + point.y * c;
		
		// translate point back:
		point.x = newX + originPoint.x;
		point.y = newY + originPoint.y;
		return point;
	}


	static getRandomPointInRange(pos, range, rangeMin = 0)
	{
		pos = this.PosToCoords(pos);

		var angle = this.randomInRange(0, 360);
		var r = this.randomInRange(rangeMin, range);

		var new_pos = this.lineToAngle(pos, r, angle);
		return new_pos;
	}
	
	static randomInRange(min, max)
	{
		return Math.floor(Math.random() * (max - min + 1)) + min;
	}

	static GetMovementSpeed(moveX, moveY)
	{
		return Math.sqrt((moveX * moveX) + (moveY * moveY));
	}

	/**
	 * 
	 * @param {Number} chance % chance of random event.
	 */
	static GetChance(chance)
	{
		var precision = 100;
		var rand = this.randomInRange(0, 100 * precision);

		return (chance * precision) > rand;
	}

	static isInRange(_pos1, _pos2, range)
	{
		var pos1 = _pos1;
		var pos2 = _pos2;

		if(_pos1.x && _pos1.y)
		{
			pos1 = [_pos1.x, _pos1.y];
		}

		if(_pos2.x && _pos2.y)
		{
			pos2 = [_pos2.x, _pos2.y];
		}

		var distance = MathHelper.GetDistance(pos1, pos2);

		return (distance <= range);
	}

	static ToAllowedAngle(angle)
	{
		return (360 + angle) % 360;
	}


	static GetPointDistanceFromLine(point, lineStart, lineEnd)
	{
		var a = (lineEnd[1] - lineStart[1]) / (lineEnd[0] - lineStart[0]);
		var b = -(a * lineStart[0]) + lineStart[1];

		var A = a;
		var B = -1;
		var C = b;

		return Math.abs(A * point[0] + B * point[1] + C) / Math.sqrt(A* A + B * B);
	}

	static ticksToSeconds(ticks, precision = 10)
	{
		return Math.round(ticks / Main.FPS * precision) / precision;
	}
}class Motion
{
	static Get(pos1, pos2, spd)
	{
		var x, y, endX, endY;

		if(pos1.x && pos1.y)
		{
			x = pos1.x;
			y = pos1.y;
		}
		else
		{
			x = pos1[0];
			y = pos1[1];
		}

		if(pos2.x && pos2.y)
		{
			endX = pos2.x;
			endY = pos2.y;
		}
		else
		{
			endX = pos2[0];
			endY = pos2[1];
		}


		var angle = MathHelper.getAngle2([x, y], [endX, endY]);
		var end = MathHelper.lineToAngle([x, y], spd, angle);
		
		var moveX = end.x - x;
		var moveY = end.y - y;

		if(x == endX) moveX = 0;
		if(y == endY) moveY = 0;

		return {x: moveX, y: moveY, angle: angle};
	}
}class Mouse
{
	static Initialize()
	{
		this.x = 0;
		this.y = 0;
		this.click = false;
		this.rightClick = false;
		this.lockClick = false;
		this.lockRightClick = false;
		this.lockHover = false;
		this.focus = false;
		this.id = null;
		this.Disabled = false;

		this.cursor = "default";
		// this.cursorAlpha = 1;
		// this.cursorScale = 1;
	}

	static CheckHoverState(x, y, width, height)
	{
		var endX = x + width;
		var endY = y + height;
		if( (this.x >= x) && (this.x <= endX) && (this.y >= y) && (this.y < endY) ) return true;
		return false;
	}
	
	static Check(object, applyCamera = false, returnState = false)
	{
		if(this.Disabled) return;
		var width, height;

		// var x = this.x + 7.5;
		var x = this.x;
		var y = this.y;
		var startX = object.x;
		var startY = object.y;

		var state = {hover: false, click: false, rightClick: false};

		if(applyCamera)
		{
			startX -= Camera.xView;
			startY -= Camera.yView;
		}
		
		if(object.style)
		{
			width = object.style.width;
			height = object.style.height;
		}
		else
		{
			width = object.width;
			height = object.height;
		}
		
		if(object.Scale)
		{
			width *= object.Scale;
			height *= object.Scale;
		}
		
		if(this.CheckHoverState(startX, startY, width, height))
		{
			if(!this.lockHover) 
			{
				if(returnState)
				{
					state.hover = true;
				}
				else
				{
					object.hover = true;
				}
			}
			
			if( (this.click) && (!this.lockClick) )
			{
				if(returnState)
				{
					state.click = true;
				}
				else
				{
					object.click = true;
					if(object.focusAble)
					{
						this.focus = object;
					}
				}
			}
			
			if( (this.rightClick) && (!this.lockRightClick) )
			{
				if(returnState)
				{
					state.rightClick = true;
				}
				else
				{
					object.rightClick = true;
				}
			}
		}
		else
		{
			if(!returnState)
			{
				object.hover = false;
				object.click = false;
				object.rightClick = false;
			}
		}


		return state;
	}
}class Security
{
	static ReportProblem(problemName)
	{
		var FreezeGame = function()
		{
			if(USE_SECURITY)
			{
				clearInterval(Main.LOOP);

				setTimeout(function()
				{
					ctx.save();
					ctx.fillStyle = 'white';
					ctx.globalAlpha = 0.7;
					ctx.fillRect(0, 0, canvas.width, canvas.height);
					ctx.restore();
				}, 100);

			}
		};


		
		switch(problemName)
		{
			case SECURITY_PROBLEM.SP:
				World.Player.ResetSPpoints();
				World.Player.Save();
				FreezeGame();
				Security.LogError('Game crashed.\n' + SECURITY_PROBLEM.SP);
				break;
		}
	}

	static LogError(message)
	{
		console.log("%c" + message, "color: red");
	}
}class SoundManager
{
	static Initialize()
	{
		this.MusicVolume = Settings.Sound.Music / 100;
		this.EffectsVolume = Settings.Sound.Effects / 100;
		this.Volume = Settings.Sound.General / 100;
		this.MusicShadeTime = 2;
		this.MusicLoopDelay = 2;
		this.MusicLoopTime = 0;
		this.MusicShade = 0;
		this.SwitchMusicTo = null;

		this.isMusicEnding = false;
		this.isMusicStarting = false;
		this.Ready = false;

		this.Playing =
		{
			Background: null,
			Effects: []
		};
	}

	static Update()
	{
		if(!this.Ready) return;

		this.MusicVolume = Settings.Sound.Music / 100;
		this.EffectsVolume = Settings.Sound.Effects / 100;
		this.Volume = Settings.Sound.General / 100;

		var background = this.Playing.Background;
		if(background)
		{
			var volume = (this.Volume * this.MusicVolume);
			var volumeMultiplier = 1;

			var current = background.currentTime;
			var duration = background.duration;

			
			if(current <= this.MusicShadeTime)
			{
				//rozpoczecie muzyki
				this.isMusicStarting= true;	
			}
			else if(current + this.MusicShadeTime < duration)
			{
				//w trakcie
				if(!this.SwitchMusicTo)
				{
					this.isMusicEnding = false;
					this.isMusicStarting = false;
					this.MusicShade = 0;
					this.MusicLoopTime = 0;
				}
			}
			else if(current <= duration)
			{
				//pod koniec
				this.isMusicEnding = true;
			}

			if(!this.SwitchMusicTo)
			{
				if(current >= duration)
				{
					if(this.MusicLoopTime >= this.MusicLoopDelay * Main.FPS)
					{
						this.Play(background.name, "BACKGROUND");
						this.Playing.Background.currentTime = 0;
						this.MusicShade = 0;
						this.MusicLoopTime = 0;
						this.Playing.Background.volume = 0;
						this.Playing.Background.play();
					}
					this.MusicLoopTime++;
				}

				if(this.isMusicEnding)
				{
					this.MusicShade++;
					volumeMultiplier = 1 - (this.MusicShade / (this.MusicShadeTime * Main.FPS));
				}
				else if(this.isMusicStarting)
				{
					this.MusicShade++;
					volumeMultiplier = this.MusicShade / (this.MusicShadeTime * Main.FPS);
				}
			}

			if(this.SwitchMusicTo)
			{
				this.MusicShade++;
				volumeMultiplier = 1 - (this.MusicShade / (this.MusicShadeTime * Main.FPS));

				if(this.MusicLoopTime >= this.MusicLoopDelay * Main.FPS)
				{
					if(this.SwitchMusicTo == "NULL")
					{
						this.Playing.Background = null;
					}
					else
					{
						this.Playing.Background = this.Sounds[this.SwitchMusicTo];
						this.Play(this.SwitchMusicTo, "BACKGROUND");
						this.Playing.Background.currentTime = 0;
					}
					
					this.MusicShade = 0;
					this.MusicLoopTime = 0;
					this.SwitchMusicTo = null;
				}
				this.MusicLoopTime++;
			}

			volumeMultiplier = (volumeMultiplier > 1) ? 1 : volumeMultiplier;
			volume *= volumeMultiplier;
			volume = (InGame.pause) ? volume / 2 : volume;
			volume = (volume < 0) ? 0 : volume;
			background.volume = volume;
		}

		if(this.Playing.Effects)
		{
			for(var i = 0; i < this.Playing.Effects.length; i++)
			{
				var effect = this.Playing.Effects[i];
				var dist = 1;
				if(effect.distanceSoundMultiplier !== undefined)
				{
					dist = effect.distanceSoundMultiplier;
				}
				effect.volume = (this.Volume * this.EffectsVolume * dist);
			}
		}
	}

	static Load()
	{
		this.Sounds = {};
		
		this.LoadProgress = 0;
		this.Loaded = 0;
		this.readyToPlay = 0;
		this.ToLoad = this.src.length;
		
		for (var num = 0; num < this.ToLoad; num++)
		{
			
			var name = this.src[num][0];
			var path = this.src[num][1];

			var sound = new Audio();
				sound.src = path;
				sound.name = name;
				sound.volume = 0;
				// sound.oncanplay  = function()
				// {
				// 	SoundManager.Loaded++;
				// 	canSoundPlay(this, function(){SoundManager.readyToPlay++;});
				// };
				sound.addEventListener('canplaythrough', function()
				{
					SoundManager.Loaded++;
				}, false);

				sound.onerror = function()
				{
					delete SoundManager.Sounds[this.name];
					SoundManager.Loaded++;
				};
			this.Sounds[name] = sound;
		}
	}

	/**
	 * 
	 * @param {String} name Name of sound.
	 * @param {String} type BACKGROUND || EFFECT
	 * @param {Bool} applyDistance Calc volume based on distance from player
	 * @param {Function} onEnd 
	 */
	static Play(name, type = "BACKGROUND", source, onEnd = null)
	{
		var audio = this.GetAudio(name);

		var onEnded = function()
		{
			var index = SoundManager.Playing.Effects.indexOf(this);
			SoundManager.Playing.Effects = SoundManager.Playing.Effects.slice(index, 1);
			if(isFunction(this.onEnd))
			{
				this.onEnd();
			}
		};

		if(audio)
		{
			if(type == "BACKGROUND")
			{
				this.isMusicEnding = false;
				this.isMusicStarting = false;
				if(this.Playing.Background)
				{
					if(this.Playing.Background.name != name)
					{
						this.SwitchMusicTo = name;
					}
					else
					{
						return;
						// this.Playing.Background.currentTime = 0;
					}
				}
				else
				{
					this.Playing.Background = audio;
					this.Playing.Background.currentTime = 0;
				}
			}
			else if(type == "EFFECT")
			{
				audio = audio.cloneNode();
				if(source)
				{
					if((World.Player) && isFinite(source.x) && isFinite(source.y))
					{
						var multi = 500 / MathHelper.GetDistance([source.x, source.y], [World.Player.x, World.Player.y]);
						multi = (multi > 1) ? 1 : multi;
						multi = (multi < 0) ? 0 : multi;

						audio.distanceSoundMultiplier = multi;
					}
				}
				this.Playing.Effects.push(audio);
			}
			else
			{
				return;
			}

			audio.type = type;
			audio.volume = 0;
			audio.onEnd = onEnd;
			audio.onended = onEnded;
			audio.play();
			
		}
	}

	static GetAudio(name)
	{
		if(this.Sounds[name])
		{
			return this.Sounds[name];
		}
		return null;
	}

	static StopMusic()
	{
		if(this.Playing.Background)
		{
			this.SwitchMusicTo = "NULL";
		}
	}
}class Style
{
	static Load()
	{
		this.styles = StylesTest.Get();
	}
	
	static GetProperties()
	{
		return Object.keys(Style.GetDefault());
	}
	
	static GetDefault()
	{
		var Default = {							//Zbior wszystkich dostepnych atrybutow oraz ich wartosci domyslnej
			color: "white",						//kolor czcionki
			placeHolder: "gray",				//kolor placeholder w input type text
			fontSize: 18,						//wielkosc czcionki
			fontSizeType: "px",					//rodzaj czcionki (px / %)
			textAlign: "center",				//kierunek tekstu (left / center / right)
			textMargin: 0,						//margines tekstu od krawedzi po bokach
			verticalAlign: "center",			//margines tekstu od gory (lub center)
			strokeColor: "black",				//kolor obramowania tekstu
			strokeSize: 2,						//wielkosc obramowania
			fontStyle: "Helvetica",			//rodzaj czcionki
			fontWeight: "bold",					// ozdoba tekstu (bold / italic)
			width: 10,							//szerokosc
			height: 10,							//wysokosc
			backgroundColor: "lightgray",		//kolor tla
			borderSize: 0,						//wielksoc obramowania
			borderColor: "rgba(0, 0, 0, 0)",	//kolor obramowania
			cursor: "default",							//kursor
			progressBar: "black",				//kolor wypelnienia progressbar
			progressDisplay: "%",				//sposob wyswietlenia postepu (n / n lub n%)
			backgroundImage: false,				//obrazek tla
			borderImage: false,					//obrazek obramowania
			progressImage: false,				//obrazek paska postepu
			Animation: null,
			borderRadius: 0,					//promien obramowania
			sliderPointer: null					//wskaznik na sliderze
		};
		
		return Default;
	}
	
	static GetStyleByName(name, state = false)
	{
		var Style = this.GetDefault();
		var styleSheet = this.styles[name] || false;
		
		if(styleSheet)
		{	
			Style = this.compareStyles(Style, styleSheet);
			
			if(styleSheet.States)
			{
				switch(state)
				{
					case STATE.HOVER:
						if(styleSheet.States.Hover)
						{
							Style = this.compareStyles(Style, styleSheet.States.Hover);
						}
						break;
					case STATE.DISABLED:
						if(styleSheet.States.Disabled)
						{
							Style = this.compareStyles(Style, styleSheet.States.Disabled);
						}
						break;
				}
				
			}
		}
		
		return Style;
	}
	
	static compareStyles(base, toCompare)
	{
		var Properties = this.GetProperties();
		
		for(var i = 0; i < Properties.length; i++)
		{
			var property = Properties[i];
			
			if(toCompare[property])
			{
				base[property] = toCompare[property];
			}
		}
		
		return base;
	}
	
	/**
	 * Draw specific text.
	 * @param {CanvasRenderingContext2D} ctx 
	 * @param {*} obj 
	 * @param {String} inner Text to be drawn.
	 * @param {Number} x1 x-coordinate.
	 * @param {Number} y1 y-coordinate.
	 * @param {Color} color1 Color of text.
	 * @param {Color} strokeColor1 Color of stroke.
	 * @param {Number} alpha Alpha channel.
	 */
	static FillText(ctx, obj, text, x1, y1, color1, strokeColor1, alpha = 1)
	{

		var style = obj.style;

		if(style)
		{
			var height = style.height || obj.height;
			var width = style.width || obj.width;
		}
		else
		{
			style = this.GetDefault();
			var height = obj.height;
			var width = obj.width;
		}
		
		var posX = x1 || obj.x;
		var posY = y1 || obj.y;
		
		var color = color1 || style.color;
		var strokeColor = strokeColor1 || style.strokeColor;
		
		if(style.fontSizeType == "%")
		{
			style.font = (canvas.height * style.fontSize) / 100;
		}
		else
		{
			style.font = style.fontSize;
		}
		
		
		
		
		if(!text) text = obj.text;

			
		if(style.verticalAlign == "center")
		{
			var y = posY + (height / 2) + (style.font / 4);
		}
		else
		{
			var y = posY + style.verticalAlign + style.font;
		}
			
			
		if(style.textAlign == "center")
		{
			var x = posX + (width / 2);
		}
			
		if(style.textAlign == "left")
		{
			var x = posX + style.textMargin;
		}
			
		if(style.textAlign == "right")
		{
			var x = posX + width - style.textMargin;
		}
		
		ctx.save();
		ctx.globalAlpha = alpha;
		ctx.font = style.fontWeight + " " + style.font + "px " + style.fontStyle;
		ctx.fillStyle = color;
		ctx.textAlign = style.textAlign;
		
		if(style.strokeSize)
		{
			ctx.strokeStyle = strokeColor;
			ctx.lineWidth = style.strokeSize;
			ctx.strokeText(text, x, y);
		}
		
		ctx.fillText(text, x, y);
		ctx.restore();
		
		
	}

	static GetTextSize(text, style)
	{
		if(style.fontSizeType == "%")
		{
			var font = (canvas.height * style.fontSize) / 100;
		}
		else
		{
			var font = style.fontSize;
		}

		
        ctx.save();
        ctx.font = style.fontWeight + " " + font + "px " + style.fontStyle;
		var width = ctx.measureText(text).width;
		var height = ctx.measureText("M").width;
		ctx.restore();

        return {width: width, height: height};
	}

	static GetCustomTextColor(text)
	{
		var color = null;
		if(text[0] == "<")    //specjalny kolor musi sie zaczynac od <
		{
			var end = text.indexOf(">");
			color = text.slice(1, end);
		}

		if(color)
		{
			text = text.replace('<'+color+'>', '');
			//used CSS variable
			if(color.startsWith('--'))
			{
				color = getCssVariable(document.body, color).trim();
			}
		}

		return {color, text};
	}

	static ColorizeTextParts(text)
	{
		var color = null;
		var lastIndex = -1;
		var s = '<';
		var e = '>';
		var start,end, textEnd, span, textPart, CSSColor, replacePart;
		var newText = '';

		while(true)
		{
			replacePart = null;
			start = text.indexOf(s);
			if(start == -1 && lastIndex == -1) return text;	//there is no part to colorize
			if(start == -1) break;
			if(lastIndex == start) break;	//there is no color left

			end = text.indexOf(';');
			textEnd = text.indexOf(e);

			if(start != 0) 
			{
				replacePart = text.slice(0, start);
				newText += replacePart;
			}

			color = text.slice(start+1, end);
			CSSColor = color;
			if(color.startsWith('--')) CSSColor = getCssVariable(document.body, color).trim();

			textPart = text.slice(end+1, textEnd);
			span = '<span style="color: '+CSSColor+';">'+textPart+'</span>';

			if(color.startsWith('data-')) span = '<span class="line" '+color+'>'+textPart+'</span>';


			if(replacePart) text = text.replace(replacePart, '');
			text = text.replace(s+color+';'+textPart+e, '');
			newText += span;

			lastIndex = start;
		}

		if(text != '') newText += text;
		
		return newText;
	}

	static InjectColor(text, color = null, autoTranslate = true)
	{
		var type = color;
		if(type == 'DATA') color = null;

		if(!color)
		{
			//auto use grade colors
			if(Object.values(GRADE).indexOf(text) != -1) 
			{
				if(type == 'DATA') color = 'data-grade="'+text+'"';
				else color = '--color-grade-'+text.replace('GRADE_', '').toLowerCase();
				if(autoTranslate) text = Lang.Get(text);
			}
		}

		if(!color) return text;

		return '<'+color+';'+text+'>';
	}

	static DottedText(text)
	{	
		if(text == null) return;
		text = text.toString();
		
		var length = text.length;
		var textParts = [];
		var number = 0;
		var tempText = "";
		var newText = "";
		
		for(var num = length - 1; num >= 0; num--)
		{
			if(number == 3)
			{
				textParts.push(tempText);
				tempText = "";
				number = 1;
			}
			else
			 {
				number++;
			}
			
			tempText += text[num];
		}
		
		if(tempText != "") 
		{
			textParts.push(tempText);
			tempText = "";
		}
		
		
		for(var num = textParts.length - 1; num >= 0; num--) 
		{
			for(var num2 = textParts[num].length - 1; num2 >= 0; num2--)
			{
				newText += textParts[num][num2];
			}
			if(num != 0)		//nie dodaje kropki po ostatniej cyfrze
			{		
				newText += ".";
			}
			
			
		}
		
		return newText;
	}
	
	static getCenterPosition(className)
	{
		var style = Style.GetStyleByName(className);
		var x = canvas.width / 2 - style.width / 2;
		var y = canvas.height / 2 - style.height / 2;
		
		return {x: x, y: y};
	}
}

class TextureManager
{
	static Load()
	{
		this.Textures = {};
		
		this.LoadProgress = 0;
		this.Loaded = 0;
		this.ToLoad = this.src.length;
		
		for (var num = 0; num < this.ToLoad; num++)
		{
			
			var name = this.src[num][0];
			var path = this.src[num][1];

			var texture = new Image();
				texture.src = path;
				texture.name = name;
				texture.onload = function()
				{
					TextureManager.Loaded++;
				};
				texture.onerror = function()
				{
					TextureManager.Loaded++;
					delete TextureManager.Textures[this.name];
				};
			this.Textures[name] = texture;
		}
	}
	
	static Get(name = "none")
	{
		if(this.Textures)
		{
			if(this.Textures[name] != undefined)
			{
				return this.Textures[name];
			}
			else
			{
				return this.Textures.none;
			}
		}
	}
}class Button
{
	constructor(posX = 0, posY = 0, className = '', text = '', disabled = false, id = 'id', onUpdate = null, onHover = null, onClick = null, onRightClick = null, onShade = null)
	{
		this.style = {};
		this.className = className;
		this.id = id;
		this.text = text;
		this.onHover = onHover;
		this.onClick = onClick;
		this.onRightClick = onRightClick;
		this.onUpdate = onUpdate;
		this.onShade = onShade;
		
		this.hover = false;
		this.gotHover = false;
		this.click = false;
		this.rightClick = false;
		this.disabled = disabled;
		this.ageInTicks = 0;
		
		this.style = Style.GetStyleByName(this.className);
		this.width = this.style.width;
		this.height = this.style.height;
		
		this.x = posX;
		this.y = posY;
		this.opacity = 1;

		this.clickSound = 'effect.ButtonClick';
		this.clickTime = 0;
		this.focusAble = true;
		this.lockPlayerAttack = true;
	}
	
	Update()
	{
		Mouse.Check(this);
		this.ageInTicks++;
		this.style = Style.GetStyleByName(this.className);
		
		
		if(!this.disabled)
		{
			if(this.hover)
			{
				if(Mouse.click) this.clickTime++;
				else this.clickTime = 0;

				this.Hover();
			}
			else if(this.gotHover) this.MouseOut();
		
			if (this.click)
			{
				this.Click();
				Mouse.lockClick = true;
				this.click = false;
			}
			
			if (this.rightClick)
			{
				this.RightClick();
				Mouse.lockRightClick = true;
				// Mouse.rightClick = true;
				this.rightClick = false;
			}

			if (this.shade)
			{
				this.Shade();
				this.shade = false;
			}
		
		}
		else
		{
			this.style = Style.GetStyleByName(this.className, STATE.DISABLED);
			this.rightClick = false;
			this.click = false;
		}
		
		if(isFunction(this.onUpdate))
		{
			this.onUpdate();
		}
	}
				
	Render()
	{			
		var width = this.style.width;
		var height = this.style.height;

		if(!this.style.backgroundImage)
		{
			var bSize = this.style.borderSize;
			ctx.save();
			ctx.globalAlpha = this.opacity;
			ctx.fillStyle = this.style.backgroundColor;
			
			if(this.style.borderRadius)
			{
				Graphic.roundRect(ctx, this.x - (bSize / 2), this.y - (bSize / 2), width + bSize, height + bSize, this.style.borderRadius, true, false);
			}
			else
			{
				ctx.fillRect(this.x - (bSize / 2), this.y - (bSize / 2), width + bSize, height + bSize);
			}
			
			ctx.restore();
		}
		else
		{
			ctx.save();
			ctx.globalAlpha = this.opacity;
			ctx.drawImage(TextureManager.Get(this.style.backgroundImage), this.x + this.style.borderSize, this.y + this.style.borderSize, width - (this.style.borderSize * 2), height - (this.style.borderSize * 2));	
			ctx.restore();
		}


		if(!this.style.borderImage)
		{
			var bSize = this.style.borderSize;
			ctx.save();
			ctx.globalAlpha = this.opacity;
			ctx.strokeStyle = this.style.borderColor;
			ctx.lineWidth = bSize;
			
			if(this.style.borderRadius)
			{
				Graphic.roundRect(ctx, this.x - (bSize / 2), this.y - (bSize / 2), width + bSize, height + bSize, this.style.borderRadius, false, true);
			}
			else
			{
				ctx.strokeRect(this.x - (bSize / 2), this.y - (bSize / 2), width + bSize, height + bSize);
			}
			
			ctx.restore();
		}
		else
		{
			ctx.save();
			ctx.globalAlpha = this.opacity;
			ctx.drawImage(TextureManager.Get(this.style.borderImage), this.x, this.y, width, height);
			ctx.restore();
		}
		
		Style.FillText(ctx, this, null, null, null, null, null, this.opacity);
	}
	
	Hover()
	{
		this.gotHover = true;
		this.style = Style.GetStyleByName(this.className, STATE.HOVER);
		Mouse.cursor = this.style.cursor ?? Mouse.cursor;
		
		if(isFunction(this.onHover))
		{
			this.onHover();
		}

		if(this.lockPlayerAttack) World.Player.allowAttack = false;
	}

	MouseOut()
	{
		this.gotHover = false;

		if(isFunction(this.onMouseOut))
		{
			this.onMouseOut();
		}
	}
	
	Click()
	{
		this.style = Style.GetStyleByName(this.className, STATE.CLICK);
		
		if(isFunction(this.onClick))
		{
			this.onClick();
		}

		if(this.clickSound)
		{
			SoundManager.Play(this.clickSound, "EFFECT");
		}
	}
	
	RightClick()
	{
		this.style = Style.GetStyleByName(this.className, STATE.RIGHTCLICK);
		
		if(isFunction(this.onRightClick))
		{
			this.onRightClick();
		}
	}
	
	Shade()
	{
		this.style = Style.GetStyleByName(this.className, STATE.SHADE);
		
		if(isFunction(this.onShade))
		{
			this.onShade();
		}
	}
}class ConfirmBox
{
	constructor(name, onTrue = null, onFalse = null, trueName = "Yes", falseName = "No")
	{
		this.Name = name;
		this.onTrue = onTrue;
		this.onFalse = onFalse;

		this.Margin = 10;

		this.Width = 200;
		this.Height = 100;
		this.ButtonHeight = 40;
		this.ButtonWidth = 50;

		var onTrueClick = function()
		{
			var index = Main.confirms.indexOf(this);
			if(index)
			{
				Main.confirms.splice(index, 1);
			}
			if(isFunction(onTrue))
			{
				onTrue();
			}
		}

		var onFalseClick = function()
		{
			var index = Main.confirms.indexOf(this);
			if(index)
			{
				Main.confirms.splice(index, 1);
			}
			if(isFunction(onFalse))
			{
				onFalse();
			}
		}
		
		this.Buttons =
		[
			new Button(0, 0, 'ConfirmBoxButton', trueName, false, "true", null, null, onTrueClick.bind(onTrueClick, onTrue)),
			new Button(0, 0, 'ConfirmBoxButton', falseName, false, "false", null, null, onFalseClick.bind(onFalseClick, onFalse)),
		];

		this.style = Style.GetStyleByName('confirmBox');

		if(isArray(this.Name))
		{
			for(var i = 0; i < this.Name.length; i++)
			{
				var size = Style.GetTextSize(this.Name[i], this.style);
				if(size.width > this.Width) this.Width = size.width;
				if(size.height > this.Height) this.Height = size.height;
			}
		}
		else
		{
			var size = Style.GetTextSize(this.Name, this.style);
			if(size.width > this.Width) this.Width = size.width;
			if(size.height > this.Height) this.Height = size.height;
		}
	}

	Update()
	{
		Mouse.Disabled = false;
		for(var i = 0; i < this.Buttons.length; i++)
		{
			this.Buttons[i].Update();
		}
		Mouse.Disabled = true;
	}

	Render()
	{
		this.x = (canvas.width / 2) - (this.Width / 2);
		this.y = (canvas.height / 2) - (this.Height / 2);

		ctx.save();
		ctx.globalAlpha = 0.6;
		ctx.fillRect(0, 0, canvas.width, canvas.height);
		ctx.restore();

		ctx.save();
		ctx.globalAlpha = 0.3;
		ctx.fillStyle = "white";
		Graphic.roundRect(ctx, this.x - this.Margin, this.y - this.Margin, this.Width + 2 * this.Margin, this.Height + this.ButtonHeight + 2* this.Margin, 20, true);
		ctx.restore();

		var xStep = (this.Width - (2 * this.ButtonWidth)) / 3;
		var x = this.x + xStep;
		var y = this.y + this.Height;

		for(var i = 0; i < this.Buttons.length; i++)
		{
			this.Buttons[i].x = x + (i * (xStep + this.ButtonWidth));
			this.Buttons[i].y = y;
			this.Buttons[i].style.width = this.ButtonWidth;
			this.Buttons[i].style.height = this.ButtonHeight;
			this.Buttons[i].Render();
		}
	}
}class DialogLine
{
	constructor(id, text, options = [], exitTexts = ['DIALOG.EXIT'])
	{
		this.id = id;
		this.Text = text;
		this.Options = options;
		this.isQuest = false;

		if(exitTexts)
		{
			var exit_txt = exitTexts[MathHelper.randomInRange(0, exitTexts.length-1)];
			this.Options.push(new DialogOption(exit_txt));
		}

		Dialog.AddDialogLine(this);

		this.currentText = null;
	}

	Reset()
	{
		this.currentText = null;
	}

	GetText()
	{
		var name = World.Player.interactionWith.getDisplayName();

		if(!isArray(this.Text)) return Lang.Get(this.Text, {NAME: name});
		if(this.currentText == null) this.currentText = MathHelper.randomInRange(0, this.Text.length-1);
		
		return Lang.Get(this.Text[this.currentText], {NAME: name});
	}

	static Exit()
	{
		UI_Helper.removeHistoryElement('talk_with');
	}

	static OpenShop()
	{
		World.Player.interactionWith.Trade();
		var t = World.Player.interactionWith;
		UI_Helper.OpenShop(World.Player.interactionWith);
		DialogLine.Exit();
		World.Player.interactionWith = t;
	}

	static OpenLargeShop()
	{
		World.Player.interactionWith.Trade();
		var t = World.Player.interactionWith;
		UI_Helper.OpenLargeShop(World.Player.interactionWith);
		DialogLine.Exit();
		World.Player.interactionWith = t;
	}
	

	static OpenCrafting()
	{
		var t = World.Player.interactionWith;
		UI_Helper.OpenCrafting();
		DialogLine.Exit();
		World.Player.interactionWith = t;
	}

	static OpenAppearance()
	{
		var t = World.Player.interactionWith;
		UI_Helper.OpenAppearanceGUI();
		DialogLine.Exit();
		World.Player.interactionWith = t;
	}

	static OpenKnowledge()
	{
		var t = World.Player.interactionWith;
		UI_Helper.OpenKnowledgeGUI();
		DialogLine.Exit();
		World.Player.interactionWith = t;
	}

	static ChangeDialogLine(id)
	{
		if(Dialog.DialogLines[id]) DialogGUI.ChangeLine(Dialog.DialogLines[id]);
	}

	GetOptions()
	{
		var options = [];
		for(var i = 0; i < this.Options.length; i++)
		{
			if(this.Options[i].showTrigger)
			{
				if(!this.Options[i].showTrigger()) continue;
			}

			options.push(this.Options[i]);
		}
		return options;
	}
}

class DialogOption
{
	constructor(text, onClick = DialogLine.Exit, icon = null, showTrigger = null)
	{
		this.Text = text;
		this.onClick = onClick;
		this.icon = icon;
		this.showTrigger = showTrigger;

		this.currentText = null;
	}

	GetText()
	{
		if(!isArray(this.Text)) return Lang.Get(this.Text);
		if(!this.currentText) this.currentText = MathHelper.randomInRange(0, this.Text.length-1);
		
		return Lang.Get(this.Text[this.currentText]);
	}
}class Interface
{
	constructor(){}
	
	static Initialize()
	{
		this.Buttons = [];
		this.Bars = [];
		this.UI_ID = null;
	}
	
	static Update()
	{
		for(var i = 0; i < this.Buttons.length; i++)
		{
			this.Buttons[i].Update();
		}
		
		for(var i = 0; i < this.Bars.length; i++)
		{
			this.Bars[i].Update();
		}
	}
	
	static Render()
	{
		this.transitionAlpha = 0;

		if(this.transition)
		{
			this.transitionDuration++;
			this.transitionAlpha = this.transitionDuration / this.transitionTime;
			
			if(this.transitionDuration >= this.transitionTime)
			{
				if(isFunction(this.onTransitionEnd))
				{
					this.onTransitionEnd();
				}
			}
		}

		if(!this.transition || (this.transition && this.showTransitionUI) )
		{
			for(var i = 0; i < this.Buttons.length; i++)
			{
				this.Buttons[i].Render();
			}
			
			for(var i = 0; i < this.Bars.length; i++)
			{
				this.Bars[i].Render();
			}
		}
		ctx.save();
		ctx.globalAlpha = this.transitionAlpha;
		ctx.fillRect(0, 0, canvas.width, canvas.height);
		ctx.restore();
	}
	
	static Run(preventInit)
	{
		if(!preventInit)
		{
			this.Initialize();
		}
		this.transition = false;
		Main.RUNNING = this.RUNNING;

		Graphic.hideShaders();
		
		if(this.UI_ID) 
		{
			UI_Helper.addHistory = false;
			UI_Helper.Open(this.UI_ID);
		}
	}

	static Transition(onEnd, time = 2, showTransitionUI = false)
	{
		SoundManager.StopMusic();
		this.showTransitionUI = showTransitionUI;
		this.transitionDuration = 0;
		this.transitionTime = time * Main.FPS;
		this.transition = true;
		this.onTransitionEnd = onEnd;
	}
}class InterfaceControl
{
	static InitializeInterface(_interface)
	{
		this.Packages = this.Packages || [];
		this.Packages.push(_interface);
	}

	static Initialize()
	{
		for(var i = 0; i < this.Packages.length; i++)
		{
			this.Packages[i].Initialize();
		}
	}
	
	static Update()
	{
		var running = Main.RUNNING;
		
		for(var i = 0; i < this.Packages.length; i++)
		{
			if(running == this.Packages[i].RUNNING)
			{
				this.Packages[i].Update();
				break;
			}
		}
	}
	
	static Render()
	{
		var running = Main.RUNNING;
		
		for(var i = 0; i < this.Packages.length; i++)
		{
			if(running == this.Packages[i].RUNNING)
			{
				this.Packages[i].Render();
				break;
			}
		}
	}

	static getCurrent()
	{
		var running = Main.RUNNING;
		
		for(var i = 0; i < this.Packages.length; i++)
		{
			if(running == this.Packages[i].RUNNING)
			{
				return this.Packages[i];
			}
		}
	}
}class InventorySlot extends Button
{
	constructor(posX, posY, disabled, id, owner, onUpdate)
	{
		super();
		
		this.text = "";
		this.Owner = owner;
		this.x = posX;
		this.y = posY;
		this.style = {};
		this.id = id;
		this.className = "inventory_slot";
		this.hover = false;
		this.click = false;
		this.rightClick = false;
		this.disabled = disabled || false;
		this.ageInTicks = 0;
		
		this.style = Style.GetStyleByName(this.className);
		this.Width = this.style.width;
		this.Height = this.style.height;
		this.onUpdate = onUpdate;

		this.lastItem = null;
		this.valueChanged = false;
		this.item = null;

		this.valueChangedAlpha = new Transition(0.6, 1, 0.5, true, 0, 0);
		this.ArmorSlot = null;

		this.highLightFrame = 0;
		this.highLightDelay = 3;
	}

	GetItem()
	{
		if(!this.Owner) return null;
		var id = parseInt(this.id.replace("slot", ""));
		var item = null;

		if(id < 141)
		{
			item = this.Owner.inventory[id];
		}
		else
		{
			this.ArmorSlot = this.getArmorSlot(id);
			item = this.Owner.equips[this.ArmorSlot];
		}

		return item;
	}
	
	Update()
	{
		super.Update();
		if(isFunction(this.onUpdate))
		{
			this.onUpdate();
		}
	}
	
	Render()
	{
		super.Render();
		var item = this.GetItem();
			if(item) item.isEquiped = false;
		var slot = null;
		var showHighlight = false;
		
		var id = parseInt(this.id.replace("slot", ""));
		var handItem = (this.Owner) ? this.Owner.hand : null;
		var displayItem = InGame.GUI.Inventory.HoveredItem;

		if(id >= 141)
		{
			this.ArmorSlot = this.getArmorSlot(id);
			if(!item)
			{
				ctx.drawImage(TextureManager.Get(this.imgEmpty), this.x, this.y, this.Width, this.Height);
			}
			else
			{
				item.isEquiped = true;
			}

			//cannot highlight and show info if equipment slot is hovered
			if(handItem || displayItem)
			{
				if(this.ArmorSlot.includes(SLOT.SPECIAL))
				{
					var number = this.ArmorSlot.replace(SLOT.SPECIAL, '');
					this.ArmorSlot = this.ArmorSlot.replace(number, '');
				}

				if(displayItem !== item && this.ArmorSlot && (handItem?.slot == this.ArmorSlot || displayItem?.slot == this.ArmorSlot))
				{
					showHighlight = true;

					InGame.GUI.Inventory.EquipedItemInfoDisplay.item = item;
					InGame.GUI.Inventory.EquipedItemInfoDisplay.startX = this.x;
					InGame.GUI.Inventory.EquipedItemInfoDisplay.startY = this.y;
				}
			}
		}
		else if(handItem)
		{
			if(handItem.type == TYPE.ENCHANT)
			{
				if(item)
				{
					var index = ItemHelper.CanBeEnchanted(item, handItem);
					if(index != null)
					{
						showHighlight = true;
					}
				}
			}
			else if(handItem.type == TYPE.UPGRADE)
			{
				if(item)
				{
					if(isFunction(item.CanBeUpgraded))
					{
						if(item.CanBeUpgraded(this.Owner))
						{
							showHighlight = true;
						}
					}
				}
			}
		}

		if(item)
		{
			item.onInventoryTick();

			ctx.drawImage(TextureManager.Get(item.Texture), this.x, this.y, this.Width, this.Height);

			if(item.Grade)
			{
				var texture_name = 'item_border_' + item.Grade.replace('GRADE_', '').toLowerCase();
				var border_texture = TextureManager.Get(texture_name);
				if(border_texture.name != 'none')
				{
					ctx.drawImage(border_texture, this.x - 1, this.y - 1, this.Width + 2, this.Height + 2);
				}
			}
			
			if(item.count > 1)
			{
				this.text = item.count;
			}
			else
			{
				this.text = "";
			}
			
			item.DrawShine(this.x + 15, this.y + 15);

			Style.FillText(ctx, this);
			

			if(this.hover)
			{
				InGame.GUI.Inventory.HoveredItem = item;
				InGame.GUI.Inventory.ItemInfoDisplay.item = item;
				item.showNewItemInfo = false;
			}


			if(item.showNewItemInfo && !this.ArmorSlot)
			{
				var alpha = this.valueChangedAlpha.Update();
				Style.FillText(ctx, this, 'New!', this.x + 5, this.y - 30, 'white', 'orange', alpha)
			}

		}
		else
		{
			this.text = "";
		}

		if(showHighlight)
		{
			var texture = TextureManager.Get('inventory_slot_changed');
			var frames = texture.height / texture.width;
			if(this.ageInTicks % this.highLightDelay == 0)
			{
				this.highLightFrame++;
				if(this.highLightFrame >= frames)
				{
					this.highLightFrame = 0;
				}
			}

			var size = 2;
			ctx.drawImage(texture, 0, texture.width * this.highLightFrame, texture.width, texture.width, this.x - size / 2, this.y - size / 2, this.Width + size, this.Height + size);
		}
		
	}

	onMouseOut()
	{
		InGame.GUI.Inventory.HoveredItem = null;
	}
	
	Click()
	{
		super.Click();
		
		this.replaceItem();
	}
	
	RightClick()
	{
		this.style = Style.GetStyleByName(this.className, STATE.RIGHTCLICK);
		
		var id = parseInt(this.id.replace("slot", ""));
		var slot = this.getArmorSlot(id);

		if(InGame.GUI.Inventory.isShopOpen)
		{
			var shop_owner = InGame.GUI.Inventory.shopOwner;
			var item = this.GetItem();
			var id = parseInt(this.id.replace('slot', ''));

			if(!shop_owner) return;
			if(!item) return;
			
			shop_owner.Buy(item, InGame.GUI.Inventory.Owner);
			this.Owner.inventory[id] = null;
			return;	//disable quick equip while trading
		}


		if(this.Owner.inventory[id])
		{
			if(isFunction(this.Owner.inventory[id].onUse))
			{
				this.Owner.inventory[id].onUse(this.Owner);
			}
			else
			{
				if(this.Owner.inventory[id].equipAble)
				{
					this.equip(this.Owner.inventory[id]);
				}
				else if(this.Owner.inventory[id].stackAble)
				{
					if(!this.Owner.hand && this.Owner.inventory[id].count > 1)
					{
						this.Owner.hand = ItemHelper.CopyItem(this.Owner.inventory[id]);
						var count = Math.floor(this.Owner.inventory[id].count / 2);
						this.Owner.hand.count -= count;
						this.Owner.inventory[id].count = count;
					}
					else
					{
						if(this.Owner.hand)
						{
							if(this.Owner.hand.constructor.name === this.Owner.inventory[id].constructor.name)
							{
								if(this.Owner.hand.count > 1)
								{
									this.Owner.hand.count -= 1;
									this.Owner.inventory[id].count += 1;
								}
								else
								{
									this.Owner.hand = null;
									this.Owner.inventory[id].count += 1;
								}
							}
						}
					}
				}

			}
		}
		else if(this.Owner.equips[slot])
		{
			//sciaganie przedmiotu
			var item = this.Owner.equips[slot];
			this.Owner.addItemToInventory(item, item.count);
			this.Owner.equips[slot] = null;
			this.Owner.UpdateStats();
		}
		else if(this.Owner.hand)
		{
			if(this.Owner.hand.stackAble && this.Owner.hand.count > 1)
			{
				this.Owner.inventory[id] = ItemHelper.CopyItem(this.Owner.hand);
				this.Owner.hand.count -= 1;
				this.Owner.inventory[id].count = 1;
			}
			
		}
	}
	
	
	
	
	
	
	replaceItem()
	{
		var slot1 = parseInt(this.id.replace("slot", ""));
		var temp = this.Owner.inventory[slot1];
		
		var item_inv = this.Owner.inventory[slot1];
		var item_hand = this.Owner.hand;
		
		if( slot1 < this.Owner.stats.availableSlots )		//tylko sloty w inventory
		{		
			if( item_hand && this.Owner.inventory[slot1])
			{
				if(item_hand.constructor.name == this.Owner.inventory[slot1].constructor.name)
				{
					//przedmioty sa tego samego typu
					if(item_hand.stackAble)
					{
						//stackowanie przedmiotow
						this.Owner.inventory[slot1].count += item_hand.count;
						if(this.Owner.inventory[slot1].count > this.Owner.inventory[slot1].maxStackSize)
						{
							item_hand.count = this.Owner.inventory[slot1].count - this.Owner.inventory[slot1].maxStackSize;
							this.Owner.inventory[slot1].count = this.Owner.inventory[slot1].maxStackSize;
							return;
						}
						else
						{
							this.Owner.hand = null;
							return;
						}
					}
				}
				else if(item_hand.type == TYPE.UPGRADE && this.Owner.inventory[slot1].upgradeAble && this.Owner.inventory[slot1].upgradeLevel < 9)
				{
					//Ulepszanie przedmiotow

					var text = "Not Enough Oxygen!";
					var type = "UPGRADE_ERROR";

					if(this.Owner.inventory[slot1].CanBeUpgraded(this.Owner))
					{
						var result = this.Owner.inventory[slot1].Upgrade(this.Owner, this.Owner.hand.degradeOnFail);
						
						
						
						if(result)
						{
							text = "Upgrade Successful";
							type = "UPGRADE_SUCCESS";
						}
						else
						{
							text = "Upgrade Failed";
							type = "UPGRADE_FAILED";
						}
						

						this.Owner.hand.count--;
						if(this.Owner.hand.count < 1)
						{
							this.Owner.hand = null;
						}
						else
						{
							this.Owner.addItemToInventory(this.Owner.hand, this.Owner.hand.count);
							this.Owner.hand = null;
						}

						// Main.Confirm("Upgrade item now?", function(){console.log(true)} );
						
					}

					DamageIndicator.AddObject(Mouse.x + Camera.xView, Mouse.y - 25 + Camera.yView, text, type);

					return;
				}
				else if(item_hand.type == TYPE.ENCHANT && this.Owner.inventory[slot1].enchantAble)
				{

					var result = this.Owner.inventory[slot1].Enchant(item_hand);
					if(result)
					{
						this.Owner.hand = null;
						DamageIndicator.AddObject(Mouse.x + Camera.xView, Mouse.y - 25 + Camera.yView, "Enchant Successful!", "UPGRADE_SUCCESS");
						return;
					}
				}
			}



			
			this.Owner.inventory[slot1] = this.Owner.hand;
			this.Owner.hand = temp;

		}
		else
		{
			if(item_hand)		//przedmiot w rece
			{		
				var slot = this.getArmorSlot(slot1);			//numer wybranego slotu
				var slot2 = slot.replace("0", "").replace("1", "").replace("2", "").replace("3", "");
				if(item_hand.slot == slot2)			//przedmiot moze byc zalozony w danym slocie
				{
					this.equip(this.Owner.hand, slot);
				}
			}
			else
			{
				//nacisnieto slot wyposazenia (equips)
				var slot = this.getArmorSlot(slot1);
				temp = this.Owner.equips[slot];

				this.Owner.equips[slot] = this.Owner.hand;
				this.Owner.hand = temp;
				this.Owner.UpdateStats();
			}
		}
	}
	
	
	
	
	equip(item, _slot)
	{				
		var slot = item.slot;
		if(slot == SLOT.SPECIAL)
		{
			if(!this.Owner.equips[slot + "0"])
			{
				slot += "0";
			}
			else if(!this.Owner.equips[slot + "1"])
			{
				slot += "1";
			}
			else if(!this.Owner.equips[slot + "2"])
			{
				slot += "2";
			}
			else if(!this.Owner.equips[slot + "3"])
			{
				slot += "3";
			}
			else
			{
				return;
			}

			if(_slot)
			{
				slot = _slot;
			}
		}
		
		if(this.Owner.hand === item)		//przedmiot jest zakladany z reki
		{		
			if(this.Owner.hand.requiredLevel <= this.Owner.stats.Level)
			{
				var temp = this.Owner.equips[slot];
				this.Owner.equips[slot] = this.Owner.hand;
				this.Owner.hand = temp;
			}
		}
		else
		{
			if(item.requiredLevel <= this.Owner.stats.Level)
			{
				var id = this.Owner.inventory.indexOf(item);

				if(id >= 0)
				{
					var temp = this.Owner.equips[slot];
					this.Owner.equips[slot] = item;
					this.Owner.inventory[id] = temp;
				}
			}
		}
		
		this.Owner.UpdateStats();
	}
	
	getArmorSlot(id)
	{
		var armor_slots = 
		[
			[SLOT.CANNON, 141],			//cannon
			[SLOT.CORE, 142],			//core
			[SLOT.DRIVE, 143],			//drive
			[SLOT.SPECIAL + "0", 144],
			[SLOT.SPECIAL + "1", 145],
			[SLOT.SPECIAL + "2", 146],
			[SLOT.SPECIAL + "3", 147],
		];

		if(id)
		{
			for(var num = 0; num < armor_slots.length; num++)
			{
				if(typeof id === "string")		//podano nazwe slotu
				{	
					if(armor_slots[num][0] == id)
					{
						return armor_slots[num][1];		//zwraca numer slotu
					}
				}
				else
				{					//podano numer slotu
					if(armor_slots[num][1] == id)
					{
						return armor_slots[num][0];		//zwraca nazwe slotu
					}
				}
			}
		}
		else
		{					
			return armor_slots;
		}
	}
	
	
	
}class ProgressBar
{
	constructor(posX, posY, className, value, currValue, onUpdate, onHover, onClick)
	{
		this.x = posX || 0;
		this.y = posY || 0;
		this.style = {};
		this.className = className;
		this.text = "";
		
		this.value = value || 0;				//wartosc maksymalna
		this.currentValue = currValue || 0;	//wartosc aktualna
		this.progress = (this.currentValue / this.value) || 0;
		this.onHover = onHover;
		this.onClick = onClick;
		this.onUpdate = onUpdate;
		this.ageInTicks = 0;
		
		this.hover = false;
		this.click = false;
		
		this.style = Style.GetStyleByName(this.className);
		this.width = this.style.width;
		this.height = this.style.height;
		this.visible = true;
		
		this.ShowText = true;
		this.reverseProgressDisplay = false;
		this.focusAble = true;
		this.disabled = false;
	}
	
	Update()
	{
		Mouse.Check(this);
		this.ageInTicks++;
		this.style = Style.GetStyleByName(this.className);

		if(this.style.Animation)
		{
			this.style.Animation.Update();
		}

		if(!this.disabled)
		{
			if(this.hover)
			{
				this.Hover();
			}
		
			if (this.click)
			{
				this.Click();
				Mouse.lockClick = true;
				this.click = false;
			}
			
			if (this.rightClick)
			{
				this.RightClick();
				Mouse.lockRightClick = true;
				Mouse.rightClick = true;
				this.rightClick = false;
			}

			if (this.shade)
			{
				this.Shade();
				this.shade = false;
			}
		}
		
		this.progress = (this.currentValue / this.value) || 0;
		
		if(this.style.progressDisplay == "%")
		{
			this.text = Math.floor(this.progress * 100) + "%";
		}
		else if(this.style.progressDisplay == "none")
		{
			this.text = "";
		}
		else
		{
			this.text = this.currentValue + "/" + this.value;
		}
		
		if(isFunction(this.onUpdate))
		{
			this.onUpdate();
		}
	}
	
	Render()
	{
		if(!this.visible) return;
		
		var height = this.style.height;
		var width = this.style.width;

		if(this.style.backgroundImage == false)
		{
			ctx.save();
			ctx.fillStyle = this.style.backgroundColor;
			ctx.fillRect(this.x + this.style.borderSize, this.y + this.style.borderSize, width - (this.style.borderSize * 2), height - (this.style.borderSize * 2));
			ctx.restore();
		}
		else
		{
			ctx.drawImage(TextureManager.Get(this.style.backgroundImage), this.x + this.style.borderSize, this.y + this.style.borderSize, width - (this.style.borderSize * 2), height - (this.style.borderSize * 2));
		}
		
		
		if(!this.style.progressImage)
		{
			var progress = (this.progress <= 1) ? this.progress : 1;
			var bSize = this.style.borderSize;

			ctx.save();
			ctx.fillStyle = this.style.progressBar;
			
			if(this.reverseProgressDisplay)
			{
				if(this.style.borderRadius)
				{
					ctx.fillRect(this.x + width, this.y, -(width * progress), height);
					// Graphic.roundRect(ctx, this.x + width - (bSize / 2), this.y - (bSize / 2), -(width * progress) + bSize, height + bSize, this.style.borderRadius, true, false);
				}
				else
				{
					ctx.fillRect(this.x + width, this.y, -(width * progress), height);
				}
				
			}
			else
			{
				if(this.style.borderRadius)
				{
					Graphic.roundRect(ctx, this.x - (bSize / 2), this.y - (bSize / 2), (width * progress) + bSize, height + bSize, this.style.borderRadius, true, false);
				}
				else
				{
					ctx.fillRect(this.x, this.y, (width * progress), height);
				}
			}
			ctx.restore();
		}
		else
		{
			var frame = 0;
			var FrameHeight = height;

			if(this.style.Animation)
			{
				frame = this.style.Animation.Frame;
			}

			var texture = TextureManager.Get(this.style.progressImage);
			// ctx.drawImage(texture, 0, frame * height, (texture.width * this.progress), height, this.x + this.style.borderSize, this.y + this.style.borderSize, (width * this.progress) - (this.style.borderSize * 2), height - (this.style.borderSize * 2));
			ctx.drawImage(texture, 0, frame * height, (texture.width * this.progress), height, this.x, this.y, (width * this.progress), height);
		}
		
		if(this.style.borderImage == false)
		{
			var bSize = this.style.borderSize;
			ctx.save();
			ctx.strokeStyle = this.style.borderColor;
			ctx.lineWidth = bSize;
			
			if(this.style.borderRadius)
			{
				Graphic.roundRect(ctx, this.x - (bSize / 2), this.y - (bSize / 2), width + bSize, height + bSize, this.style.borderRadius, false, true);
			}
			else
			{
				ctx.strokeRect(this.x - (bSize / 2), this.y - (bSize / 2), width + bSize, height + bSize);
			}
			
			ctx.restore();
		}
		else
		{
			ctx.drawImage(TextureManager.Get(this.style.borderImage), this.x, this.y, width, height);
		}
		
		if(this.ShowText)
		{
			Style.FillText(ctx, this);
		}
	}
	
	Hover()
	{
		this.style = Style.GetStyleByName(this.className, STATE.HOVER);
		Mouse.cursor = this.style.cursor ?? Mouse.cursor;
		
		if(isFunction(this.onHover))
		{
			this.onHover();
		}
	}
	
	Click()
	{
		this.style = Style.GetStyleByName(this.className, STATE.CLICK);
		
		if(isFunction(this.onClick))
		{
			this.onClick();
		}
	}
	
	RightClick()
	{
		this.style = Style.GetStyleByName(this.className, STATE.RIGHTCLICK);
		
		if(isFunction(this.onRightClick))
		{
			this.onRightClick();
		}
	}
	
	Shade()
	{
		this.style = Style.GetStyleByName(this.className, STATE.SHADE);
		
		if(isFunction(this.onShade))
		{
			this.onShade();
		}
	}
}class Slider
{
	constructor(posX, posY, className, id, min, max, current, disabled, onUpdate, onChange)
	{
		this.className = className;
		this.id = id;

		this.value = current;
		this.lastValue = this.value;
		this.minValue = min;
		this.maxValue = max;

		this.onUpdate = onUpdate;
		this.onChange = onChange;
		
		this.hover = false;
		this.click = false;
		this.rightClick = false;
		this.disabled = disabled || false;
		this.ageInTicks = 0;
		
		this.style = Style.GetStyleByName(this.className);
		this.width = this.style.width;
		this.height = this.style.height;
		
		this.x = posX;
		this.y = posY;
		this.percent = (this.value / this.maxValue * 100);
		this.opacity = 1;
		this.focusAble = true;
	}
	
	Update()
	{
		Mouse.Check(this);
		this.ageInTicks++;
		this.style = Style.GetStyleByName(this.className);
		
		
		if(this.value != this.lastValue)
		{
			this.lastValue = this.value;
			if(isFunction(this.onChange))
			{
				this.onChange();
			}
		}

		if(!this.disabled)
		{
			if(this.hover)
			{
				this.Hover();
			}
		
			if (this.click)
			{
				this.Click();
				Mouse.lockClick = true;
				this.click = false;
			}
			
			if (this.rightClick)
			{
				this.RightClick();
				Mouse.lockRightClick = true;
				// Mouse.rightClick = true;
				this.rightClick = false;
			}

			if (this.shade)
			{
				this.Shade();
				this.shade = false;
			}
		
		}
		else
		{
			this.style = Style.GetStyleByName(this.className, STATE.DISABLED);
			this.rightClick = false;
			this.click = false;
		}
		
		if(isFunction(this.onUpdate))
		{
			this.onUpdate();
		}
	}
				
	Render()
	{			
		var width = this.style.width;
		var height = this.style.height;

		if(!this.style.backgroundImage)
		{
			var bSize = this.style.borderSize;
			ctx.save();
			ctx.globalAlpha = this.opacity;
			ctx.fillStyle = this.style.backgroundColor;
			
			if(this.style.borderRadius)
			{
				Graphic.roundRect(ctx, this.x - (bSize / 2), this.y - (bSize / 2), width + bSize, height + bSize, this.style.borderRadius, true, false);
			}
			else
			{
				ctx.fillRect(this.x - (bSize / 2), this.y - (bSize / 2), width + bSize, height + bSize);
			}
			
			ctx.restore();
		}
		else
		{
			ctx.save();
			ctx.globalAlpha = this.opacity;
			ctx.drawImage(TextureManager.Get(this.style.backgroundImage), this.x + this.style.borderSize, this.y + this.style.borderSize, width - (this.style.borderSize * 2), height - (this.style.borderSize * 2));	
			ctx.restore();
		}


		if(!this.style.borderImage)
		{
			var bSize = this.style.borderSize;
			ctx.save();
			ctx.globalAlpha = this.opacity;
			ctx.strokeStyle = this.style.borderColor;
			ctx.lineWidth = bSize;
			
			if(this.style.borderRadius)
			{
				Graphic.roundRect(ctx, this.x - (bSize / 2), this.y - (bSize / 2), width + bSize, height + bSize, this.style.borderRadius, false, true);
			}
			else
			{
				ctx.strokeRect(this.x - (bSize / 2), this.y - (bSize / 2), width + bSize, height + bSize);
			}
			
			ctx.restore();
		}
		else
		{
			ctx.save();
			ctx.globalAlpha = this.opacity;
			ctx.drawImage(TextureManager.Get(this.style.borderImage), this.x, this.y, width, height);
			ctx.restore();
		}



		if(this.style.sliderPointer)
		{
			var width = (this.style.sliderPointer.width != null) ? this.style.sliderPointer.width : this.style.width;
			var height = (this.style.sliderPointer.height != null) ? this.style.sliderPointer.height : this.style.height;

			var backgroundColor = (this.style.sliderPointer.backgroundColor != null) ? this.style.sliderPointer.backgroundColor : this.style.backgroundColor;
			var borderColor = (this.style.sliderPointer.borderColor != null) ? this.style.sliderPointer.borderColor : this.style.borderColor;
			var borderRadius = (this.style.sliderPointer.borderRadius != null) ? this.style.sliderPointer.borderRadius : this.style.borderRadius;

			var bSize = borderRadius;

			var x = this.x + (this.percent * this.style.width / 100) - (width / 2);
			var y = this.y;

			ctx.save();
			ctx.globalAlpha = this.opacity;
			ctx.strokeStyle = borderColor;
			ctx.fillStyle = backgroundColor;
			ctx.lineWidth = bSize;

			if(borderRadius)
			{
				Graphic.roundRect(ctx, x - (bSize / 2), y - (bSize / 2), width + bSize, height + bSize, bSize, true, true);
			}
			else
			{
				ctx.strokeRect(x - (bSize / 2), y - (bSize / 2), width + bSize, height + bSize);
			}

			ctx.restore();
		}

		
	}
	
	Hover()
	{
		this.style = Style.GetStyleByName(this.className, STATE.HOVER);
		Mouse.cursor = this.style.cursor ?? Mouse.cursor;
		
		if(isFunction(this.onHover))
		{
			this.onHover();
		}

		if(Mouse.click)
		{
			var margin = 5;

			var x = (Mouse.x - margin) - this.x;
				x = (x < 0) ? 0 : x;

			var percent = (x / (this.style.width - 2 * margin) * 100);
				percent = (percent > 100) ? 100 : percent;

			this.percent = percent;
			this.value = Math.round(percent * (this.maxValue - this.minValue) / 100);
		}
	}
	
	Click()
	{
		this.style = Style.GetStyleByName(this.className, STATE.CLICK);

		if(isFunction(this.onClick))
		{
			this.onClick();
		}
	}
	
	RightClick()
	{
		this.style = Style.GetStyleByName(this.className, STATE.RIGHTCLICK);
		
		if(isFunction(this.onRightClick))
		{
			this.onRightClick();
		}
	}
	
	Shade()
	{
		this.style = Style.GetStyleByName(this.className, STATE.SHADE);
		
		if(isFunction(this.onShade))
		{
			this.onShade();
		}
	}
}
class Item
{
	constructor()
	{
		this.maxStackSize = 999;
		
		this.count = 1;
		this.type = TYPE.ITEM;

		this.slot = "";
		this.name = "";

		this.stackAble = true;		//przedmiot mozna stackowac
		this.pickAble = true;		//przedmiot moze zostac podniesiony (z ziemi)
		this.equipAble = false;		//przedmiot mozna zalozyc
		this.shineStrength = 0;				//sila polysku
		this.showNewItemInfo = false; 		//czy ma pokazywac 'New!'
		this.price = 0;

		this.inShopPrice = 0;		//cena w sklepie
		this.isInShop = false;		//przedmiot znajduje sie w ekwipunku handlarza
		this.isFromMerchant = false;

		this.Recipe = null;
		this.showInBubble = true;		//render bubble when item is on floor
		this.onFloorScale = 1;
		this.canBeDroppedOut = true;	//can you throw this item away ?
		this.isUnique = false;			//unique items cannot be thrown away
		this.showGrade = true;
		this.canBeSold = true;
		this.showPriceInfo = true;

		this.restrictTypes = 0;	//only certain number of items with this type can be equipped
		this.Lore = null;
		this.Description = null;
		this.ARGS = {};
		this.FILTER = '';
	}

	GetPrimaryBonuses()
	{
		return this.primary ?? [];
	}

	GetId()
	{
		return this.constructor.name;
	}

	GetFilter(onlySelf = false)
	{
		if(onlySelf) return this.FILTER;

		var f = this.FILTER +';'+this.type+';'+this.slot;
		if(this.Recipe) f+=';'+'GOT_RECIPE';
		return f;
	}

	isMaterial()
	{
		return ItemHelper.isMaterial(this);
	}

	getShineStrength()
	{
		if(this.shineStrength) return this.shineStrength;
		if(!this.Grade) return 0;

		if(this.Grade == GRADE.NORMAL) return 0;
		if(this.Grade == GRADE.COMMON) return .25;
		if(this.Grade == GRADE.RARE) return .5;
		if(this.Grade == GRADE.MYTHICAL) return .75;
		return 1;
	}

	getLore()
	{
		if(!this.Lore) return null;
		return Lang.Get(this.Lore, this.ARGS).split('\n');
	}

	getChargeDescription()
	{
		if(!this.ChargeDescription) return null;
		return Lang.Get(this.ChargeDescription, this.ARGS).split('\n');
	}

	getDescription()
	{
		if(!this.Description) return null;
		return Lang.Get(this.Description, this.ARGS).split('\n');
	}

	getDisplayName()
	{
		if(!this.name) return '';
		return Lang.Get(this.name, this.ARGS);
	}

	canBeEquipped(owner, equips_path = 'equips', certainSlot = null)
	{
		if(!this.equipAble) return false;

		if(this.restrictTypes)
		{
			var equipped_types = {};
			for(var slot in owner[equips_path])
			{
				var item = owner[equips_path][slot];
				if(!item) continue;

				if(!equipped_types[item.type]) equipped_types[item.type] = 0;
				equipped_types[item.type]++;
			}

			if(certainSlot)
			{
				//you can replace item with same type
				if(owner[equips_path][certainSlot]?.type == this.type) return true;
			}

			if(equipped_types[this.type] >= this.restrictTypes) return false;
		}

		if(certainSlot && this.slot != certainSlot.replace(/[0-9]/, '')) return false;

		return true;
	}
	
	static Get(name)
	{
		return ItemHelper.getInstanceOfItem(name);
	}

	onInventoryTick()
	{

	}

	onEquip()
	{

	}

	onEquipTick()
	{
		
	}

	Drop(x, y, ownerInventory, dirX)
	{
		this.onDropOut?.();
		if(!this.canBeDroppedOut || this.isUnique) return false;

		var entity = new EntityItem(this, x, y, dirX);
		if(ownerInventory)
		{
			for(var i = 0; i < ownerInventory.length; i++)
			{
				if(ownerInventory[i] == this)
				{
					ownerInventory[i] = null;
				}
			}
		}

		World.AddEntity(entity);
		return true;
	}

	DrawShine(x, y, scale = 1, preventUpdate = false)
	{
		if(this.upgradeAble)
		{
			if(this.upgradeLevel > 4)
			{
				this.shineStrength = (this.upgradeLevel - 4) * 0.2;
			}
		}

		if(!this.shineStrength) return;

		if(!(this.shineRotation instanceof Transition) || !this.shineRotation) 
		{
			this.shineRotation = new Transition(0, 360, 20, false, 0, 0, true);
			this.shineRotation.RandomizeTicks();
		}

		if(!(this.shineSize instanceof Transition) || !this.shineSize)
		{
			this.shineSize = new Transition(25, 35, 0.5, true, 0, 0);
			this.shineSize.RandomizeTicks();
		}

		var rotation = (preventUpdate) ? this.shineRotation.Get() : this.shineRotation.Update();
		var size = (preventUpdate) ? this.shineSize.Get() : this.shineSize.Update();

		Graphic.ApplyShineEffect(x, y, size * scale * this.shineStrength, 1, rotation);
	}

	Pick(owner, entityItem)
	{
		owner.addItemToInventory(this);
		World.RemoveEntity(entityItem);
	}
}class ItemBag extends Item
{
	constructor(name)
	{
		super();

		this.stackAble = true;
		this.maxStackSize = 99;
		this.upgradeAble = false;
		this.enchantAble = false;
		this.Items = [];
		this.Texture = 'treasureBag';

		this.Grade = GRADE.LEGENDARY;
		this.showGrade = false;
		this.name = name;
		this.Description = 'ITEM.BAG.DESCRIPTION';
		this.canBeSold = false;

		this.showInBubble = false;
		this.onFloorScale = 2;
	}

	getDescription()
	{
        if(this.Items.length == 0)
        {
            return ['Cannot be used.'];
        }

        var desc = Lang.Get(this.Description);

        for(var i in this.Items)
        {
            var itemData = this.Items[i];
			var item = Item.Get(itemData.Type);
            if(!item) continue;

            desc += '\n-'+item.getDisplayName();
        }

		desc += '\n\n'+Lang.Get('ITEM.CLICK_TO_OPEN.RIGHT');

        return desc.split('\n');
	}

	onUse(player)
	{
		this.count--;

		for(var i = 0; i < this.Items.length; i++)
		{
			var ItemData = this.Items[i];
			if(MathHelper.GetChance(ItemData.Chance))
			{
				var count = MathHelper.randomInRange(ItemData.Min, ItemData.Max);

				var item = ItemHelper.getInstanceOfItem(ItemData.Type);
				if(item)
				{
					if(item.stackAble)
					{
						item.count = count;
					}

					var dir = (MathHelper.GetChance(50)) ? 1 : -1;

					item.Drop(player.x, player.y, null, dir);
				}
			}
		}

		if(this.count <= 0)
		{
			var index = player.inventory.indexOf(this);
			if(index > -1)
			{
				player.inventory[index] = null;
			}
		}
	}
}class ItemBonus
{
	constructor(id, value, isPercent = false)
	{
		this.name = Lang.Get(id);
		this.id = id;
		
		this.isPercent = isPercent;
		this.value = value;		
	}

	static GetBonusValue(stat_name, bonus_list = [])
	{
		for(var i = 0; i < bonus_list.length; i++)
		{
			var bonus = bonus_list[i];
			if(bonus.id == stat_name) return bonus.value;
		}
		return null;
	}
}class ItemHelper
{
	static Initialize()
	{
		this.totalItems = 0;
		this.Items = {};
		this.Recipes = {};
		this.ItemPrices = {};

		for(var i = 0; i < this.ItemsConstructors.length; i++)
		{
			var _item = this.ItemsConstructors[i];
			var temp = new _item();
			var name = temp.constructor.name;
			this.Items[name] = _item;

			this.totalItems++;
		}
	}

	static InitLocationDrop(location)
	{
		this.ItemsInLocation = this.ItemsInLocation ?? {};

		var entities = location.RoomInfo?.EntityTypes;
		for(var i in entities)
		{
			var entity = new World.EntityList[entities[i]]();
			var loot = entity.LootTable;
			if(!loot) continue;

			for(var j in loot.itemList)
			{
				this.ItemsInLocation[loot.itemList[j].Type] = location.GetId();
			}
		}
	}

	static CanBeBlessed(item, blessing)
	{
		if(isFunction(blessing.Require))
		{
			return blessing.Require(item);
		}
		return false;
	}

	static CanBeEnchanted(item, enchant)
	{
		if(!item.enchantAble) return null;
		var alreadyBonuses = [];
		var emptyIndex = null;


		if(isFunction(enchant.Require))
		{
			if(!enchant.Require(item)) return null;
		}

		var slots = item.getEnchantSlots?.() ?? 0;
		if(!slots) return null;

		for(var i = 0; i < slots; i++)
		{
			if(!item.Enchants[i])
			{
				if(emptyIndex == null) emptyIndex = i;
				continue;
			}

			if(item.Enchants[i].bonus)
			{
				if(enchant.bonus)
				{
					if(item.Enchants[i].bonus.name == enchant.bonus.name)
					{
						//uzyto enchantu z takim samym bonusem
						if(item.Enchants[i].bonus.name == enchant.bonus.name)
						{
							if(item.Enchants[i].bonus.isPercent == enchant.bonus.isPercent && 
								item.Enchants[i].bonus.value < enchant.bonus.value)
								{
									//tylko jesli zakladany enchant ma wieksza wartosc niz aktualny
									return i;
								}
						}
					}
				}
				
				alreadyBonuses.push(item.Enchants[i].bonus.name);
			}
		}

		if(emptyIndex != null)
		{
			if(enchant.bonus)
			{
				if(!alreadyBonuses.includes(enchant.bonus.name))
				{
					//przedmiot moze byc enchantowany
					return emptyIndex;
				}
			}
			else
			{
				return emptyIndex;
			}
		}

		return null;
	}

	static GetUpgradeChance(item, player, upgradeItem)
	{
		if(item.upgradeAble && item.upgradeLevel < 9)
		{
			var chance = item.upgradeChances[item.upgradeLevel];

			if(player)
			{
				if(player.stats)
				{
					chance += Math.floor(player.stats.LUCK / 10);
				}
			}

			if(upgradeItem)
			{
				if(upgradeItem.upgradeChance) chance += upgradeItem.upgradeChance;
			}

			chance = (chance > 100) ? 100 : chance;
			chance = (chance < 0) ? 0 : chance;

			return chance;
		}
		return 0;
	}

	static GetUpgradeCost(item, level = item.upgradeLevel)
	{
		var cost = 50;		//default upgrade cost is equal to 50% of current item value

		if(item.upgradeAble && level < 9)
		{
			if(item.upgradeCosts[level]) return item.upgradeCosts[level];
			var base_price = ItemHelper.GetBaseItemPrice(item);
			var current_value = (base_price * Math.pow((100 + cost) / 100, level));
			
			return Math.round(current_value * 50 / 100);		
		}
		return 0;
	}

	static getItemDropLocations(item)
	{
		var dropLocations = [];
		var locations = getLocationOrder();
		// var droppableItems = ItemHelper.GetItemsInLocationOrder();
		// if(droppableItems.indexOf(item) == -1) return [];
	
		for(var i = 0; i < locations.length; i++)
		{
			var availableDrop = locations[i].GetAvailableDrop();
			for(var j = 0; j < availableDrop.length; j++)
			{
				if(availableDrop[j] == item.GetId()) dropLocations.push(locations[i].GetId());
			}
		}

		return dropLocations;
	}

	static GetFilteredItems(_filter = null, toObject = false)
	{
		var items = [];
		var items_obj = {};
		for(var name in this.Items)
		{
			var item = Item.Get(name);
			if(!item) continue;
			if(_filter && !filter(_filter, item.GetFilter(), true)) continue;

			items.push(name);
			items_obj[name] = item;
		}

		if(toObject) return items_obj;
		return items;
	}

	static GetItemsInLocationOrder(_filter = null, getAll = false)
	{
		var items = [];
		var list = getLocationOrder();
		var name, i, j, itemName, item, drops;

		for(i = 0; i < list.length; i++)
		{
			name = list[i].constructor.name;
			if(World.Player.locationInfo[name]?.isCleared || getAll)
			{
				drops = list[i].GetAvailableDrop();
				// types = list[i].RoomInfo.EntityTypes;
				for(j = 0; j < drops.length; j++)
				{
					itemName = drops[j];
					item = Item.Get(itemName);
					if(!item) continue;
					if(_filter && !filter(_filter, item.GetFilter(), true)) continue;

					if(items.indexOf(itemName) == -1) items.push(itemName);
					
					// itemList[lootTable.itemList[k].Type] = true;
				}
			}
		}

		return items;
	}

	static GetBaseItemPrice(item)
	{
		var price = item.price;
		var base_price = 100;

		if(item.type == TYPE.ITEM) base_price = 10;		//materials are less valuable

		if(price == null) return 0;

		if(price == 0)
		{
			if(this.ItemPrices[item.GetId()]) return this.ItemPrices[item.GetId()];
			
			var locations = getLocationOrder(true);
			var locationDrop = this.ItemsInLocation[item.GetId()];

			var index = locations.indexOf(locationDrop);
			price = base_price * (index-1);
			if(index == -1) price = 1;	//this item cannot drop


			// var drops_in = ItemHelper.getItemDropLocations(item);
			// var locations = getLocationOrder(true);
			// var lowest_id = 9999;

			// for(var i = 0; i < drops_in.length; i++)
			// {
			// 	var id = locations.indexOf(drops_in[i]);
			// 	if(id < lowest_id) lowest_id = id;
			// }

			// price = base_price * lowest_id;
			// if(lowest_id == 9999) price = 1;	//this item cannot drop
		}

		if(price == 0) price = 1;
		item.price = price;
		this.ItemPrices[item.GetId()] = price;

		if(item.Grade)
		{
			var info = ItemHelper.GetGradeInfo(item.Grade);
			price *= info.price;
		}

		return price;
	}

	static GetUpgradesValue(item)
	{
		var upgradeCostRefund = 1;
		var price = 0;
		if(item.upgradeAble)
		{
			for(var i = 0; i < item.upgradeLevel; i++)
			{
				price += Math.round(ItemHelper.GetUpgradeCost(item, i) * upgradeCostRefund);
			}
		}

		return price;
	}

	static GetItemPrice(item, count = null)
	{
		var price = {buy: 0, sell: 0};

		if(!item.canBeSold) return {buy: 'none', sell: 'none'}

		var base_price = ItemHelper.GetBaseItemPrice(item);
		var re_buy_tax = 1;	//1.3
		
		count = count ?? item.count;

		// price.sell += ItemHelper.GetUpgradesValue(item);
		price.sell += base_price;
		price.sell *= count;

		if(item.isFromMerchant)
		{
			//items from merchant costs 10 times more
			price.buy = price.sell * 10;
			if(item.inShopPrice) price.buy = item.inShopPrice * count;
		}
		else
		{
			//% tax on re-buying items
			price.buy = price.sell * re_buy_tax;
		}

		return price;
	}

	static GetGradeInfo(grade)
	{
		var heart = Player.GetHeartValue() * 2;
		var info =
		{
			[GRADE.NORMAL]: {chance: 100, bonus: 0, price: 1},
			[GRADE.COMMON]: {chance: 50, bonus: 10, price: 2},
			[GRADE.RARE]: {chance: 30, bonus: 20, price: 5},
			[GRADE.MYTHICAL]: {chance: 10, bonus: 30, price: 10},
			[GRADE.LEGENDARY]: {chance: 5, bonus: 50, price: 20},

			[GRADE.ANGELIC]: {chance: 0, bonus: 75, price: 50, specialBonus: [new ItemBonus(STAT.MAX_HP, heart)]},
			[GRADE.DEMONIC]: {chance: 0, bonus: 75, price: 50, specialBonus: [new ItemBonus(STAT.ATTACK_DAMAGE, 20, true)]},
			[GRADE.DIVINE]: {chance: 0, bonus: 100, price: 100, specialBonus: 
				[
					new ItemBonus(STAT.MAX_HP, heart),
					new ItemBonus(STAT.ATTACK_DAMAGE, 20, true)
				]},
			[GRADE.TRANSCENDENTAL]: {chance: 0, bonus: 200, price: 1000}
		};

		return (info[grade]) ? info[grade] : info;
	}

	static GetGradesOrder(grade)
	{
		var order = 
		[
			GRADE.NORMAL,
			GRADE.COMMON,
			GRADE.RARE,
			GRADE.MYTHICAL,
			GRADE.LEGENDARY,
			GRADE.ANGELIC,
			GRADE.DEMONIC,
			GRADE.DIVINE,
			GRADE.TRANSCENDENTAL
		];

		if(!grade) return order;
		return order.indexOf(grade);
	}

	static CopyItem(item)
	{
		var type = item.constructor.name;
		var newItem = ItemHelper.getInstanceOfItem(type);
		if(newItem)
		{
			return  Object.assign(newItem, item);
		}
		return null;
	}

	static InitializeItem(_item)
	{
		this.ItemsConstructors = this.ItemsConstructors || [];
		this.ItemsConstructors.push(_item);
	}

	static InitializeRecipes()
	{
		for(var i = 0; i < this.ItemsConstructors.length; i++)
		{
			var item = new this.ItemsConstructors[i]();
			if(item.Recipe) this.Recipes[this.ItemsConstructors[i].name] = item.Recipe;
		}
	}
	
	static getInstanceOfItem(name, data = {})
	{
		if(this.Items[name])
		{
			var item = new this.Items[name]();
			for(var i in data)
			{
				item[i] = data[i];
			}
			return item;
		}
		
		return null;
	}
	
	
	static RandomItemBonus(item, onlyPerfect = false)
	{
		while(true)
		{
			var bonuses = getItemBonuses(item.type);
			var alreadyBonuses = new Array(Item.Bonuses.Length);
			var bonusId;
			var bonusName;
			var bonusLevel;
			var max_bonus_count = 0;

			var bonusesNumber = getItemGrade(item);
			var bonus_number = bonusesNumber[0];

			item.secondary = [[]];		//kasuje wszystkei aktualne bonusy

			var min_bonus_level = bonusesNumber[2];
			var max_bonus_level = bonusesNumber[3];

			for (var num = 0; num < alreadyBonuses.length; num++)
			{
				alreadyBonuses[num] = -1;
			}


			for (var num = 0; num < item.primary.length; num++)
			{
				if (item.primary[num] != null)
				{
					alreadyBonuses[num] = item.primary[num].id;
					//dodaje do tablicy obecnych bonusow, bonusy stale
				}
			}

			for (var num = 0; num < bonus_number; num++)
			{
				bonusId = Math.random() * Item.Bonuses.length;

				while ((!bonuses.Contains(bonusId)) || (alreadyBonuses.Contains(bonusId)))
				{
					//wylosowane id nei znajduje sie w tablicy dostepnych bonusow
					//lub
					//wylosowane id zostalo juz wczesniej wylosowane

					bonusId = Math.random() * Item.Bonuses.length;
				}

			//	bonusName = Item.Bonuses[bonusId].name;
				bonusLevel = random.Next(min_bonus_level, max_bonus_level + 1);

				if (bonusLevel > max_bonus_level)
				{
					bonusLevel = max_bonus_level;
				}


				if (bonusLevel == max_bonus_level)
				{
					max_bonus_count++;
				}


				if (max_bonus_count == bonus_number)
				{
					item.isPerfect = true;
				}
				else
				{
					item.isPerfect = false;
				}


				for (var num2 = 0; num2 < alreadyBonuses.length; num2++)
				{
					if (alreadyBonuses[num2] == -1)
					{
						alreadyBonuses[num2] = bonusId;
						break;
					}
				}

				item.secondary[num] = [ bonusId, bonusLevel ];

			}


			if ((!onlyPerfect) || (item.isPerfect))
			{
				break;
			}
		}

	}

	static isMaterial(item)
	{
		for(var name in this.Recipes)
		{
			if(this.isMaterialFor(item, name)) return true;
		}
		return false;
	}

	static isMaterialFor(item, recipe_id)
	{
		var id = item.GetId();
		var recipe = this.Recipes[recipe_id];
		if(!recipe) return false;

		for(var i = 0; i < recipe.Ingredients.length; i++)
		{
			var ingr = recipe.Ingredients[i];
			if(ingr[0] == id) return true;
		}
		return false;
	}

	static getAllRecipesFrom(item, toObj = false)
	{
		var recipes = [];
		var obj_recipes = {};
		if(item)
		{
			for(var name in this.Recipes)
			{
				if(this.isMaterialFor(item, name)) 
				{
					recipes.push(name);
					obj_recipes[name] = true;
				}
			}
		}

		if(toObj) return obj_recipes;
		return recipes;
	}

	static getRecipeFrom(items, getAll = false)
	{
		var all_recipes = {};
		var recipe = {};
		var itemsToUse = 0;
		var possible = [];

		for(var i in items)
		{
			var item = items[i];
			if(!item) continue;
			itemsToUse++;
			recipe = this.getAllRecipesFrom(item, true);
			all_recipes = {...all_recipes, ...recipe};
		}

		for(var name in all_recipes)
		{
			var rec = this.Recipes[name];
			var itemsUsed = 0;

			for(var i = 0; i < rec.Ingredients.length; i++)
			{
				var ing = rec.Ingredients[i];
				var gotThis = false;
				for(var j in items)
				{
					if(!items[j]) continue;

					if(items[j].GetId() == ing[0])
					{
						if(items[j].count >= ing[1] || getAll)
						{
							gotThis = true;
							itemsUsed++;
							break;
						}
					}
				}
				if(!gotThis && !getAll)
				{
					break;
				}
			}

			//return this recipe only if its using all of the items
			if(itemsToUse == itemsUsed && itemsUsed == rec.Ingredients.length && !getAll) return rec;
			if(itemsToUse == itemsUsed) possible.push(rec);
		}
		
		if(getAll) return possible;

		return null;
	}
	
	
	static getItemBonuses(type = TYPE.ITEM)
	{
		var bonuses = 
		{
			"Gun": [0, 1, 2, 3, 4, 5, 6, 7, 8]

		};
		
		bonuses[TYPE.SWORD] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];

		if (bonuses[type])
		{
			return bonuses[type];
		}
		else
		{
			return [];
		}
	}
	
	static GetRandomGrade()
	{
		var grades = ItemHelper.GetGradeInfo();
		var highest_grade = 0;
		var order = ItemHelper.GetGradesOrder();

		for(var i = 0; i < order.length; i++)
		{
			var name = order[i];
			if(name == GRADE.NORMAL) continue;
			if(name == GRADE.ANGELIC) continue;	//demonic and angelic are same tier

			if(MathHelper.GetChance(grades[name].chance)) highest_grade = i;
		}

		var resultGrade = order[highest_grade];
		if(resultGrade == GRADE.DEMONIC) if(MathHelper.GetChance(50)) resultGrade = GRADE.ANGELIC;

		return resultGrade;
	}
}



class ItemRecipe
{
	constructor(item, ingredients = [])
	{
		this.Result = item;
		this.Ingredients = ingredients;
	}
}



// function testGrades(iterations)
// {
// 	var grades = {};
// 	for(var i = 0; i < iterations; i++)
// 	{
// 		var g = ItemHelper.GetRandomGrade();
// 		if(!grades[g]) grades[g] = 0;
// 		grades[g]++;
// 	}

// 	return grades;
// }
class ItemUpgradeAble extends Item
{
	constructor(enchantAble = true)
	{
		super();

		this.upgradeLevel = 0;
		this.maxLevel = 9;
		this.maxStackSize = 1;
		this.stackAble = false;
		this.requiredLevel = 0;

		this.upgradeAble = true;
		this.equipAble = true;
		this.isPerfect = false;

		this.Element = ELEMENT.PHYSICAL;

		this.Grade = ItemHelper.GetRandomGrade();
		

		if(enchantAble)
		{
			this.enchantAble = true;
			this.enchantSlots = 0;
			this.Enchants = [];
		}
		
		this.upgradeCosts = [];
		this.upgradeChances = [100, 90, 80, 70, 60, 50, 40, 30, 20];
	}

	getEnchantSlots()
	{
		return this.enchantSlots;
	}

	Bless(blessing, simulate = false)
	{
		if(ItemHelper.CanBeBlessed(this, blessing))
		{
			blessing.Bless(this, simulate);
			return true;
		}

		return false;
	}

	Enchant(enchant)
	{
		var index = ItemHelper.CanBeEnchanted(this, enchant);
		if(index === null) return false;

		this.Enchants[index] = enchant;
		return true;
	}

	Upgrade(player, degradeOnFail)
	{
		if(this.CanBeUpgraded(player))
		{
			player.coins -= ItemHelper.GetUpgradeCost(this);
			if(MathHelper.GetChance(ItemHelper.GetUpgradeChance(this, player, player.hand)))
			{
				this.upgradeLevel++;
				return true;
			}
			else
			{
				if(degradeOnFail)
				{
					this.upgradeLevel--;
				}
			}
		}
		
		return false;
	}

	CanBeUpgraded(player)
	{
		if(!this.upgradeAble || this.upgradeLevel >= this.maxLevel) return false;

		if(ItemHelper.GetUpgradeCost(this) <= player.coins) return true;
		
		return false;
	}
}class ItemWeapon extends ItemUpgradeAble
{
    constructor(enchantAble = true)
    {
        super(enchantAble);

        this.slot = SLOT.CANNON;
        this.BulletType = 'BulletBubble';
		this.ammoCost = 0;

        this.attackCharge = 9999;   //allows to shoot immediately on game enter
        this.requiredCharge = 60;
        this.bulletSery = 0;
        this.BULLET_SERY_DELAY = 5;
        this.BULLET_SERIES = 1;
        this.bulletDamageMultiplier = 1;
        this.bullets = 1;
        this.chargeBullets = 1;

        this.showRequiredMP = true;
        this.requiredMP = 0;
        this.currentMP = 0;
        this.fixedMP = null;
        this.MPgain = 'SHOOT';
        this.knockBack = .5;
        this.onUseKnockBack = 0;

        this.Owner;
        this.FILTER = 'WEAPON';

        this.lastProjectile = null;


        this.canIncreaseBaseBulletCount = false;
        this.canIncreaseChargeBulletCount = false;

        this.nextShootData = {};
        this.shootBeforeCharge = true;
        this.Charged = null;
    }

    canIncreaseBulletsCount()
    {
        if(this.canIncreaseBaseBulletCount) return true;
        if(this.canIncreaseChargeBulletCount) return true;
        return false;
    }

    CalculateBullets(base)
    {
        var bonus = 0;
        var bonus_p = 0;
        var bonusValue = 0;

        if(this.Grade != GRADE.NORMAL)
        {
            var gradeInfo = ItemHelper.GetGradeInfo(this.Grade);
            if(gradeInfo != null) bonusValue = gradeInfo.bonus;
        }

        for(var i in this.Enchants)
        {
            var enchant = this.Enchants[i];
            if(!enchant) continue;

            var value = Math.round(enchant.bonus.value + (enchant.bonus.value * bonusValue / 100));

            if(enchant.bonus.id == STAT.BULLETS_COUNT)
            {
                if(enchant.bonus.isPercent) bonus_p += value;
                else bonus += value;
            }
        }

        base += bonus;
        base *= (100 + bonus_p) / 100;

        return Math.ceil(base);
    }

    GetBulletCount(charged = false)
    {
        if(charged)
        {
            if(!this.canIncreaseChargeBulletCount) return this.chargeBullets;
            return this.CalculateBullets(this.chargeBullets);
        }

        if(!this.canIncreaseBaseBulletCount) return this.bullets;
        return this.CalculateBullets(this.bullets);
    }

    onSpecialCharge(){}

    UpdateSpecialCharge(owner)
    {
        if(!this.requiredMP) return;

        if(this.MPgain == 'SHOOT')
        {
            var mp = this.fixedMP ?? owner.getSpecialCharge();
            this.currentMP += mp;
        }

        if((this.currentMP >= this.requiredMP && !this.shootBeforeCharge) ||
        (this.currentMP > this.requiredMP && this.shootBeforeCharge))
        {
            this.currentMP = 0;
            this.onSpecialCharge();
            this.isChargedShot = true;
            return;
        }
    }

    UpdateSpecialChargeGauge(owner = this.Owner)
    {
        owner.specialAttackGauge = this.currentMP / this.requiredMP;

        if(this.MPgain == 'SHOOT')
        {
            //fill gauge if onwer get more mp than need
            var mp = this.fixedMP ?? owner.getSpecialCharge();
            if(mp >= this.requiredMP) owner.specialAttackGauge = 1;
        }
    }

    onOwnerUpdate(owner)
    {
        if(!owner) return;
        this.Owner = owner;

        this.UpdateAttackCharge();
        this.UpdateSpecialChargeGauge(owner);
    }

    UpdateAttackCharge(owner = this.Owner)
    {
        if(owner.isAttacking || (this.bulletSery < this.BULLET_SERIES && this.BULLET_SERIES > 1 && this.bulletSery > 0))
        {
            if (this.attackCharge >= this.requiredCharge)
            {
                if(this.shootBeforeCharge) this.Shoot(owner);
                this.UpdateSpecialCharge(owner);
                if(!this.shootBeforeCharge) this.Shoot(owner);

                this.bulletSery++;
                if(this.bulletSery >= this.BULLET_SERIES)
                {
                    this.attackCharge = 0;
                    this.bulletSery = 0;
                }
                else
                {
                    if(this.BULLET_SERY_DELAY) this.attackCharge -= this.BULLET_SERY_DELAY;
                }
            }
            else
            {
                this.attackCharge += owner.stats.ATTACK_SPEED;
            }
        }
        else
        {
            if (this.attackCharge < this.requiredCharge)
            {
                this.attackCharge += owner.stats.ATTACK_SPEED;
            }
            else
            {
                this.attackCharge = this.requiredCharge;
            }
        }

        owner.attackGauge = this.attackCharge / this.requiredCharge;
    }

    ConsumeAmmo(owner = this.Owner)
    {
        var cost_reduction = owner.stats[STAT.AMMO_COST];

        var cost = this.ammoCost - cost_reduction;
        if(cost < 1) cost = (this.ammoCost) ? 1 : 0;

        var dir = (Mouse.x <= owner.posX) ? 1 : -1;

        if(cost <= owner.coins)
        {
            DamageIndicator.AddObject(owner.x, owner.y, -cost, "AMMO", dir);
            owner.coins -= cost;
            return true;
        }
        else
        {
            DamageIndicator.AddObject(owner.x, owner.y, Lang.Get('TEXT.NOT_ENOUGH_OXYGEN'), "RECEIVED", dir);
        }
        return false;
    }

    GetAdditionalBulletStats(){return {}}

    GetBulletDamageInfo(owner = this.Owner)
    {
        var info = 
        {
            AD: owner.stats.AD,
            criticalChance: owner.stats.CR,
            criticalDamage: owner.stats.CD,
            element: this.Element
        };
        return info;
    }

    Shoot(owner = this.Owner)
    {
        if(Main.RUNNING != RUNNING.INGAME) return;

        var type = Projectile.Types();
        var bulletType = this.nextShootData.BulletType || this.BulletType;
		if(!type[bulletType]) return;

        owner.UpdateBulletStats();

		var damageMultiplier = 1 * this.bulletDamageMultiplier;
        var haveEnoughOxygen = true;

        if(this.ammoCost) haveEnoughOxygen = this.ConsumeAmmo();

		// owner.target = Mouse;
		
		var maximalAngle = 90;
		var angleDiff = 10;
		var shotCount = this.GetBulletCount();
		
		
		var minAngle = shotCount * angleDiff;
		if(minAngle > maximalAngle) minAngle = maximalAngle;
		
		var targetAngle = MathHelper.getAngle2([owner.x, owner.y], [Mouse.x + Camera.xView, Mouse.y + Camera.yView]);
		var angle = targetAngle - (minAngle / 2);
		if(shotCount == 1) angle = targetAngle;

		var angleStep = minAngle / (shotCount - 1);

		//get bullet spawn position
		var startPos = owner.GetBulletStartPos();
		var distance = MathHelper.GetDistance([startPos.x - Camera.xView, startPos.y- Camera.yView], [Mouse.x, Mouse.y]);

		var damageInfo = {...this.GetBulletDamageInfo(owner)};
        if(!haveEnoughOxygen) 
        {
            damageInfo.AD = 1;
            damageMultiplier = 1;
        }


        var mp = this.fixedMP ?? owner.getSpecialCharge();
        if(this.MPgain != 'HIT') mp = 0;

		for(var i = 0; i < shotCount; i++)
		{
			var target = MathHelper.lineToAngle([startPos.x, startPos.y], distance, angle);

			var dmgValues = owner.GetDamageValues(Math.floor(damageInfo.AD * damageMultiplier), damageInfo.element);
			owner.bulletStats.damage = damageInfo.damage ?? dmgValues;
            owner.bulletStats.criticalChance = damageInfo.criticalChance;
            owner.bulletStats.criticalDamage = damageInfo.criticalDamage;
			
			var bullet = new type[bulletType](startPos.x, startPos.y, owner.bulletStats);
                bullet.setStats(this.GetAdditionalBulletStats());
				bullet.Shoot(owner, target);
                bullet.MP = mp;
                bullet.Item = this;
                bullet.bulletSery = this.bulletSery;
                if(bullet.knockBack) bullet.knockBack = this.knockBack;
                if(this.isChargedShot) bullet.bullets = this.GetBulletCount(true);
                else bullet.bullets = 0;
				
			World.AddProjectile(bullet);

			if(!World.currentRoom.isCleared)
			{
				owner.RunStats.totalShots++;
			}
				
			angle += angleStep;

            this.lastProjectile = bullet;
		}


        this.nextShootData = {};
        this.isChargedShot = false;

        if(this.onUseKnockBack)
        {
            ApplyEffect(owner, 'KnockBack', this.onUseKnockBack, .15, targetAngle-180);
        }
    }
}class ItemWeaponBoomerang extends ItemWeapon
{
    constructor(enchantAble = true)
    {
        super(enchantAble);

        this.Throws = 0;
        this.refillCharge = false;

        this.BulletType = 'BulletBoomerang';
    }

    GetMaxThrows()
    {
        //scales with bullet count
        return this.CalculateBullets(1);
    }

    GetAvailableThrows()
    {
        var max = this.GetMaxThrows();
        return max - this.Throws;
    }

    GetAdditionalBulletStats()
    {
        var s = super.GetAdditionalBulletStats();
        s.Item = this;

        return s;
    }

    Shoot(owner)
    {
        if(this.GetAvailableThrows() <= 0)
        {
            this.refillCharge = true;
            return;
        }

        super.Shoot(owner);
        this.Throws++;
    }

    UpdateAttackCharge(owner = this.Owner)
    {
        super.UpdateAttackCharge(owner);

        if(this.refillCharge)
        {
            this.attackCharge = this.requiredCharge;
            this.refillCharge = false;

            owner.attackGauge = this.attackCharge / this.requiredCharge;
        }
    }
}class ItemWeaponLaser extends ItemWeapon
{
    constructor(enchantAble = true)
    {
        super(enchantAble);

        this.BulletType = 'BulletLaserBeam';

        this.Duration = 120;
        this.Cooltime = 60;
        this.hurtDelay = 5;
        this.rotationSpeed = 180;
    }

    GetDuration()
    {
        return ItemBonus.GetBonusValue(STAT.DURATION, this.primary) ?? this.Duration;
    }

    GetCooltime()
    {
        var cooltime = ItemBonus.GetBonusValue(STAT.COOLTIME, this.primary) ?? this.Cooltime;
        var duration = this.GetDuration();

        return cooltime + duration;
    }

    UpdateAttackCharge(owner = this.Owner)
    {
        this.attackCharge++;
        var cooltime = this.GetCooltime();

        if(owner.isAttacking)
        {
            if(this.attackCharge >= cooltime)
            {
                this.UpdateSpecialCharge(owner);
                this.Shoot();
                this.attackCharge = 0;
            }
        }
        
        if(this.attackCharge > cooltime) this.attackCharge = cooltime;

        owner.attackGauge = this.attackCharge / cooltime;
    }

    GetAdditionalBulletStats()
    {
        var s =
        {
            hurtDelay: this.hurtDelay,
            rotationSpeed: this.rotationSpeed,
            laserDuration: this.GetDuration()
        };
        return s;
    }
}class Collision
{
	static Check(entity)
	{
		entity.lockMove.Right = false;
		entity.lockMove.Left = false;
		entity.lockMove.Top = false;
		entity.lockMove.Down = false;

		if(entity.x <= 0)
		{
			entity.x = 0;
			entity.lockMove.Left = true;
			if(entity.Bounce)
			{
				entity.dirX *= -1;
			}
		}
		
		if(entity.y <= 0)
		{
			entity.y = 0;
			entity.lockMove.Top = true;
			if(entity.Bounce)
			{
				entity.dirY *= -1;
			}
		}
		
		if(entity.x + entity.Width >= World.Width)
		{
			entity.x = World.Width - entity.Width;
			entity.lockMove.Right = true;
			if(entity.Bounce)
			{
				entity.dirX *= -1;
			}
		}

		if(entity.y + entity.Height >= World.Height)
		{
			entity.y = World.Height - entity.Height;
			entity.lockMove.Down = true;
			if(entity.Bounce)
			{
				entity.dirY *= -1;
			}
		}
	}

	

	static AreColliding(entity1, entity2)
	{
		if(!entity1 || !entity2) return false;

		var hitBoxes1 = ([entity1.HitBox]).concat(entity1.advancedHitBox ?? []);
		var hitBoxes2 = ([entity2.HitBox]).concat(entity2.advancedHitBox ?? []);

		for(var i in hitBoxes1)
		{
			for(var j in hitBoxes2)
			{
				if(this.CheckHitboxCollisions(hitBoxes1[i], hitBoxes2[j], entity1, entity2)) return true;
			}
		}
		
		return false;
	}

	static CheckHitboxCollisions(hitbox1, hitbox2, entity1, entity2)
	{
		if(hitbox1.Type == HITBOX.RECTANGLE && hitbox2.Type == HITBOX.RECTANGLE)
		{
			var x1 = hitbox1.x;
			var y1 = hitbox1.y;
			var sx1 = hitbox1.endX;
			var sy1 = hitbox1.endY;

			var x2 = hitbox2.x;
			var y2 = hitbox2.y;
			var sx2 = hitbox2.endX;
			var sy2 = hitbox2.endY;
			

			if(
				(
					(x1 >= x2) && (x1 <= sx2) ||
					(x2 >= x1) && (x2 <= sx1)
				) &&
				(
					(y1 >= y2) && (y1 <= sy2) ||
					(y2 >= y1) && (y2 <= sy1)
				)
			)
			{
				return true;
			}
			return false;
		}
		else if(hitbox1.Type == HITBOX.ROUND && hitbox2.Type == HITBOX.ROUND)
		{
			var x1 = hitbox1.x;
			var y1 = hitbox1.y;
			var r1 = hitbox1.Radius;

			var x2 = hitbox2.x;
			var y2 = hitbox2.y;
			var r2 = hitbox2.Radius;

			var distance = MathHelper.GetDistance([x1, y1], [x2, y2]);
			if(distance <= r1 + r2)
			{
				return true;
			}
			return false;
		}
		else if(hitbox1.Type == HITBOX.RECTANGLE && hitbox2.Type == HITBOX.ROUND)
		{
			var width = hitbox1.Width;
			var height = hitbox1.Height;
			var x1 = hitbox1.x + (width / 2);
			var y1 = hitbox1.y + (height / 2);
			

			var x2 = hitbox2.x;
			var y2 = hitbox2.y;
			var r2 = hitbox2.Radius;

			var distX = Math.abs(x2 - x1);
			var distY = Math.abs(y2 - y1);
			if((distX <= r2 + width / 2) && (distY <= r2 + height / 2))
			{
				//distance from corner
				var d = Math.sqrt((width * width) + (height * height));
				var distD = MathHelper.GetDistance([x1, y1], [x2, y2]);
				if(distD <= r2 + (d / 2))
				{
					return true;
				}
			}
			return false;
		}
		else
		{
			return this.AreColliding(entity2, entity1);
		}
	}
}class Camera
{
	static Initialize()
	{
		this.xView = 0;
		this.yView = 0;
		
		this.Locked = false;
		
		this.shake = false;
		this.shakeStrength = 0;
		this.ShakeTime = 0;
		this.ShakeDirection = 1;
		this.ShakeDuration = 10;
		this.Scale = 1.0;

		this.smoothTime = 0;
		this.smoothTick = 0;
		this.smoothPos = {};

		this.lastX = 0;
		this.lastY = 0;
		this.lastPosX = 0;
		this.lastPosY = 0;
	}

	static Smooth(x, y, time)
	{
		if(this.smoothTime) return;
		
		this.smoothLock = this.Locked;
		this.Locked = true;

		this.smoothTime = time * Main.FPS;
		this.smoothTick = Main.ageInTicks;
		this.smoothPos = {from: {x: this.lastX, y: this.lastY}, to: {x, y}};
	}
	
	static Update(x, y, posX, posY, rePosition)
	{
		if (!this.Locked)
		{
			this.UpdateView(x, y, posX, posY, rePosition);
		}
		else if(this.smoothTime)
		{
			var p = (Main.ageInTicks - this.smoothTick) / this.smoothTime;

			if(p >= 1)
			{
				this.smoothTime = 0;
				this.Locked = this.smoothLock;
				this.UpdateView(x, y, posX, posY, rePosition);
				return;
			}
			else
			{
				var playerDiffX = this.smoothPos.to.x - x;
				var playerDiffY = this.smoothPos.to.y - y;

				var diffX = this.smoothPos.from.x - this.smoothPos.to.x;
				var diffY = this.smoothPos.from.y - this.smoothPos.to.y;

				x = this.smoothPos.from.x - (diffX * p) - playerDiffX;
				y = this.smoothPos.from.y - (diffY * p) - playerDiffY;
				this.UpdateView(x, y, posX, posY, rePosition);
			}
		}
	}

	static UpdateView(x, y, posX, posY, rePosition)
	{
		this.lastX = x;
		this.lastY = y;

		this.lastPosX = posX;
		this.lastPosY = posY;

		this.xView = x - posX;
		this.yView = y - posY;

		var width = World.Width;
		var height = World.Height;

		if(!rePosition)
		{
			if (this.xView >= width - canvas.width)
			{
				this.xView = width - canvas.width;
			}

			if (this.xView < 0)
			{
				this.xView = 0;
			}


			if (this.yView > height - canvas.height)
			{
				this.yView = height - canvas.height;
			}

			if (this.yView < 0)
			{
				this.yView = 0;
			}
		}

		if (this.shake)
		{
			if (this.ShakeTime <= this.ShakeDuration)
			{
				this.ShakeTime++;

				if (this.ShakeTime % 4 == 0)
				{
					//zmiana kierunku drzen
					var chance = Math.random() * 100;

					if (chance > 50)
					{
						this.ShakeDirection *= -1;
					}
				}

				var power = Math.random() * 3;

				this.xView += power * this.ShakeStrength * this.ShakeDirection;
				this.yView += power * this.ShakeStrength * this.ShakeDirection;
			}
			else
			{
				this.shake = false;
			}
		}
	}
	
	static Shake(strength, priority = false, time = 10)
	{
		if (!this.shake || priority)
		{
			this.ShakeTime = 0;
			this.ShakeDuration = time;
			this.ShakeStrength = strength;
			this.shake = true;
		}
	}
}class DamageIndicator
{
	static Initialize()
	{
		this.ToRender = [];
		this.liveTime = Main.FPS * 0.5;
		this.style = Style.GetStyleByName("ItemInfoDisplay");

		this.fontSize = 20;
		this.fontSizeCrit = 60;

		this.style.fontSize = this.fontSize;

		this.fX = function(x, p, q, s = 1)
		{
			return 0.25 * s * ((x - p) * (x - p)) + q;
		};

		this.Colors = 
		{
			"DEALT": "white",
			"RECEIVED": "red",
			"HEAL": "lightgreen",
			"AMMO": 'yellow',

			"UPGRADE_SUCCESS": "#00ff00",
			"UPGRADE_FAILED": "orange",
			"UPGRADE_ERROR": "#ff0000"
		};

		this.Strokes = 
		{
			"DEALT": "lightgray",
			"RECEIVED": "red",
			"HEAL": "lightgreen",
			"AMMO": 'yellow',

			"UPGRADE_SUCCESS": "black",
			"UPGRADE_FAILED": "black",
			"UPGRADE_ERROR": "black"
		};
	}

	static AddObject(x, y, value, type, direction = 1, isCritical = false)
	{
		this.ToRender.push(
			{
				x: x,
				y: y,
				p: x + (direction * 10),
				q: y - 10,
				direction: direction ?? 1,
				value: value,
				type: type,
				isCritical: isCritical,
				ageInTicks: 0
			}
		);
	}

	static Update()
	{
		for(var i = 0; i < this.ToRender.length; i++)
		{
			var obj = this.ToRender[i];
			var strength = 1;
			var time = this.liveTime;
			if(obj.isCritical)
			{
				// time /= 2;
				strength = 5;
			}
			obj.x += obj.direction * strength;
			obj.y = this.fX(obj.x, obj.p, obj.q, 1 / strength / 2);


			obj.ageInTicks++;
			obj.alpha = 1 - (obj.ageInTicks / time);

			if(obj.ageInTicks > time)
			{
				this.ToRender.splice(i, 1);
			}
		}
	}

	static Render()
	{
		for(var i = 0; i < this.ToRender.length; i++)
		{
			var obj = this.ToRender[i];
			var color = this.Colors[obj.type];
			var stroke = this.Strokes[obj.type];
			var value = obj.value;

			if(obj.isCritical) 
			{
				this.style.fontSize = this.fontSizeCrit;
				value += ' Crit!';
			}
			else this.style.fontSize = this.fontSize;

			Style.FillText(ctx, this, value+'', obj.x - Camera.xView, obj.y - Camera.yView, color, stroke, obj.alpha);
		}
	}
}class itemInfoDisplay
{
    constructor()
    {
        this.x = 0;
        this.y = 0;

        this.startX = null;
        this.startY = null;

        this.width = 0;
        this.height = 0;
        this.className = "ItemInfoDisplay";
        this.style = null;
        this.item = null;
        this.useMousePosition = true;
        
        this.interLineStep = 25;
        this.interLine = this.interLineStep;

        this.heighestWidth = 0;
        this.heighestHeight = 0;

        this.DisplayLines = [];
        this.DisplayImages = [];
    }
   
    
    Update()
    {
        if(this.useMousePosition)
        {
            this.startX = Mouse.x;
            this.startY = Mouse.y;
        }

        this.x = this.startX;
        this.y = this.startY;
        
        this.style = Style.GetStyleByName(this.className);
    }

    static getGradeInfo(item)
    {
        var info = {name: '', color: null};
        info.color = ItemHelper.GetGradeInfo(item.Grade).color ?? '';

        if (item.Grade == GRADE.LEGENDARY) info.name = 'Legendary ';
        if (item.Grade == GRADE.MYSTICAL) info.name = 'Mystical ';
        if (item.Grade == GRADE.RARE) info.name = 'Rare ';

        if(item.Grade == GRADE.TRANSCENDENCE)
        {
            var speed = 4;
            var mod = 360 / speed;

            var start = (Main.ageInTicks%mod) * speed;
            var end = ((Main.ageInTicks+60)%mod) * speed;

            var grd = new DisplayLineGradient(null, 0, null, 0);
                grd.addColorStop(0, 'hsl(' + start + ', 100%, 75%)');
                grd.addColorStop(1, 'hsl(' + end + ', 100%, 75%)');

            info.color = grd;
            info.name = 'Transcendence ';
        }

        return info;
    }

    setInterline(times = 1)
    {
        this.interLine += times * this.interLineStep;
    }

    setMaxWidth(text, adjust = 0)
    {
        var width = Style.GetTextSize(text, this.style).width + adjust;

        if (width > this.heighestWidth) this.heighestWidth = width;
        return width;
    }

    setNewLine(text, textColor)
    {
        var width = this.setMaxWidth(text);
        
        this.DisplayLines.push(new ItemInfoDisplayLine(width, this.height, this.interLine, text, textColor));
        this.setInterline();
    }

    setPosition()
    {
        this.heighestWidth += 50;     //right side margin

        if (this.startX + this.heighestWidth > canvas.width)
        {
            this.x += canvas.width - (this.startX + this.heighestWidth);
        }

        if (this.startY + this.interLine + 10 > canvas.height)
        {
            this.y += canvas.height - (this.startY + this.interLine) - 10;
        }
    }

    GetPrimaryBonusesDisplayValues(bonus, value)
    {
        var text = bonus.name + ": +" + value;

        switch(bonus.id)
        {
            case STAT.ATTACK_DAMAGE:
                var dmg = World.Player.GetDamageValues(value);
                return bonus.name + ": " + dmg.min + " - " + dmg.max;

            case STAT.ATTACK_SPEED:
                value = (value == parseInt(value)) ? value + ".0" : value;
                return bonus.name + ": " + value;

            case STAT.COOLTIME:
                return bonus.name + ': ' + MathHelper.ticksToSeconds(value) + 's';

            case STAT.DURATION:
                return bonus.name + ': ' + MathHelper.ticksToSeconds(value) + 's';

            case STAT.ATTACK_RANGE:
                return bonus.name + ": " + value;
        }

        return text;
    }

    
    
    Render()
    { 
        var item = this.item;
        if(!item) return;

        this.heighestWidth = 0;

        this.interLine = this.interLineStep;

        var grade = item.Grade;
        var text;
        var width;

        this.DisplayLines = [];
        this.DisplayImages = [];

        var showNextLevelInfo = false;
        var arrow = "  ->  ";
        var colorGreen = "#00ff00";
        var colorRed = '#FF5F5F';
        var bonusValue = 0;


        var HandEnchant = null;
        var HandEnchantIndex = null;

        if(World.Player.hand)
        {
            if(World.Player.hand.type == TYPE.UPGRADE)
            {
                showNextLevelInfo = true;
            }
            else if(World.Player.hand.type == TYPE.ENCHANT)
            {
                HandEnchantIndex = ItemHelper.CanBeEnchanted(item, World.Player.hand);
                if(HandEnchantIndex != null)
                {
                    HandEnchant = World.Player.hand;
                }
            }
        }




        if(item.upgradeAble)
        {
            var gradeInfo = itemInfoDisplay.getGradeInfo(item);

            grade = gradeInfo.name;

            var nextLevel = null;
            if(item.upgradeLevel < 9 && showNextLevelInfo) nextLevel =  "+" + (item.upgradeLevel + 1);

            text = grade + itemInfoDisplay.GetItemName(item);

            
            var color = Style.GetCustomTextColor(item.name);
            if(color) this.style.color = color;
            if(gradeInfo.color) this.style.color = gradeInfo.color;

            if(nextLevel)
            {
                this.setNewLine([text, arrow, nextLevel], [this.style.color, "white", colorGreen]);
            }
            else
            {
                this.setNewLine(text, this.style.color);
            }
        }
        else
        {
            var gradeInfo = itemInfoDisplay.getGradeInfo(item);

            grade = gradeInfo.name;
            text = grade + itemInfoDisplay.GetItemName(item);

            var color = Style.GetCustomTextColor(item.name);
            if(color) this.style.color = color;
            if(gradeInfo.color) this.style.color = gradeInfo.color;

            this.setNewLine(text, this.style.color);
        }

        if(item.primary != null)
        {
            for (var i = 0; i < item.primary.length; i++)
            {
                if (item.primary[i] != null)
                {
                    var id = item.primary[i].id;
                    var name = item.primary[i].name;
                    var level = item.upgradeLevel;
                    var value = ItemBonus.GetPrimaryBonusValue(id, item);

                    var nextLevelValue = (showNextLevelInfo) ? ItemBonus.GetPrimaryBonusValue(id, item, level + 1) : 0;

                    if (value != 0)
                    {
                        if (value < 0)
                        {
                            this.style.color = colorRed;
                            
                            text = name + ": " + value;
                        }
                        else
                        {
                            if(!item.primary[i].isPercent) text = this.GetPrimaryBonusesDisplayValues(item.primary[i], value);
                            this.style.color = "white"; 
                        }

                        if(item.primary[i].isPercent) text += "%";


                        if(nextLevelValue)
                        {
                            var nextLevelColor = colorGreen;
                            if(nextLevelValue != value)
                            {
                                if (nextLevelValue < 0)
                                {
                                    nextLevelColor = bonusNegative;
                                }
                                else
                                {
                                    if (nextLevelValue < value)
                                    {
                                        nextLevelColor = bonusNegative;
                                    }
                                    
                                    if(item.primary[i].id == STAT.ATTACK_DAMAGE && !item.primary[i].isPercent)
                                    {
                                        var dmg = World.Player.GetDamageValues(nextLevelValue);
                                        nextLevelValue = dmg.min + " - " + dmg.max;
                                    }
                                    else
                                    {
                                        nextLevelValue =  "+" + nextLevelValue;
                                    }   
                                }

                                if (item.primary[i].isPercent) nextLevelValue += "%";

                                this.setNewLine([text, arrow, nextLevelValue], [this.style.color, "white", nextLevelColor]);
                            }
                            else
                            {
                                this.setNewLine(text, this.style.color);
                            }
                        }
                        else
                        {
                            this.setNewLine(text, this.style.color);
                        }
                    }

                }
                else break;
            }
        }

        if(item.enchantAble)
        {
            if(item.Grade != GRADE.NORMAL)
            {
                var info = ItemHelper.GetGradeInfo(item.Grade);
                if(info != null) bonusValue = info.bonus;
            }

            if(item.enchantSlots > 0)
            {
                var isSomething = function(element)
                {
                    return(element == null);
                }


                if(!item.Enchants.every(isSomething) || HandEnchant)
                {
                    for(var i = 0; i < item.enchantSlots; i++)
                    {
                        var enchant = item.Enchants[i];
                        var size = (2 * this.interLineStep) - 4;
                        var isHandEnchant = false;

                        if(HandEnchant && HandEnchantIndex == i)
                        {
                            enchant = HandEnchant;
                            isHandEnchant = true;
                        }

                        if(item.isEquiped && isHandEnchant) continue;

                        if(enchant && !(enchant instanceof EnchantLock))
                        {
                            var gradeInfo = itemInfoDisplay.getGradeInfo(enchant);

                            grade = gradeInfo.name;


                            text = "[" + grade + itemInfoDisplay.GetItemName(enchant) + "]";
                            var bonus = "No effect";

                            var color = Style.GetCustomTextColor(enchant.name);
                            if(gradeInfo.color) color = gradeInfo.color;

                            var bonusColor = "lightgray";
                            var additionalValue = " ";

                            if(enchant.bonus)
                            {
                                var name = enchant.bonus.name;
                                var value = enchant.bonus.value;
                                var isPercent = (enchant.bonus.isPercent) ? "%" : "";
                                if(bonusValue)
                                {
                                    additionalValue = "  (+" + Math.ceil(value * bonusValue / 100) + ")";
                                } 

                                bonus = name + " +" + value + isPercent;
                                bonusColor = "white";
                            }


                            this.setMaxWidth(text, size + 5);
                            this.setMaxWidth(bonus, size + 5);
            
                            if(isHandEnchant)
                            {
                                bonusColor = colorGreen;
                                color = colorGreen;
                            }

                            this.DisplayLines.push(new ItemInfoDisplayLine(width, this.height, this.interLine, text, color, size + 5));
                            this.DisplayLines.push(new ItemInfoDisplayLine(width, this.height, this.interLine, [bonus, additionalValue], [bonusColor, itemInfoDisplay.getGradeInfo(item).color], size + 5, this.interLineStep));
                            this.DisplayImages.push(new ItemInfoDisplayImage("inventory_slot", 5, this.interLine + 3 + (size / 4), size, size, 0.8));

                            var imageLine = new ItemInfoDisplayImage(enchant, 5, this.interLine + 3 + (size / 4), size, size, 0.8);
                                imageLine.isFromHand = isHandEnchant;
                            this.DisplayImages.push(imageLine);
                        }
                        else
                        {
                            text = "[empty]";
                            var imageLine = null;

                            this.setMaxWidth(text, size + 5);

                            if(enchant)
                            {
                                text = "[Broken slot]";
                                imageLine = new ItemInfoDisplayImage(enchant, 5, this.interLine + 3 + (size / 4), size, size, 0.8);
                            }

                            this.DisplayLines.push(new ItemInfoDisplayLine(width, this.height, this.interLine, text, "lightgray", size + 5, this.interLineStep / 2));
                            this.DisplayImages.push(new ItemInfoDisplayImage("inventory_slot", 5, this.interLine + 3 + (size / 4), size, size, 0.8));
                            if(imageLine) this.DisplayImages.push(imageLine);
                        }

                        this.setInterline(2);
                    }
                }
            }

        }


        if(item.type == TYPE.ENCHANT)
        {
            if(item.bonus)
            {
                var name = item.bonus.name;
                var value = item.bonus.value;
                var isPercent = (item.bonus.isPercent) ? "%" : "";

                text = name + " +" + value + isPercent;

                this.setNewLine(text, 'white');
            }
        }


        if(bonusValue)
        {
            text =  "Enchants` power +" + bonusValue + "%";

            this.setNewLine(text, itemInfoDisplay.getGradeInfo(item).color);
        }

        if(item.ammoCost)
        {
            text =  "Consumes " + item.ammoCost + " oxygen";

            this.setInterline();
            this.setNewLine(text, colorRed);
        }


        if (item.Lore != null)
        {
            this.setInterline();

            for (var i = 0; i < item.Lore.length; i++)
            {
                if (item.Lore[i] != null)
                {
                    this.style.color = "violet";
                    text = item.Lore[i];

                    var color = Style.GetCustomTextColor(text);
                    if(color)
                    {
                        this.style.color = color;
                        text = text.replace("<"+color+">", "");
                    }

                    this.setNewLine(text, this.style.color);
                }
            }
        }

        if(HandEnchantIndex != null && !item.isEquiped)
        {
            text = "Click to enchant";

            this.setInterline();
            this.setNewLine(text, colorGreen);
        }

        if(showNextLevelInfo && item.upgradeAble && item.upgradeLevel < 9)
        {
            this.setInterline();

            var color = "yellow";
            var text2 = "Not enough oxygen";
            var color2 = "#ff0000";

            if(item.CanBeUpgraded(World.Player))
            {
                text2 = "Click to upgrade";
                color2 = colorGreen;
            }

            text = "Upgrade Cost: " + ItemHelper.GetUpgradeCost(item);
            this.setNewLine(text, color);

            text = "Upgrade Chance: " + ItemHelper.GetUpgradeChance(item, World.Player, World.Player.hand) + "%";
            this.setNewLine(text, 'white');
            this.setNewLine(text2, color2);
        }

        // if (item.equipAble)
        // {
        //     interLine += interLineStep;
        //     this.style.color = "lightgray";
        //     text = "[Slot: " + Lang.Translate(item.slot) + "]";

        //     width = Style.GetTextSize(text, this.style).width;

        //     if (width > heighestWidth)
        //     {
        //         heighestWidth = width;
        //     }

        //     DisplayLines.push(new ItemInfoDisplayLine(width, this.height, interLine, text, this.style.color));

        //     interLine += interLineStep;
        // }


        if(InGame.GUI.Inventory.isShopOpen || Settings.General.AlwaysShowItemPrice)
        {
            var priceInfo = ItemHelper.GetItemPrice(item);
            var price = priceInfo.sell;

            if(item.isInShop) price = (item.inShopPrice) ? item.inShopPrice : priceInfo.buy;
        
            this.style.color = (price > 1000000) ? "yellow" : 'white';

            text = "Price: " + Style.DottedText(price);
            this.setInterline();
            this.setNewLine(text, this.style.color);
        }

        this.setPosition();



        for(var i = 0; i < this.DisplayImages.length; i++)
        {
            this.DisplayImages[i].Render(this.x, this.y);
        }

        for (var i = 0; i < this.DisplayLines.length; i++)
        {
            this.DisplayLines[i].Render(this.x, this.y, this.style);
        }

        this.item = null;
    }

    static GetItemName(item, showNextLevelInfo)
    {
        var name;

        if (item.upgradeAble == true)
        {
            var level = item.upgradeLevel;

            name = item.name + " +" + level;
            var color = Style.GetCustomTextColor(item.name);
            if(color)
            {
                name = name.replace("<"+color+">", "");
            }
        }
        else
        {
            name = item.name;
            var color = Style.GetCustomTextColor(item.name);
            if(color)
            {
                name = name.replace("<"+color+">", "");
            }
        }

        return name;
    }
}

class ItemInfoDisplayImage
{
    constructor(src, tX = 0, tY = 0, width = 0, height = 0, alpha = 1)
    {
        this.src = src;
        this.tX = tX;
        this.tY = tY;

        this.width = width;
        this.height = height;
        this.alpha = alpha;
    }

    Render(x, y)
    {
        if(this.src instanceof Item)
        {
            var item = this.src;
            var texture = TextureManager.Get(item.Texture);

            var width = this.width || texture.width;
            var height = this.height || texture.height;

            ctx.save();
            ctx.globalAlpha = this.alpha;
            ctx.drawImage(texture, x + this.tX, y + this.tY, width, height);
            ctx.restore();

            item.DrawShine(x + this.tX + 12, y + this.tY + 12, width / 45, this.isFromHand);
        }
        else
        {
            var texture = TextureManager.Get(this.src);

            var width = this.width || texture.width;
            var height = this.height || texture.height;

            ctx.save();
            ctx.globalAlpha = this.alpha;
            ctx.drawImage(texture, x + this.tX, y + this.tY, width, height);
            ctx.restore();
        }
        
    }
}

class ItemInfoDisplayLine
{
    constructor(width, height, interline, text, color, tX = 0, tY = 0)
    {
        this.Width = width;
        this.Height = height;
        this.Interline = interline;

        this.Text = text;
        this.Color = color;

        this.tX = tX;
        this.tY = tY;
    }

    Render(x, y, style)
    {
        if(isArray(this.Text))
        {
            for(var i = 0; i < this.Text.length; i++)
            {
                var temp = {};
                temp.style = style;

                if(isArray(this.Color))
                {
                    if(this.Color[i])
                    {
                        temp.style.color = this.Color[i];
                    }
                    else
                    {
                        temp.style.color = this.Color[this.Color.length - 1];
                    }
                }
                else
                {
                    temp.style.color = this.Color;
                }
                
                temp.text = this.Text[i];
                temp.x = x + this.tX;
                temp.y = y + this.tY + this.Interline;

                Style.FillText(ctx, temp);

                x += Style.GetTextSize(this.Text[i], style).width;
            }
        }
        else
        {
            var temp = {};
            temp.style = style;
            temp.style.color = this.Color;
            temp.text = this.Text;
            temp.x = x + this.tX;
            temp.y = y + this.tY + this.Interline;

            var size = Style.GetTextSize(this.Text, style);

            if(temp.style.color instanceof DisplayLineGradient)
            {
                temp.style.color = temp.style.color.getContextGradient(ctx, temp.x, temp.y, temp.x + size.width, temp.y + size.height);
            }

            Style.FillText(ctx, temp);
        }
    }
}


class DisplayLineGradient
{
    constructor(x, y, endX, endY)
    {
        this.x = x;
        this.y = y;
        this.endX = endX;
        this.endY = endY;

        this.colorStops = {};
    }

    addColorStop(id, color)
    {
        this.colorStops[id] = color;
    }

    getContextGradient(ctx, x, y, endX, endY)
    {
        x = (this.x != null) ? this.x : x;
        y = (this.y != null) ? this.y : y;
        endX = (this.endX != null) ? this.endX : endX;
        endY = (this.endY != null) ? this.endY : endY;

        var grd = ctx.createLinearGradient(x, y, endX, endY);
            
            for(var id in this.colorStops)
            {
                grd.addColorStop(id, this.colorStops[id]);
            }

        return grd;
    }
}class Player
{
	constructor()
	{
		this.x = -1;
		this.y = -1;
		this.posX = 0;
		this.posY = 0;
		
		this.Width = 64;
		this.Height = 64;
		this.ageInTicks = 0;
		
		this.isWriting = false;
		this.isMoving = false;
		this.isAttacking = false;
		this.movedInRoom = false;

		
		this.canDodge = false;

		this.Difficulty = 0;

		this.Textures =
		{
			["Body"]: new ItemModel("bubble_no_shine"),
			[SLOT.CANNON]: new ItemModel("cannonBase", 34, 34, 2, 0, 55, itemCannonUpdate),
			[SLOT.DRIVE]: new ItemModel("driveBase", 81, 31, 2, 0, -42),
			["Core"]: new ItemModel("bubble", 80, 80, 2)
		};

		this.Colors =
		{
			["Body"]: null,
			[SLOT.CANNON]: null,
			[SLOT.DRIVE]: null,
			["Core"]: null
		};

		this.Cooltimes = {};

		this.specialAttackGauge = 0;

		this.Rotation = 0;
		this.Scale = 1;
		this.attackCharge = 0;
		this.bulletSery = 0;
		
		this.isDashing = false;
		// this.dashDuration = (Main.FPS / 60) * 10;
		// this.dashMultiplier = 5;
		// this.dashCooldown = 2;
		this.dashAngle = 0;
		this.dashStart = -99999;		//allows to dash immediately after starting game
		this.dashShadowsData = [];


		this.totalDamageReceived = 0;

		
		//podstawowe statystyki
		this.baseStats =
		{
			[STAT.ATTACK_SPEED]: 0,
			[STAT.BULLET_SPEED]: 1200,
			[STAT.BULLET_SERIES]: 1,
			[STAT.MOVEMENT_SPEED]: 600,
			[STAT.MAX_HP]: 100,
			[STAT.ATTACK_DAMAGE]: 0,
			[STAT.BULLETS_COUNT]: 1,
			[STAT.ATTACK_RANGE]: 0,
			// [STAT.ACCELERATION]: .25,
			[STAT.ACCELERATION]: 0.15,
			[STAT.BRAKE]: 1,
			[STAT.LIGHT_RANGE]: 200,
			[STAT.PIERCE]: 0,
			[STAT.CHARGE]: 0,
			[STAT.DEFENSE]: 0,

			[STAT.CR]: 0,
			[STAT.CD]: 100,

			[STAT.HARDNESS]: 0,
			[STAT.POWER]: 0,
			[STAT.DEXTERITY]: 0,
			[STAT.AMMO_COST]: 0,

			[STAT.BLOCK_CHANCE]: 0,

			[STAT.DAMAGE_ELECTRO]: 0,
			[STAT.DAMAGE_FIRE]: 0,
			[STAT.DAMAGE_POISON]: 0,
			[STAT.DAMAGE_ICE]: 0,
			[STAT.ELEMENTAL_MASTERY]: 0,

			[STAT.DASH_DURATION]: 0,
			[STAT.DASH_COOLTIME]: 0,
			[STAT.DASH_DISTANCE]: 0
		};



		this.SPstats =
		{
			//nazwa : [uzyte punkty, statystyka, wartosc / 1SP, %]
			[STAT.HARDNESS]: [0, STAT.DEFENSE, 1, false],
			[STAT.POWER]: [0, STAT.ATTACK_DAMAGE, 2, true],
			[STAT.DEXTERITY]: [0, STAT.ATTACK_SPEED, 2, true],

			[STAT.CHARGE]: [0, STAT.CHARGE, 1, false],
			[STAT.AMMO_COST]: [0, STAT.AMMO_COST, 1, false],
		};



		//aktualne statystyki
		this.stats =
		{
			[STAT.ATTACK_SPEED]: 0,
			[STAT.BULLET_SPEED]: 900,
			[STAT.BULLET_SERIES]: 1,
			[STAT.MOVEMENT_SPEED]: 300,
			[STAT.MAX_HP]: 10,
			[STAT.ATTACK_DAMAGE]: 0,
			[STAT.BULLETS_COUNT]: 1,
			[STAT.ACCELERATION]: 0,
			Level: 1,
			HP: 0,
			availableSlots: 63,
			availableSP: 0,
			usedSP: 0,
			[STAT.LIGHT_RANGE]: 0,
			[STAT.LIGHT_STRENGTH]: 0,
			[STAT.PIERCE]: 0,
			[STAT.CHARGE]: 0,
			[STAT.DEFENSE]: 0,

			[STAT.CR]: 0,
			[STAT.CD]: 100
		};
		
		this.additionalStats =
		{
			[STAT.ATTACK_SPEED]: 0,
			[STAT.BULLET_SPEED]: 0,
			[STAT.BULLET_SERIES]: 0,
			[STAT.MOVEMENT_SPEED]: 0,
			[STAT.MAX_HP]: 0,
			[STAT.ATTACK_DAMAGE]: 0,
			[STAT.BULLETS_COUNT]: 0
		};

		this.lockMove = 
		{
			Top: false,
			Down: false,
			Right: false,
			Left: false
		};

		this.lockKey =
		{
			"Bounce" : false
		};
		
		this.velocityX = 0;
		this.velocityY = 0;
		

		this.Bounce = true;
		this.isBouncing = false;
		this.oxygen = 0;
		this.coins = 0;
		
		this.isHurtAble = true;
		this.Slow = 0;
		this.reward = 0;
		this.hurted = false;
		this.shield = 0;
		this.timeSinceHurt = 0;
		this.allowAttack = true;
		this.timeInRoom = 120;
		this.immunityDuration = 1;
		this.immunityDurationMultiplier = 1;
		this.interactionWith = false;
		this.canInteractWith = [];


		this.HitBox = new HitBox();
		
		this.bulletStats = this.GetDefaultBulletStats();
		
		

		InGame.GUI.Inventory = new Inventory(this);
		InGame.GUI.PlayerStats = new PlayerStats(this);

		this.inventory = new Array(140);		//140 slotow inventory + sloty typu bron/zbroja
		this.equips = Player.GetEquipSlots();

		//starting weapon
		var starter = new CannonBase();
			starter.Enchant(new EnchantLock());
			starter.Grade = GRADE.NORMAL;
			starter.enchantAble = false;
		this.equips[SLOT.CANNON] = starter;
		this.equips[SLOT.CORE] = new Core1();
		this.equips[SLOT.CORE].Grade = GRADE.NORMAL;

		this.Effects = new Effects();
		
		this.requiredOxygen = 100;
		this.allowControl = true;
		this.allowMove = true;
		this.moveToPoint = null;
		this.lastPos = {x: 0, y: 0};

		this.recallTicks = 0;
		this.canInterruptRecall = true;
		this.isRecalling = false;
		this.recallTime = 0;
		this.recallRoom = null;
		this.allowSuperFastTravel = false;

		this.oxygenGainedInRoom = 0;

		this.alphaTransition = new Transition(0.2, 1, 0.15, true, 0.02, 0.02);
		this.scaleTransition = new Transition(1, 0.95, 0.25, true, 0.02, 0.02);

		this.locationInfo = Player.getDefaultLocationInfo();


		this.RunStats = this.getDefaultRunStats();

		this.UpdateStats();
		this.laserRotation = null;

		this.startLocation = 'Tutorial';
		this.stats.HP = this.stats.MAXHP;
		this.isAlive = true;

		this.shotPoints = 
		[
			{distance: 20, angle: 0}
		];

		this.Appearance =
		{
			Skin: 'SkinBase',
			Particle: 'bubble',
			Weapon: null,

			Scale: null,
			Rotation: null,
			Transparency: null,

			AvailableSkins: 
			{
				[SKIN.BASE]: true,
				[SKIN.BASEF]: true
			}
		};

		this.Skin;
		this.NPCData = 
		{
			MERCHANT: Player.CreateNPCData({met: true}),
			SENSEI: Player.CreateNPCData({met: true}),
		};

		this.Immunity = [];
		this.Weakness = [];
		this.Resistance = [];
		this.knockBackResistance = 0;
		this.canBeKnockedBack = true;

		for(var name in ELEMENT)
		{
			this.Immunity[name] = false;
			this.Weakness[name] = false;
			this.Resistance[name] = false;
		}


		this.isStunned = false;
		this.QuestData = {};


		this.invincibleScale = 2;
		this.isInvincible = false;

		this.canFastTravel = false;		//allows to TP to every cleared room
	}

	static CreateNPCData(data = {})
	{
		data.met = data.met ?? false;
		data.interactions = data.interactions ?? 0;
		data.displayName = data.displayName || '';

		return data;
	}

	static InitSkin(skin, variantFor = null)
    {
        if(!this.Skins) this.Skins = {};

        this.Skins[skin.name] = skin;

		var skin_id = skin.name.toUpperCase().replace('SKIN', '');
		SKIN[skin_id] = skin.name;

		if(variantFor) variantFor.InitVariant(skin);
    }

	getSpecialSlots()
	{
		return 5;
	}

	static GetEquipSlots(inOrder = false)
	{
		var equips = 
		{
			[SLOT.CANNON] : null,
			[SLOT.CORE] : null,
			[SLOT.COVER]: null,
			// [SLOT.DRIVE] : null,
			[SLOT.SPECIAL + "0"]: null,
			[SLOT.SPECIAL + "1"]: null,
			[SLOT.SPECIAL + "2"]: null,
			[SLOT.SPECIAL + "3"]: null,
			[SLOT.SPECIAL + "4"]: null
		};

		var order = 
		[
			SLOT.CANNON,
			SLOT.CORE,
			SLOT.COVER,
			// SLOT.DRIVE,

			SLOT.SPECIAL+"0",
			SLOT.SPECIAL+"1",
			SLOT.SPECIAL+"2",
			SLOT.SPECIAL+"3",
			SLOT.SPECIAL+"4",
		];

		if(inOrder) return order;
		return equips;
	}

	getSpecialCharge()
	{
		return this.stats[STAT.CHARGE];
	}

	Interact()
	{
		if(!this.canInteractWith.length) return false;
		if(this.interactionWith) return false;

		var close;
		var lowest_distance = 999999;
		for(var i = 0; i < this.canInteractWith.length; i++)
		{
			var entity = this.canInteractWith[i];
			var dist = MathHelper.GetDistance(this, entity);
			if(dist < lowest_distance) 
			{
				lowest_distance = dist;
				close = entity;
			}
		}

		this.interactionWith = close;

		return true;
	}

	Load()
	{
		var save = localStorage.getItem(Main.SaveSlot);
		if(save != 'null' && isJSON(save)) this.LoadData(save);

		World.LoadMap(this.startLocation, true);

		UI_Helper.setDifficultyInfo();
	}

	LoadData(save)
	{
		if(!save) return;
		var obj = JSON.parse(save);

		if(obj.Level) this.stats.Level = obj.Level;
		this.requiredOxygen = Player.GetRequiredOxygen(this.stats.Level);

		if(obj.oxygen) this.oxygen = obj.oxygen;
		if(obj.coins) this.coins = obj.coins;
		if(obj.HP) this.stats.HP = obj.HP;
		if(obj.usedSP) this.stats.usedSP = obj.usedSP;
		if(obj.startLocation) this.startLocation = obj.startLocation;
		if(obj.Difficulty) this.Difficulty = obj.Difficulty;
		if(obj.NPCData) this.NPCData = obj.NPCData;
		if(obj.QuestData) this.QuestData = obj.QuestData

		if(obj.SPstats)
		{
			for(var name in obj.SPstats)
			{
				if(!this.SPstats[name]) continue;
				this.SPstats[name][0] = obj.SPstats[name];
			}
		}

		var newItem = function(itemInfo)
		{
			var item = ItemHelper.getInstanceOfItem(itemInfo.type);

			if(!item) return null;


			if(itemInfo.Grade) item.Grade = itemInfo.Grade;
			if(itemInfo.count) item.count = itemInfo.count;
			if(itemInfo.isPerfect) item.isPerfect = itemInfo.isPerfect;
			if(itemInfo.upgradeLevel) item.upgradeLevel = itemInfo.upgradeLevel;
			if(itemInfo.secondary) item.secondary = itemInfo.secondary;


			if(itemInfo.Enchants)
			{
				for(var i = 0; i < itemInfo.Enchants.length; i++)
				{
					item.Enchants[i] = null;
					var enchant = ItemHelper.getInstanceOfItem(itemInfo.Enchants[i]);
					if(!enchant) continue;

					item.Enchants[i] = enchant;
				}
			}

			return item;
		}

		if(obj.inventory)
		{
			for(var i = 0; i < obj.inventory.length; i++)
			{
				var itemInfo = obj.inventory[i];
				this.inventory[i] = null;

				if(!itemInfo) continue;
				if(!itemInfo.type) continue

				this.inventory[i] = newItem(itemInfo);
			}
		}

		if(obj.equips)
		{
			for(var slot in obj.equips)
			{
				var itemInfo = obj.equips[slot];
				this.equips[slot] = null;

				if(!itemInfo) continue;
				if(!itemInfo.type) continue

				this.equips[slot] = newItem(itemInfo);
			}
		}

		
		if(obj.locationInfo)
		{
			for(var name in obj.locationInfo)
			{
				this.locationInfo[name] = obj.locationInfo[name];
			}
		}


		if(obj.Appearance)
		{
			for(var name in obj.Appearance)
			{
				this.Appearance[name] = obj.Appearance[name];
			}
		}

		

		this.UpdateStats();
	}

	Save()
	{
		if(Main.inTestMode || !this.locationInfo.Tutorial?.isCleared) return;
		
		var save = {};

		save.Level = this.stats.Level;
		save.oxygen = this.oxygen;
		save.coins = this.coins;
		save.HP = this.stats.HP;
		save.SPstats = {};
		save.usedSP = this.stats.usedSP;
		save.startLocation = World.Location.constructor.name;
		save.Difficulty = this.Difficulty;
		save.NPCData = this.NPCData;
		save.QuestData = this.QuestData

		for(var name in this.SPstats)
		{
			save.SPstats[name] = this.SPstats[name][0];
		}

		save.inventory = [];
		save.equips = {};




		var _itemInfo = function(item)
		{
			var itemInfo = {};

				itemInfo.type = item.constructor.name;
				itemInfo.Grade = item.Grade;
				itemInfo.count = item.count;
				itemInfo.isPerfect = item.isPerfect;
				itemInfo.upgradeLevel = item.upgradeLevel;
				itemInfo.Enchants = [];
				
				for(var i = 0; i < item.getEnchantSlots?.(); i++)
				{
					itemInfo.Enchants[i] = null;
					if(!item.Enchants[i]) continue;
					itemInfo.Enchants[i] = item.Enchants[i].constructor.name;
				}

			return itemInfo;
		}


		for(var i = 0; i < this.inventory.length; i++)
		{
			var item = this.inventory[i];
			
			if(!item)
			{
				save.inventory[i] = null;
				continue;
			}

			save.inventory[i] = _itemInfo(item);
		}


		for(var slot in this.equips)
		{
			var item = this.equips[slot];

			if(!item)
			{
				save.equips[slot] = null;
				continue;
			}

			save.equips[slot] = _itemInfo(item);
		}

		save.locationInfo = this.locationInfo;
		save.Appearance = this.Appearance;

		localStorage.setItem(Main.SaveSlot, JSON.stringify(save));
	}

	static getDefaultLocationInfo()
	{
		var locationInfo = {};

		for(var locationName in World.LocationList)
		{
			locationInfo[locationName] = 
			{
				isCleared: false,
				rank: null
			};
		}

		locationInfo.Village.isCleared = true;

		return locationInfo;
	}

	getDefaultRunStats()
	{
		var stats = 
		{
			timeInLocation: 0,
			defeatedBosses: 0,
			defeatedEnemies: 0,
			foundSecretRooms: 0,
			totalExperienceEarned: 0,
			totalGoldEarned: 0,
			totalShots: 0,
			missedShots: 0,

			hpLostInRoom: 0,
			roomsInfo: {},

			setRoomInfo: function()
			{
				var id = World.currentRoom.id;
				var performance = 100 - (this.hpLostInRoom / World.Player.stats.MAXHP * 100);
					performance = (performance > 100) ? 0 : performance;
					performance = (performance < 0) ? 0 : performance;

				this.roomsInfo[id] = performance;
				this.hpLostInRoom = 0;
			},

			getRunInfo: function()
			{

				//nie wyswietli statystyk jesli nie pokonano bossa
				if(this.defeatedBosses == 0) return null;


				var ranks = 
				[
					//[performance (%), rankName]
					[0, 'F'],

					[30, 'D'],
					[40, 'D+'],

					[45, 'C-'],
					[50, 'C'],
					[60, 'C+'],

					[65, 'B-'],
					[70, 'B'],
					[80, 'B+'],

					[85, 'A-'],
					[90, 'A'],
					[93, 'A+']
				];


				var runInfo =
				{
					performance: 0,
					accuracy: 0,
					rank: 'F',
					bossChambers: World.Location.RoomInfo.BossChambers,
					secretChambers: World.Location.RoomInfo.SecretChambers
				};

				var totalRooms = 0;
				for(var i = 0; i < World.Location.Rooms.length; i++)
				{
					if(World.Location.Rooms[i] != null) totalRooms++;
				}

				var roomsEntered = 0;
				var performanceSum = 0;
				for(var id in this.roomsInfo)
				{
					performanceSum += this.roomsInfo[id];
					roomsEntered++;
				}

				var performance = performanceSum / roomsEntered;
				var accuracy = 100 - (this.missedShots / this.totalShots * 100);
				var rank;

				runInfo.performance = performance;
				runInfo.accuracy = accuracy;

				if(performance >= 95)
				{
					//dodatkowe wymagania
					rank = "S-";

					//nie stracil ani jednego punktu zdrowia
					if(performance == 100)
					{
						rank = "S";

						//pokonal wszystkie dostepne bossy
						if(this.defeatedBosses == World.Location.RoomInfo.BossChambers)
						{
							if(accuracy >= 90)
							{
								rank = 'S+';
							}
						}
					}

					runInfo.rank = rank;

					return runInfo;
				}

				for(var i = 0; i < ranks.length; i++)
				{
					if(ranks[i][0] <= performance)
					{
						rank = ranks[i][1];
					}
				}

				runInfo.rank = rank;

				return runInfo;
			}
		};

		return stats;
	}

	static GetHeartValue()
	{
		//how many HP contains half heart
		return 10;
	}

	static GetRequiredOxygen(level)
	{
		var requiredOxygen = 100;

		for(var i = 1; i < level; i++)
		{
			requiredOxygen += Math.round(Math.sqrt(requiredOxygen) * 10);
		}

		return requiredOxygen;
	}
	
	GetDefaultBulletStats()
	{
		var stats = 
		{
			Type: "BulletBubble",
			Scale: 1,
			Pierce: 0,
			Bounce: false,
			bounceTime: 5,
			Color: null,
			DeathSound: "effect.BubblePop"
		};

		return stats;
	}

	UpdateBulletStats()
	{
		this.bulletStats.spd = this.stats.BULLET_SPEED;
		this.bulletStats.damage = this.stats.AD;
		this.bulletStats[STAT.ATTACK_RANGE] = this.stats[STAT.ATTACK_RANGE];
		this.bulletStats.Pierce = this.stats[STAT.PIERCE];
	}

	GetDamageValues(AD = false, element = ELEMENT.PHYSICAL)
	{
		if(isObject(AD))
		{
			if(AD.min != null && AD.max != null) return AD;
		}

		var diff = 20; 	//%
		var damage = this.stats.AD;
		if(AD) damage = AD;
		if(element == ELEMENT.THUNDER) return {min: 1, max: ((damage+this.stats[STAT.DAMAGE_ELECTRO])*(100+this.stats[STAT.ELEMENTAL_MASTERY])/100)};
		if(element == ELEMENT.ICE) damage = ((damage+this.stats[STAT.DAMAGE_ICE])*(100+this.stats[STAT.ELEMENTAL_MASTERY])/100);
		if(element == ELEMENT.FIRE) damage = ((damage+this.stats[STAT.DAMAGE_FIRE])*(100+this.stats[STAT.ELEMENTAL_MASTERY])/100);

		var diffValue = Math.round(damage * diff / 100);

		return {min: (damage - diffValue), max: (damage + diffValue)};
	}

	Recall(time, room, location, canInterruptRecall = true)
	{
		this.isRecalling = true;
		this.recallTime = time * Main.FPS;
		this.recallRoom = room;
		this.canInterruptRecall = canInterruptRecall;
		this.recallTicks = 0;
		if(location)
		{
			if(location instanceof Location)
			{
				location = location.name;
			}
		}
		this.recallLocation = location;
	}
	
	UpdateStats()
	{
		var statsPerLevel = //wartosc zwiekszenia statystyki co 1 lv;
		{			
		};
		
		var percent_bonuses = {};

		
		
		for(var stat_name in this.baseStats)
		{
			var base_stat = this.baseStats[stat_name];
			
			if(statsPerLevel[stat_name]) this.stats[stat_name] = base_stat + ( (this.stats.Level - 1) * statsPerLevel[stat_name] );
			else this.stats[stat_name] = base_stat;
		}

		var SP_STAT, STAT_NAME, value, isPercent, invested;
		this.stats.usedSP = 0;
		var maxSP = (this.stats.Level - 1) * 3;
		for(var property in this.SPstats)
		{
			SP_STAT = this.SPstats[property];
			invested = SP_STAT[0];
			STAT_NAME = SP_STAT[1];
			value = SP_STAT[2];
			isPercent = SP_STAT[3];

			this.stats.usedSP += invested;

			if(isPercent) percent_bonuses[STAT_NAME] = invested * value;
			else this.stats[STAT_NAME] += invested * value;
		}

		this.stats.availableSP = maxSP - this.stats.usedSP;

		//sprawdza czy ilosc uzytych sp jest poprawna
		if(this.stats.usedSP > maxSP) Security.ReportProblem(SECURITY_PROBLEM.SP);

		var enchantBullets = {n: 0, p: 0};
		
		var eq = Player.GetEquipSlots();
		for(var slot_name in eq)
		{
			var item = this.equips[slot_name];
			
			if(item)
			{
				var gradeInfo = ItemHelper.GetGradeInfo(item.Grade);
				var primary = item.GetPrimaryBonuses();
				if(primary)
				{			//przedmiot posiada bonusy glowne
					for(var i = 0; i < primary.length; i++)
					{
						var bonus = primary[i];
						var stat_name = bonus.id;

						var value = bonus.value;
							
						if(bonus.isPercent)
						{	
							//wartosc bonusu jest podana w %
							percent_bonuses[stat_name] = (percent_bonuses[stat_name]) ? percent_bonuses[stat_name] + value : value;
						}
						else
						{
							this.stats[stat_name] += value;
						}
					}
				}

				var ench_slots = item.getEnchantSlots();
				if(ench_slots && item.enchantAble)
				{
					for(var i = 0; i < ench_slots; i++)
					{
						var enchant = item.Enchants[i];
						if(!enchant || enchant instanceof EnchantLock) continue;
						
						var stat_name = enchant.bonus.id;
						var value = enchant.bonus.value;

						if(stat_name == STAT.BULLETS_COUNT)
						{
							if(enchant.bonus.isPercent)
							{
								enchantBullets.p += value;
							}
							else
							{
								enchantBullets.n += value;
							}

							continue;
						}


						if(gradeInfo)
						{
							if(gradeInfo.bonus)
							{
								value = value + Math.ceil((value * gradeInfo.bonus) / 100);
							}
						}


						
						if(enchant.bonus.isPercent)
						{
							percent_bonuses[stat_name] = (percent_bonuses[stat_name]) ? percent_bonuses[stat_name] + value : value;
						}
						else
						{
							this.stats[stat_name] += value;
						}
					}
				}

				if(gradeInfo.specialBonus && item.enchantAble)
				{
					for(var i = 0; i < gradeInfo.specialBonus.length; i++)
					{
						var bonus = gradeInfo.specialBonus[i];
						value = bonus.value;
						stat_name = bonus.id;

						if(bonus.isPercent)
						{
							percent_bonuses[stat_name] = (percent_bonuses[stat_name]) ? percent_bonuses[stat_name] + value : value;
						}
						else
						{
							this.stats[stat_name] += value;
						}
					}
					
				}
			}
		}

		for(var stat_name in this.baseStats)
		{			
			if(stat_name in percent_bonuses)
			{
				if(stat_name == STAT.ATTACK_SPEED)
				{
					//attack speed wymaga wiekszej precyzji
					this.stats[stat_name] = Math.round((this.stats[stat_name] + (this.stats[stat_name] * percent_bonuses[stat_name] / 100)) * 100 ) / 100;
				}
				else
				{
					this.stats[stat_name] += Math.round((this.stats[stat_name] * percent_bonuses[stat_name]) / 100);
				}
			}
		}
		
		// this.stats.HP = this.stats.MAXHP - missingHealt;
		
		var heartValue = Player.GetHeartValue();

		this.stats.MAXHP = Math.floor(this.stats.MAXHP / (2 * heartValue)) * (2 * heartValue);
		// this.stats.HP = Math.floor(this.stats.HP / (2 * heartValue)) * (2 * heartValue);

		if(this.stats.HP > this.stats.MAXHP)
		{		
			//obecne zycie nie moze byc wieksze od maksymalnego
			this.stats.HP = this.stats.MAXHP;
		}


		for(var property in this.stats)
		{
			if(property == "HP") continue;
			if(this.additionalStats[property])
			{
				var value = this.additionalStats[property];

				//te statystyki sa procentowe
				if((property == "MAXHP") || (property == "AD"))
				{
					this.stats[property] += Math.round((value * this.stats[property]) / 100);
				}
				else
				{
					this.stats[property] += value;
				}
			}
		}
		
		if(this.stats.AD <= 0) this.stats.AD = 1;
		if(this.stats.CR < 0) this.stats.CR = 0;
		if(this.stats.CR > 100) this.stats.CR = 100;
		if(this.stats[STAT.BLOCK_CHANCE] > 50) this.stats[STAT.BLOCK_CHANCE] = 50;
		

		this.bulletStats = this.GetDefaultBulletStats();

		if(this.equips[SLOT.CANNON])
		{
			this.stats.BULLETS_COUNT = (this.equips[SLOT.CANNON].BULLETS_COUNT) ? this.equips[SLOT.CANNON].BULLETS_COUNT : 1;
			this.bulletStats.Type = this.equips[SLOT.CANNON].BulletType;

			if(enchantBullets.n)
			{
				this.stats.BULLETS_COUNT += enchantBullets.n;
			}
			else if(enchantBullets.p)
			{
				this.stats.BULLETS_COUNT += Math.round((this.stats.BULLETS_COUNT * enchantBullets.p) / 100);
			}

			var type = new (Projectile.Types()[this.bulletStats.Type])();
		}


		
	}

	LevelUp()
	{
		this.oxygen -= this.requiredOxygen;
		this.stats.Level++;
		this.stats.availableSP += 3;
		// this.baseStats.MAXHP += 1;
		// this.baseStats.AD++;
		// this.baseStats.SPD += 10;
		
		if(this.oxygen < 0)
		{
			this.oxygen = 0;
		}

		this.UpdateStats();

		this.stats.HP = this.stats.MAXHP;

		this.requiredOxygen = Player.GetRequiredOxygen(this.stats.Level);

		var stats = {};
			stats.spd = 900;
			stats.damage = this.stats.AD * 10;
			stats.Type = "HolyBullet";
			stats[STAT.ATTACK_RANGE] = 9999;
			stats.Scale = 4;
		AI_ShotOnCircle.StaticShoot(this, stats, 64);
		Camera.Shake(2, true, 25);
		InGame.showLevelUpMessage(true);
	}

	UseSPpoint(statName)
	{
		if(!this.SPstats[statName]) return;

		//sprawdza czy moze dodac punkty
		if(this.stats.availableSP <= 0) return;
		

		this.SPstats[statName][0]++;
		this.UpdateStats();
	}

	ResetSPpoints()
	{
		for(var property in this.SPstats)
		{
			this.SPstats[property][0] = 0;
		}

		this.UpdateStats();
	}

	UpdateHP()
	{
		if(this.lastHP != this.stats.HP || this.lastMAXHP != this.stats.MAXHP)
		{
			UI_Helper.UpdatePlayerHealthBar(this.stats.HP, this.stats.MAXHP);
		}
		
		this.lastHP = this.stats.HP;
		this.lastMAXHP = this.stats.MAXHP;
	}

	CompleteLocation(id)
	{
		this.locationInfo[id].isCleared = true;
		this.Save();
	}

	ChangeSkin(skin)
	{
		if(!this.Appearance.AvailableSkins[skin] && skin != SKIN.BASE && skin != SKIN.BASEF) return;
		if(!Player.Skins[skin]) skin = SKIN.BASE;
		
		var s = Player.Skins[skin];

		this.Skin = new s(this);
		this.Appearance.Skin = skin;
	}
	
	Update()
	{
		if(!this.isAlive) return;
		this.ageInTicks++;

		this.canDodge = false;
		this.isHurtAble = true;
		this.canInteractWith = [];
		this.isBouncing = false;
		this.isAttacking = false;

		if(!this.Skin || this.Skin.constructor.name != this.Appearance.Skin) this.ChangeSkin(this.Appearance.Skin);
		this.Skin.Update();
		this.GetCurrentWeaponModel()?.Update(this);

		if(this.interactionWith) this.allowMove = false;

		if(!InGame.GUI.RunInfo.Open) this.RunStats.timeInLocation++;
		if(this.hurted) this.timeSinceHurt++;

		if(!this.isStunned) this.Rotation = (MathHelper.getAngle2([Mouse.x, Mouse.y], [this.posX, this.posY]) + 270)%360;
		// if(this.x < 0) this.x = World.CenterPoint.x;
		// if(this.y < 0) this.y = World.CenterPoint.y;

		if(this.stats.HP <= 0) 
		{
			this.Kill();
			this.UpdateHP();
			return;
		}
		if(this.oxygen >= this.requiredOxygen) this.LevelUp();

		this.UpdateHP();

		UI_Helper.setBarProgress('player_attack_charge', (this.attackGauge * 100) + '%');

		if(this.equips[SLOT.CANNON]?.requiredMP)
		{
			set('#player_attack_bars_container', 'dataset.showspecialcharge', 'true', true);
			UI_Helper.setBarProgress('player_special_attack_charge', (this.specialAttackGauge * 100) + '%');
		}
		else
		{
			set('#player_attack_bars_container', 'dataset.showspecialcharge', 'false', true);
		}
		

		var exp_progress = this.oxygen / this.requiredOxygen * 100;
		var dmg = this.GetDamageValues();
		var as = (this.stats.ATTACK_SPEED == parseInt(this.stats.ATTACK_SPEED)) ? this.stats.ATTACK_SPEED + ".0" : this.stats.ATTACK_SPEED;

		UI_Helper.setBarProgress('player_level_bar', exp_progress + '%');
		set('#player_level', 'dataset.level', Lang.Get('STAT.LEVEL') + ': ' + this.stats.Level, true);
		set('#player_stat_exp', 'innerText', this.oxygen +' / '+ this.requiredOxygen, true);

		set('#player_stat_hp', 'innerText', this.stats.HP +' / '+ this.stats.MAXHP, true);
		set('#player_stat_def', 'innerText', this.stats.DEFENSE, true);
		set('#player_stat_ad', 'innerText', dmg.min + " - " + dmg.max, true);
		set('#player_stat_attack_speed', 'innerText', as, true);
		set('#player_stat_attack_range', 'innerText', this.stats.ATTACK_RANGE, true);
		set('#player_stat_spd', 'innerText', this.stats.SPD, true);

		set('#player_health_container', 'dataset.poisoned', this.isPoisoned, true);
		set('#shader_poisoning', 'dataset.open', this.isPoisoned, true);

		for(var name in this.SPstats)
		{
			var value = this.SPstats[name][0];
			set('#player_stat_'+name.toLowerCase(), 'innerText', value, true);
		}


		set('#player_stat_available_sp', 'dataset.sp', this.stats.availableSP, true);
		set('#player_oxygen', 'innerText', Style.DottedText(this.coins), true);

		UI_Helper.updateCooltimeIcons();

		this.Effects.Update(this);
		this.UpdateEquipTicks();
		this.UpdateDash();

		this.lastPos = {x: this.x, y: this.y};
		this.posX = (canvas.width / 2) - this.Width / 2;
		this.posY = (canvas.height / 2) + this.Height / 2;

		this.UpdateRecall();

		if(this.timeInRoom < Main.FPS || (this.timeSinceHurt < this.immunityDuration * this.immunityDurationMultiplier * Main.FPS && this.hurted))
		{
			this.isHurtAble = false;
		}
		

		
		Collision.Check(this);

		
		if(!this.isWriting && !this.isStunned)
		{
			if(this.allowControl && !this.interactionWith)
			{
				if(Mouse.click && Mouse.focus == Graphic.mainCanvas)
				{
					if(this.hand)
					{
						Mouse.click = false;
						var dir = (Mouse.x < this.posX) ? -1 : 1;
						if(this.hand.Drop(this.x, this.y, null, dir)) this.hand = null;
						InventoryGUI.UpdateHand();
					}
					else if(this.allowAttack)
					{
						this.isAttacking = true;
					}
				}
			}



			this.MovementUpdate();
			
			
			if((Settings.Controls.StateBounce) && (!this.lockKey.Bounce))
			{
				this.isBouncing = true;
				this.lockKey.Bounce = true;
			}
			else if(!Settings.Controls.StateBounce)
			{
				this.lockKey.Bounce = false;
			}


			if(this.canInterruptRecall && (this.isMoving || this.isDashing || this.velocityX || this.velocityY))
			{
				this.isRecalling = false;
				this.movedInRoom = true;
			}


			
			var distance = MathHelper.GetDistance([this.x, this.y], [World.CenterPoint.x, World.CenterPoint.y]);
			
			this.allowControl = true;
			
			var isOutOfBubble = (distance > World.Radius) ? true : false;
			if( (distance > World.Radius - 64) && !isOutOfBubble && this.allowControl && !Main.BorderLess && !World.isChangingLocation)
			{
				// this.isBouncing = true;
				var s = (((distance+64)-World.Radius) / 64) * (this.stats.SPD * 1.2);
				var motion = Motion.Get([this.x, this.y], [World.CenterPoint.x, World.CenterPoint.y], s);
				this.ApplyMove(motion);
			}
			
			if(this.isBouncing)
			{
				this.velocityX *= -1;
				this.velocityY *= -1;
			}

			if(Mouse.rightClick) this.Dash();

			this.WeaponUpdate();
		}

		this.allowAttack = true;
		this.allowMove = true;

		this.HitBox.Update(this);
		this.Skin.Update();
	}

	UpdateEquipTicks()
	{
		for(var slot in this.equips)
		{
			var item = this.equips[slot];
			if(item) if(isFunction(item.onEquipTick)) item.onEquipTick(this);
		}
	}

	onLocationExit()
	{
		var runInfo = this.RunStats.getRunInfo();
		if(runInfo)
		{
			var loc_id = World.Location.constructor.name;
			var ranks = ['F', 'D-', 'D', 'D+', 'C-', 'C', 'C+', 'B-', 'B', 'B+', 'A-', 'A', 'A+', 'S', 'S+', 'SS', 'SSS'];
			var currentRank = get(this, 'locationInfo.'+loc_id+'.rank');
			var rank = runInfo.rank;
			
			if(currentRank)
			{
				var currentIndex = ranks.indexOf(currentRank);
				var newIndex = ranks.indexOf(rank);

				if(newIndex < currentIndex) rank = currentRank;
			}

			InGame.GUI.RunInfo.open(this.RunStats);

			set(this, 'locationInfo.'+loc_id+'.rank', rank);
			this.Save();
		}
	}

	UpdateRecall()
	{
		if(this.isRecalling)
		{
			this.recallTicks++;

			InGame.backgroundTransparency = this.recallTicks / this.recallTime;

			if(this.recallTicks == this.recallTime)
			{
				if(this.recallRoom && !this.recallLocation)
				{
					World.currentRoom.Quit();
					this.recallRoom.Enter();
					this.x = World.CenterPoint.x;
					this.y = World.CenterPoint.y;
				}

				if(this.recallLocation)
				{
					if(this.recallLocation != World.Location.Name)
					{
						this.onLocationExit();
						World.Location.Exit();
						World.LoadMap(this.recallLocation, true);
					}
				}
			}

			/*
			var isRunInfo = this.RunStats.getRunInfo();

			if(this.recallTicks == this.recallTime - 2)
			{
				if(isRunInfo)
				{
					//open stats gui
					InGame.GUI.RunInfo.Open = true;
				}
			}

			if(this.recallTicks == this.recallTime - 1)
			{
				if(isRunInfo && InGame.GUI.RunInfo.Open)
				{
					this.recallTicks =  this.recallTime - 2;
				}
			}

			*/
			

			//animacja pojawiania sie gracza
			if(this.recallTicks > this.recallTime)
			{
				this.allowControl = false;
				var animationTime = (Main.FPS  / 3);
				var toEnd = this.recallTime + animationTime;
				InGame.backgroundTransparency = 1 - ((this.recallTicks - this.recallTime) / animationTime);
				if(this.recallTicks >= toEnd)
				{
					this.isRecalling = false;
					InGame.backgroundTransparency = 0;
					this.timeInRoom = (!World.currentRoom.isCleared) ? 0 : this.timeInRoom;
				}
			}
		}
	}

	UpdateCooltime(id, current, required, icon, isEffect = false)
	{
		var p = Math.round(current / required * 100);
		if(isEffect) p = 100 - p;
		if(p < 0) p = 0;
		if(p > 100) p = 100;

		if(!icon) icon = id;

		this.Cooltimes[id] = 
		{
			current: current,
			required: required,
			progress: p,
			icon: icon,
			isEffect: isEffect
		};
	}

	canDash()
	{
		if(this.isDashing) return false;
		if(!this.allowMove) return false;
		if(!this.allowControl) return false;
		if(this.interactionWith) return false;
		// if(!this.isMoving) return false;
		if(!this.stats[STAT.DASH_DURATION] || !this.stats[STAT.DASH_COOLTIME]) return false;
		if(this.dashStart + this.stats[STAT.DASH_DURATION] + (this.stats[STAT.DASH_COOLTIME] * Main.FPS) >= this.ageInTicks) return false;
		return true;
	}

	GetDashDistance(multiplier = this.stats[STAT.DASH_DISTANCE], duration = this.stats[STAT.DASH_DURATION])
	{
		return Math.ceil(((this.GetSPD() * multiplier) / (Main.FPS / duration)) / 10) * 10;
	}

	UpdateDash()
	{
		var cd = this.stats[STAT.DASH_COOLTIME];
		var duration = this.stats[STAT.DASH_DURATION];
		var multiplier = this.stats[STAT.DASH_DISTANCE];

		var required = (cd * Main.FPS) + duration;
		var current = this.ageInTicks - (this.dashStart);
		
		if(required) this.UpdateCooltime('DASH', current, required);

		if(!this.isDashing) return;

		if(this.dashStart + duration < this.ageInTicks) 
		{
			this.isDashing = false;
			this.dashEnd = this.ageInTicks;
		}

		var spd = this.GetSPD();
		var delta = Main.DELTA;

		spd *= multiplier;

		var to = MathHelper.lineToAngle([this.x, this.y], spd * delta, this.dashAngle);
		if(MathHelper.GetDistance([to.x, to.y], World.CenterPoint) < World.Radius)
		{
			this.x = to.x;
			this.y = to.y;
		}

		this.dashShadowsData.push({x: this.x, y: this.y, Rotation: this.Appearance.Rotation, times: 0});
	}

	Dash()
	{
		if(!this.canDash()) return;

		this.isDashing = true;
		this.dashStart = this.ageInTicks;

		

		if(Settings.Controls.AlwaysDashTowardCursor || 
		(!Settings.Controls.StateMoveLeft && !Settings.Controls.StateMoveRight && !Settings.Controls.StateMoveUp && !Settings.Controls.StateMoveDown))
		{
			this.dashAngle = MathHelper.getAngle2([this.x - Camera.xView, this.y - Camera.yView], [Mouse.x, Mouse.y]);	//dash toward cursor
		}
		else
		{
			this.dashAngle = MathHelper.getAngle2([this.x, this.y], [this.x + this.velocityX, this.y + this.velocityY]);	//dash toward current move direction
		}
		
		this.dashShadowsData = [];
	}

	GetSPD()
	{
		var spd = this.stats.SPD * ((100 - this.Slow) / 100);
		return spd;
	}

	MovementUpdate()
	{
		this.isMoving = false;

		var spd = this.GetSPD();
		var delta = Main.DELTA;
		var acc = this.stats.ACCELERATION;
		var brake  = this.stats.BRAKE;

		var movingLeft, movingRight, movingUp, movingDown;

		if(this.allowControl && !this.interactionWith && !this.isDashing)
		{
			if(Settings.Controls.StateMoveLeft && !this.lockMove.Left) movingLeft = true;
			if(Settings.Controls.StateMoveRight && !this.lockMove.Right) movingRight = true;
			if(Settings.Controls.StateMoveUp && !this.lockMove.Top) movingUp = true;
			if(Settings.Controls.StateMoveDown && !this.lockMove.Down) movingDown = true;
		}

		if(movingLeft || movingRight || movingUp || movingDown) this.isMoving = true;

		var m = 1;

		if(movingLeft)
		{
			m = 1;
			if(this.velocityX > -spd)
			{
				if(this.velocityX > spd / 2) m = .5;		//make it faster if player was moving right and now want to change direction to the left.
				this.velocityX -= spd / (acc * m) * delta;
				if(this.velocityX < -spd) this.velocityX = -spd;
			}
		}


		if(movingRight)
		{
			m = 1;
			if(this.velocityX < spd)
			{
				if(this.velocityX < -spd / 2) m = .5;		//make it faster if player was moving left and now want to change direction to the right.
				this.velocityX += spd / (acc * m) * delta;
				if(this.velocityX > spd) this.velocityX = spd;
			}
		}




		if(movingUp)
		{
			m = 1;
			if(this.velocityY > -spd)
			{
				if(this.velocityY > spd / 2) m = .5;		//make it faster if player was moving down and now want to change direction to the up.
				this.velocityY -= spd / (acc * m) * delta;
				if(this.velocityY < -spd) this.velocityY = -spd;
			}
		}


		if(movingDown)
		{
			m = 1;
			if(this.velocityY < spd)
			{
				if(this.velocityY < -spd / 2) m = .5;		//make it faster if player was moving up and now want to change direction to the bottom.
				this.velocityY += spd / (acc*m) * delta;
				if(this.velocityY > spd) this.velocityY = spd;
			}
		}


		//stop player if both keys are hold or both are not
		if((movingLeft && movingRight) || (!movingLeft && !movingRight)) 
		{      
            if(this.velocityX < 0) 
			{       
                this.velocityX += spd / brake * delta;
                if(this.velocityX > 0) this.velocityX = 0;
            }
            else if(this.velocityX > 0) 
			{
                this.velocityX -= spd / brake * delta;
                if(this.velocityX < 0) this.velocityX = 0;
            }
        }

		// console.log(this.ageInTicks + " / " + this.velocityX);


		if((movingUp && movingDown) || (!movingUp && !movingDown)) 
		{      
            if(this.velocityY < 0) 
			{       
                this.velocityY += spd / brake * delta;
                if(this.velocityY > 0) this.velocityY = 0;
            }
            else if(this.velocityY > 0) 
			{
                this.velocityY -= spd / brake * delta;
                if(this.velocityY < 0) this.velocityY = 0;
            }
        }


		if(!this.allowMove || this.interactionWith)
		{
			this.velocityX = 0;
			this.velocityY = 0;
		}


		var move = {x: this.velocityX, y: this.velocityY};
		var currentSpd = MathHelper.GetMovementSpeed(this.velocityX, this.velocityY);

		if(currentSpd > spd)
		{
			var mltp = spd/currentSpd;

			move.x = this.velocityX * mltp;
			move.y = this.velocityY * mltp;

			// console.log(currentSpd, spd, MathHelper.GetMovementSpeed(x, y));
		}


		// this.ApplyMove({x: this.velocityX, y: this.velocityY});
		this.ApplyMove(move);
	}

	GetWeapon()
	{
		var weapon = this.equips[SLOT.CANNON];
		if(!weapon) return null;
		return weapon;
	}

	WeaponUpdate()
	{
		this.GetWeapon()?.onOwnerUpdate?.(this);
	}

	ApplyMove(motion)
	{
		if(motion)
		{
			this.x += motion.x * Main.DELTA;
			this.y += motion.y * Main.DELTA;
		}
	}

	GetBulletStartPos(posId = 0)
	{
		var distance = this.shotPoints[posId].distance;
		var angle = this.shotPoints[posId].angle;

		return MathHelper.lineToAngle([this.x, this.y], (distance * this.Scale), this.Rotation - 90 - angle);
	}

	canBeHurt()
	{
		if(!this.isHurtAble) return false;
		if(this.isInvincible) return false;
		if(this.isDashing) return false;
		if(this.godMode) return false;
		return true;
	}

	setDifficultyDamageReceived(baseDamage)
	{
		var info = GetDifficultyInfo();
		baseDamage *= info.DamageMultiplier;

		return Math.round(baseDamage);
	}

	getDamageReduction()
	{
		var base_reduction = this.stats[STAT.DAMAGE_REDUCTION] ?? 0;
		var defense = this.stats[STAT.DEFENSE];

		return base_reduction + Math.floor(defense / 10);
	}

	Heal(amount, percent = false, showIndicator = true)
	{
		if(percent) amount = Math.ceil(this.stats.MAXHP * amount / 100);
		var healed = amount;

		if(this.stats.HP >= this.stats.MAXHP) return;

		this.stats.HP += amount;
		if(this.stats.HP > this.stats.MAXHP)
		{
			healed -= (this.stats.MAXHP - this.stats.HP);
			this.stats.HP = this.stats.MAXHP;
		}

		if(showIndicator) DamageIndicator.AddObject(this.x, this.y, healed, "HEAL");
	}
	
	Hurt(damage, source, data = {})
	{
		if(!this.canBeHurt() && !data?.ALWAYS_HURT) return;
		this.immunityDurationMultiplier = 1;

		damage = this.setDifficultyDamageReceived(damage);
		var defense = this.stats[STAT.DEFENSE];
		var reduction = this.getDamageReduction();

		if(data.IGNORE_REDUCTION) reduction = 0;
		if(data.ELEMENT == ELEMENT.THUNDER) damage = MathHelper.randomInRange(1, damage);

		var type = data.ELEMENT;
		if(this.Resistance[type]) damage = Math.floor(damage / 2);
		if(this.Weakness[type]) damage *= 2;
		if(this.Immunity[type]) damage = 1;
		if(this.DefBreak) damage = Math.ceil(damage * (100 + this.DefBreak) / 100);


		if(damage)
		{
			if(type == ELEMENT.PHYSICAL) damage -= defense;
			damage = Math.round(damage * (100 - reduction) / 100);

			if(damage < 1) damage = 1;

			var dodge = false;
			var shake = 2;

			if(type != ELEMENT.POISON && 
				MathHelper.GetChance(this.stats[STAT.BLOCK_CHANCE])
			) 
			{
				damage = 0;
				dodge = true;
			}

			if(this.shield)
			{
				this.shield -= damage;
				if(this.shield <= 0)
				{
					this.stats.HP += this.shield;
					this.shield = 0;
					shake = 3;
				}
			}
			else
			{
				this.stats.HP -= damage;	
			}

			//damage that deals less than 5% of max health causes shorter immunity
			if(damage < this.stats.MAXHP * .05)
			{
				var p = damage / (this.stats.MAXHP * .05);
				this.immunityDurationMultiplier = p;
			}
			if(type == ELEMENT.FIRE)
			{
				this.immunityDurationMultiplier = .1;
			}

			if(dodge)
			{
				if(Settings.General.ShowDamageReceived) DamageIndicator.AddObject(this.x, this.y, Lang.Get('TEXT.BLOCK'), "DEALT");
				return;
			}


			this.hurted = (World.Location.isCleared) ? this.hurted : true;
			if(Settings.General.ShowDamageReceived) DamageIndicator.AddObject(this.x, this.y, damage, "RECEIVED");
			this.totalDamageReceived += damage;
			this.RunStats.hpLostInRoom += damage;

			if(type == ELEMENT.POISON)
			{
				if(this.stats.HP <= 0) this.stats.HP = 1;		//poison cannot kill you
			}
			else
			{
				Camera.Shake(shake, true);
				this.timeSinceHurt = 0;
			}


			
			this.lastHurtBy = source;
			this.isHurtAble = false;		//player cant be hurted with more than one projectile in game tick
		}
	}

	Kill()
	{
		this.stats.HP = this.stats.MAXHP;
		this.ApplyDeathPenalty();
		this.Save();

		this.stats.HP = 0;
		this.isAlive = false;
		World.AddParticle(new Particle("bubble_pop", this.HitBox.x, this.HitBox.y, 120, this.Width, this.Height, this.Scale));
		World.Kill(Projectile, true);
		InGame.failScreenAlpha.ageInTicks = 1;
		Camera.Shake(2, true, 3 * Main.FPS);
		Mouse.click = false;
		InGame.DeathScreenQuote = Helper.GetDeathQuote(this.lastHurtBy);
		World.PlayerEntities = [];

		document.querySelectorAll('#ingame .pop-up').forEach(e => e.dataset.open = 'false');		//hide uis
	}

	ApplyDeathPenalty()
	{
		if(Difficulty(0)) return;
		var info = GetDifficultyInfo();

		this.oxygen -= Math.floor(this.requiredOxygen * info.DeathPenaltyXp / 100);
		if(this.oxygen < 0) this.oxygen = 0;
		this.coins = Math.floor(this.coins * (100 - info.DeathPenaltyOxygen) / 100);
	}


	Respawn()
	{
		var player = new Player();
			
		World.Players[0] = player;
		World.Player = player;
		World.Boss = null;

		player.Load();
	}

	GetCurrentWeaponModel()
	{
		var weaponModel = this.GetWeapon()?.Model;
		if(this.Appearance.Weapon) return this.Appearance.Weapon;
		return weaponModel;
	}

	RenderDashShadows(context)
	{
		if(this.dashShadowsData.length > 0)
		{
			var savedX = this.x;
			var savedY = this.y;
			var savedRot = this.Appearance.Rotation;
			var savedAlpha = this.Appearance.Transparency;
			var shadowsRendered = 0;

			for(var i = 0; i < this.dashShadowsData.length; i++)
			{
				var data = this.dashShadowsData[i];
				if(data.times > 10) continue;
				shadowsRendered++;

				this.x = data.x;
				this.y = data.y;
				this.Appearance.Rotation = data.Rotation;
				this.Appearance.Transparency = .25 - (data.times * .025);

				this.Skin.RenderHands(context);
				this.GetCurrentWeaponModel()?.Render(context, this);
				this.Skin.Render(context);

				this.dashShadowsData[i].times++;
			}

			this.x = savedX;
			this.y = savedY;
			this.Appearance.Rotation = savedRot;
			this.Appearance.Transparency = savedAlpha;

			if(shadowsRendered == 0) this.dashShadowsData = [];
		}
	}
	
	Render(context)
	{
		if(!this.isAlive) return;

		if(!this.isHurtAble)
		{
			this.Transparency = this.alphaTransition.Update();
		}
		else
		{
			this.Transparency = 1;
		}
		if(this.isDashing) this.Transparency = .5;

		var scale = this.Scale * this.scaleTransition.Update();
		this.Appearance.Scale = scale;
		this.Appearance.Rotation = this.laserRotation ?? this.Rotation;
		this.Appearance.Transparency = this.Transparency;
		

		var spd = this.stats.SPD;
		var particle = this.Appearance.Particle;
		if(Math.abs(this.velocityX) > spd * 0.4 || Math.abs(this.velocityY) > spd * 0.4)
		{
			if(this.ageInTicks % 5 == 0)
			{
				var x = this.x + (this.Width / 4 * this.Scale);
				var y = this.y + (this.Height / 4 * this.Scale);

				x = MathHelper.randomInRange(x - (this.Width / 4 * scale), x + (this.Width / 4 * scale));
				y = MathHelper.randomInRange(y - (this.Height /  4 * scale), y + (this.Height /  4 * scale));

				Particle.SummonCirclePattern(particle, x, y, 0.4, 2, 1, 11, null, null, false);
			}
		}

		this.RenderDashShadows(context);

		this.Skin.RenderHands(context);
		this.GetCurrentWeaponModel()?.Render(context, this);
		this.Skin.Render(context);
		this.HitBox.Render();
		this.Effects.Render(context, this);

		Graphic.addLightSource(this.x - Camera.xView, this.y - Camera.yView, this.stats[STAT.LIGHT_RANGE]);
	}

	haveItemInInventory(itemType, count = 1)
	{
		for (var i = 0; i < this.stats.availableSlots; i++)
		{
			var item = this.inventory[i];
			if (!item) continue;

			if (itemType == item.constructor.name)
				if(item.count >= count) return i;
		}

		return -1;
	}

	haveItemInstanceInInventory(itemType, count = 1)
	{
		for (var i = 0; i < this.stats.availableSlots; i++)
		{
			var item = this.inventory[i];
			if (!item) continue;

			if (item instanceof itemType)
				if(item.count >= count) return i;
		}

		return -1;
	}

	addItemToInventory(item, count = 0, showNewItemInfo = false)
	{
		if(typeof item === 'string')
		{
			//podano nazwe przedmiotu, a nie przedmiot
			
			item = Item.Get(item);
		}

		var stacked = false;
		var added = false;

		if (item != null)
		{
			if(count) item.count = count;
			if(showNewItemInfo)
			{
				item.showNewItemInfo = showNewItemInfo;
			}
			
			for (var i = 0; i < this.stats.availableSlots; i++)
			{
				if (this.inventory[i] != null)
				{				//w danym slocie znajduje sie przedmiot
					if (item.constructor.name == this.inventory[i].constructor.name)
					{		//przedmiot ktory jest dodawany jest taki sam jak w slocie
						if (item.stackAble)
						{
							if (this.inventory[i].count < this.inventory[i].maxStackSize)
							{
								if ((this.inventory[i].count + item.count) <= this.inventory[i].maxStackSize)
								{
									this.inventory[i].count += item.count;
									this.inventory[i].showNewItemInfo = true;
									stacked = true;
									InventoryGUI.Update();
									return i;
								}
								else
								{
									this.inventory[i].count += item.count;
									item.count = Math.abs(this.inventory[i].count - this.inventory[i].maxStackSize);
									this.inventory[i].count = this.inventory[i].maxStackSize;
									continue;
								}
							}
						}
					}
				}
			}


			if (!stacked)
			{
				for (var i = 0; i < this.stats.availableSlots; i++)
				{
					if (this.inventory[i] == null)
					{		//wartosc w inventory jest pusta
						this.inventory[i] = item;
						InventoryGUI.Update();
						return i;
					}
				}
			}
	
			//przedmiot nie mogl zostac dodany, wiec zostanie wyrzucony na podloge
			item.Drop(this.x, this.y, this.inventory);
		}

		InventoryGUI.Update();
		return -1;
	}
}


class PlayerDummy
{
	constructor(player)
	{
		this.x = 0;
		this.y = 0;

		this.Width = player.Width;
		this.Height = player.Height;

		this.Appearance = {...player.Appearance};
		this.Appearance.Rotation = 180;
		this.Appearance.Scale = 1;
		this.Appearance.Transparency = 1;

		this.attackGauge = 1;
	}
}

class Upgrade
{
	constructor(name, description, onActive, onDisactive)
	{
		this.name = name;
		this.description = description;
		this.inUse = false;
		this.active = false;
		this.onActive = onActive;
		this.onDisactive = onDisactive;
	}
	
	Active(player)
	{
		if(!this.active)
		{
			if(isFunction(this.onActive))
			{
				this.onActive(player);
			}
			InGame.itemTitle = this.description;
			setTimeout(function(){InGame.itemTitle = "";}, 3000);
			player.UpdateStats();
			this.active = true;
			this.inUse = true;
		}
	}
	
	Disactive(player)
	{
		if(this.active)
		{
			if(isFunction(this.onDisactive))
			{
				this.onDisactive(player);
			}
			this.active = false;
		}
	}
	
	static Spawn(player, x, y)
	{
		var upgradesAvailable = 0;
		for(var i =0; i < player.Upgrades.length; i++)
		{
			if(!player.Upgrades[i].inUse)
			{
				upgradesAvailable++;
			}
		}
		
		if(upgradesAvailable)
		{
			while(true)
			{
				var upgrade = MathHelper.randomInRange(0, player.Upgrades.length - 1);
				if(!player.Upgrades[upgrade].inUse)
				{
					World.AddEntity(new EntityUpgrade(x, y, upgrade));
					break;
				}
			}
		}
	}
}class Controls
{
	constructor()
	{
		this.PlayerMoveUp = "W";
		this.PlayerMoveDown = "S";
		this.PlayerMoveRight = "D";
		this.PlayerMoveLeft = "A";
		this.OpenInventory = "E";
		this.SwitchWeapons = "Q";
		this.OpenPlayerStats = "C";
		this.Bounce = " ";
		this.UseItemSkill = " ";
		this.Escape = "ESCAPE";
		this.OpenMap = "TAB";
		this.OpenWorldMap = "M";
		this.OpenQuestLog = 'V';
		this.Interact = 'F';
		this.UseItem = 'F';
		
		this.StateMoveUp = false;
		this.StateMoveDown = false;
		this.StateMoveLeft = false;
		this.StateMoveRight = false;
		this.StateOpenInventory = false;
		this.StateOpenPlayerStats = false;
		this.StateSwitchWeapons = false;
		this.StateBounce = false;
		this.StateUseItemSkill = false;
		this.StateEscape = false;
		this.StateMap = false;
		this.StateInteract = false;
		this.StateUseItem = false;

		this.AlwaysDashTowardCursor = false;
	}

	Update(key, KeyDown)
	{
		var interaction = World.Player.interactionWith;

		switch(key.toUpperCase())
		{
			case this.PlayerMoveUp:
				this.StateMoveUp = KeyDown;
				break;
				
			case this.PlayerMoveDown:
				this.StateMoveDown = KeyDown;
				break;
				
			case this.PlayerMoveRight:
				this.StateMoveRight = KeyDown;
				break;
				
				
			case this.PlayerMoveLeft:
				this.StateMoveLeft = KeyDown;
				break;

			case this.OpenInventory:
				if(this.canToggleIngameGUI(KeyDown) && !interaction) UI_Helper.ToggleInventory();
				// this.StateOpenInventory = KeyDown;
				break;

			case this.OpenPlayerStats:
				if(this.canToggleIngameGUI(KeyDown) && !interaction) UI_Helper.TogglePlayerStats();
				this.StateOpenPlayerStats = KeyDown;
				break;
				
			// case this.Bounce:
			// 	this.StateBounce = KeyDown;
			// 	break;

			case this.UseItemSkill:
				this.StateUseItemSkill = KeyDown;
				break;
				
			case this.Escape:
				this.StateEscape = KeyDown;
				if(KeyDown) UI_Helper.CatchEscape();
				break;

			case this.OpenMap:
				this.StateMap = KeyDown;
				break;

			case this.OpenWorldMap:
				if(this.canToggleIngameGUI(KeyDown) && !interaction) UI_Helper.ToggleWorldMap();
				break;

			case this.OpenQuestLog:
				if(this.canToggleIngameGUI(KeyDown) && !interaction) UI_Helper.ToggleQuestLog();
				break;

			case this.Interact:
				if(World?.Player?.Interact() && this.canToggleIngameGUI(!KeyDown) && DialogGUI.canBeOpened())
				{
					DialogGUI.Open();
					this.StateInteract = KeyDown;
				}

			case this.UseItem:
				this.StateUseItem = KeyDown;
				break;
		}
	}

	canToggleIngameGUI(KeyDown, ignorePause = false)
	{
		if(Main.RUNNING != RUNNING.INGAME) return false;
		if(!ignorePause && InGame.pause) return false;
		if(KeyDown) return false;
		return true;
	}
}class General
{
	constructor()
	{
		this.Lang = "EN";
		this.ShowDamageDealt = true;
		this.ShowDamageReceived = true;
		this.showMinimap = true;
		this.showRadar = true;
		this.showFPS = true;
		this.AlwaysShowItemPrice = false;
		this.AllowDraggableWindows = true;
		this.AlwaysReposeWindows = true;
	}
}class Settings
{
	static Init()
	{
		Settings.List = {};

		Settings.InitSetting(Controls);
		Settings.InitSetting(Video);
		Settings.InitSetting(Sound);
		Settings.InitSetting(General);

		Settings.Load();
	}


	static Apply()
	{
		document.body.style.setProperty('--ui-scale', Settings.Video.UI_Scale / 100);

		Graphic.mainCanvas.width = Settings.Video.Resolution[0];
		Graphic.mainCanvas.height = Settings.Video.Resolution[1];
		
		// Lang.Initialize("EN");
		// UI_Helper.Init();

		Graphic.ApplyFullscreen();
		Main.Resize();
	}

	static InitSetting(constr)
	{
		var name = constr.name;
		Settings[name] = new constr();
		Settings.List[name] = constr;
	}
	
	static Load()
	{
		var save = localStorage.getItem("SETTINGS");
		if(isJSON(save))
		{
			save = JSON.parse(save);
			
			for(var objName in save)
			{
				for(var property in save[objName])
				{
					if(objName == "Controls" && property.includes("State")) continue;
					Settings[objName][property] = save[objName][property];
				}
			}
		}

		Settings.Video.isFullscreen = false;
	}

	static Save()
	{
		var obj = {};
		for(var prop in Settings.List)
		{
			obj[prop] = Settings[prop];
		}

		var save = JSON.stringify(obj);
		localStorage.setItem("SETTINGS", save);

		Settings.Apply();
	}

	static RestoreDefault(type)
	{
		var constr = Settings.List[type];
		if(!constr) return;

		Settings[type] = new constr();
	}
}

class Sound
{
	constructor()
	{
		this.Music = 10;
		this.Effects = 20;
		this.General = 50;
	}
}class Video
{
	constructor()
	{
		this.Resolution = [1920, 1080];
		this.isFullscreen = false;
		this.UI_Scale = 100;
	}

	getResolutions()
	{
		var res = 
		[
			[800, 600],
			[1024, 720],
			[1920, 1080]
		];

		return res;
	}
}class Dimension
{
    constructor()
    {
        this.HexMap = [[]];
        this.Points = [];

        this.lightMap = [];
    }

    getLocations(dimension = 'OVERWORLD', showAll = Main.renderFullMap)
    {
        var locations = [];

        for(var locationName in World.LocationList)
		{
			var location = World.LocationList[locationName];
            if(location.Dimension != dimension) continue;

			if(World?.Player?.locationInfo[locationName] || showAll)
			{
				var prevLocationCleared = showAll;
                var alwaysVisible = (location.specialIcon) ? true : false;
                var isCleared = World?.Player?.locationInfo[locationName]?.isCleared;

				if(location.reqPrevLocation && !showAll)
				{
                    for(var i = 0; i < location.reqPrevLocation.length; i++)
                    {
                        var prev_id = location.reqPrevLocation[i];

                        if(World.Player.locationInfo[prev_id]?.isCleared)
                        {
                            prevLocationCleared = true;
                            break;
                        }
                    }
				}

                var canInteract = (isCleared || prevLocationCleared);

				if(isCleared || prevLocationCleared || alwaysVisible)
				{
					locations[locationName] = 
					{
						x: location.MapPos.x,
						y: location.MapPos.y,

						isVillage: location.isVillage,
						specialIcon: location.specialIcon,
                        canInteract: canInteract,
						name: location.GetDisplayName(),
						id: locationName,
						requiredLevel: location.requiredLevel,
						canPlayerEnter: (location.requiredLevel > World.Player.stats.Level) ? false : true,
						isCurrent: (locationName == World?.Location?.constructor?.name) ? true : false,
						isCleared: isCleared,
						rank: World?.Player?.locationInfo[locationName]?.rank
					};
				}
			}
		}

        return locations;
    }

    getLocationPoints()
    {
        var locations = this.getLocations();
        var points = [];

        for(var locationName in locations)
		{
			var location = locations[locationName];
            var p = new HexMapPoint(location.x, location.y, location);
            points.push(p);
        }

        return points;
    }

    static getLightMap(map, points)
    {
        var s = Dimension.getHexMapSize(map);
        var lightMap = [];

        for(var i = 0; i < s.height; i++)
        {
            lightMap[i] = [];
            for(var j = 0; j < s.width; j++)
            {
                lightMap[i][j] = false;
            }
        }

        for(var i = 0; i < points.length; i++)
        {
            var p = points[i];
            
            if(!p.locationData.isCleared) continue;
            if(!map[p.y]?.[p.x]) continue;        //points outside map cannot set vision

            var coords = Dimension.getPointVision(p.x, p.y, s.width, s.height);

            for(var j = 0; j < coords.length; j++)
            {
                lightMap[coords[j][1]][coords[j][0]] = true;
            }
        }

        return lightMap;
    }

    createLightMap()
    {
        this.lightMap = Dimension.createLightMap(this.HexMap, this.Points);
    }

    static getPointVision(x, y, width, height)
    {
        var coords = [];

        coords.push([x, y]);
        coords.push([x-1, y]);
        coords.push([x+1, y]);

        coords.push([x, y-1]);

        coords.push([x, y+1]);
        coords.push([x-1, y+1]);
        coords.push([x+1, y+1]);



        coords.push([x, y+2]);

        if(x%2 == 0)
        {
            coords.push([x+1, y+2]);
            coords.push([x-1, y+2]);
        }
        else
        {
            coords.push([x+1, y-2]);
            coords.push([x-1, y-2]);  
        }

        coords.push([x, y-2]);

        
        coords.push([x+1, y-1]);
        coords.push([x-1, y-1]);

        coords.push([x-2, y]);
        coords.push([x+2, y]);

        coords.push([x-2, y+1]);
        coords.push([x+2, y-1]);

        coords.push([x-2, y-1]);
        coords.push([x+2, y+1]);

        var valid_coords = [];

        for(var i = 0; i < coords.length; i++)
        {
            var c = coords[i];

            if(c[0] < 0 || c[0] > width || c[1] < 0 || c[1] > height) continue;

            valid_coords.push(c);
        }

        return valid_coords;
    }

    static getHexMapSize(map)
    {
        var width = map[0].length;
        var height = map.length;

        return {width: width, height: height};
    }

    static getMapPointAtHex(x, y, points)
    {
        for(var i = 0; i < points.length; i++)
        {
            if(points[i].x == x && points[i].y == y) return points[i];
        }
    }

    getHexData(x, y)
    {
        return Dimension.getHexData(x, y, this.HexMap, this.Points, this.lightMap);
    }

    static getHexData(x, y, map, points, lightmap)
    {
        var hex = map[y][x];

        var isMapTile = hex;
        var isActiveMapTile = lightmap[y][x];
        var locationPoint = Dimension.getMapPointAtHex(x, y, points);

        return {isMapTile: isMapTile, isActiveMapTile: isActiveMapTile, locationPoint: locationPoint};
    }
}

class HexMapPoint
{
    constructor(x, y, locationData)
    {
        this.x = x;
        this.y = y;
        this.locationData = locationData;
    }
}class Location
{
	constructor()
	{
		this.Radius = 250;
		this.Rooms = 0;
		this.Name = "";
		this.ageInTicks = 0;

		this.Dimension = 'OVERWORLD';
		this.LocationFamily = 'none';	//location family is used to create locations order

		this.lightLevel = 1;
		this.lightSourcesRange = 1;
		this.lightSourcesStrength = 1;

		this.MapPos = {x: -100, y: -100};		//pozycja ikonki na mapie
		this.isVillage = false;					//czy jest wioska
		this.requiredLevel = 0;					//wymagany poziom
		this.reqPrevLocation = null;			//poprzednia lokacja wymagana do wejscia
		this.specialIcon = false;				//czy posiada specjalna ikonke

		this.allowMap = true;					//czy mozna wlaczyc mape lokacji
		this.canSave = true;					//czy automatycznie zapisywac po ukonczeniu pokoju

		this.Texture = 'bubble_large';
		this.TunnelTexture = 'bubble';
		this.TextureScale = 1;
		this.TextureAlpha = 1;

		this.alwaysShowBubbleTunnel = 
		{
			top: false,
			bottom: false,
			left: false,
			right: false
		};
	}

	GetAvailableDrop()
	{
		var drop = [];
		var types = this.RoomInfo.EntityTypes.concat(this.RoomInfo.BossTypes);
		var entity, lootTable, i, j, itemName;
		for(i = 0; i < types.length; i++)
		{
			entity = new World.EntityList[types[i]]();
			lootTable = entity.LootTable;

			for(j = 0; j < lootTable.itemList.length; j++)
			{
				itemName = lootTable.itemList[j].Type;
				drop.push(itemName);
			}
		}

		return drop;
	}

	canOpenPortal(){return true;}

	GetId()
	{
		return this.constructor.name;
	}

	GetDisplayName()
	{
		return Lang.Get(this.Name);
	}
	
	Update()
	{
		this.ageInTicks++;
		if(this.Rooms.length > 0)
		{
			var room = MathHelper.GetRoomByIndex(this.Rooms, this.Room);
			this.Rooms[room.y][room.x].Update();
		}
	}

	DefaultLocationLoad()
	{

		InGame.GUI.Map.WorldMapShowing = "LOCATION";

		if(this.BackgroundTheme)
		{
			SoundManager.Play(this.BackgroundTheme, "BACKGROUND");
		}

		var rooms = this.generateRooms(this.RoomInfo);
		this.Rooms = rooms.rooms;

		MathHelper.GetRoomByIndex(this.Rooms, rooms.startRoom).room.Enter();
		World.deep = World.MinimalDeep + MathHelper.GetRoomByIndex(this.Rooms, this.Room).y;
	}

	RenderGradient()
	{
		var pos = World.GetBackgroundPosition();

		var grd = ctx.createLinearGradient(pos.x, pos.y, 0, World.Height);
			grd.addColorStop(0, "lightblue");
			grd.addColorStop(0.5, "blue");
			grd.addColorStop(1, "black");

		ctx.save();
		ctx.fillStyle = grd;
		ctx.fillRect(-Camera.xView, -Camera.yView, World.Width, World.Height);
		ctx.restore();
	}

	RenderRoom()
	{
		var scale = this.TextureScale;
		var size = World.Radius * 2;
		var texture = TextureManager.Get(this.Texture);

		Graphic.DrawRotatedImage(ctx, texture, World.CenterPoint.x-Camera.xView, World.CenterPoint.y-Camera.yView, size, size, scale, 0, this.TextureAlpha);
	}
	
	Render()
	{
		this.RenderGradient();
		this.RenderRoom();

		if(World.currentRoom.isCleared && World.ageInTicks % 2 == 0)
		{
			var sides = World.currentRoom.GetSides();
			var center = World.CenterPoint;
			var r = World.Radius;
			var R = canvas.width / 2;
			var width = World.roomChangeTriggerRange * 2;
			var base_spd = 300;
			
			var count = 1;
			var margin = width / 2;
			var bubbles = [];
			var x, y;

			if(sides.left || this.alwaysShowBubbleTunnel.left)
			{
				x = margin + center.x - r;
				y = center.y + MathHelper.randomInRange(-width/2, width/2);
				bubbles.push({x, y, destX: x - R, destY: y});
			}


			if(sides.top || this.alwaysShowBubbleTunnel.top)
			{
				x = center.x + MathHelper.randomInRange(-width/2, width/2);
				y = margin + center.y - r;
				bubbles.push({x, y, destX: x, destY: y - R});
			}

			if(sides.right || this.alwaysShowBubbleTunnel.right)
			{
				x = -margin + center.x + r;
				y = center.y + MathHelper.randomInRange(-width/2, width/2);
				bubbles.push({x, y, destX: x + R, destY: y});
			}

			if(sides.bottom || this.alwaysShowBubbleTunnel.bottom)
			{
				x = center.x + MathHelper.randomInRange(-width/2, width/2);
				y = -margin + center.y + r;
				bubbles.push({x, y, destX: x, destY: y + R});
			}


			for(var i = 0; i < bubbles.length; i++)
			{
				var data = bubbles[i];
				var size = MathHelper.randomInRange(20, 50) / 100;
				var spd = base_spd * size * 2;

				Particle.Summon(this.TunnelTexture, data.x, data.y, data.destX, data.destY, size, spd, count, 50);
			}
		}
	}

	getLightLevelInfo()
	{
		if(this.lightLevel >= 1) return null;
		return new LightLevel(1 - this.lightLevel, this.lightSourcesRange, this.lightSourcesStrength);
	}

	onExit()
	{

	}


	Exit()
	{
		World.Boss = null;
		this.onExit();
	}


	generateRandomRooms(RoomInfo, roomsNumber, min_empty)
	{
		var rooms = [];
		var size = 1;

		while(true)
		{
			//Generowanie ilosci pokoi

			if(roomsNumber == 1) break;

			if(size * size > roomsNumber + min_empty)
			{
				break;
			}
			size ++;
		}

		for(var i = 0; i < size; i++)
		{
			//wypelnianie pokoi
			rooms[i] = [];
			for(var j = 0; j < size; j++)
			{
				rooms[i][j] = "room";
			}
		}
		

		//poczatkowy pokoj
		while(true)
		{
			var startRoom = MathHelper.randomInRange(0, (size * size) - 1);
			var pos = MathHelper.GetRoomByIndex(rooms, startRoom);
			
			var margin = size / 4;
			if((pos.x > margin && pos.x < size - margin && pos.y > margin && pos.y < size - margin) || (size < 5))
			{
				break;
			}
		}

		var startPos = {x: pos.x, y: pos.y};
		var emptyRooms = (size * size) - roomsNumber;
	
		var safe = 0;

		while(true)
		{
			for(var i = 0; i < size; i++)
			{
				//wypelnianie pokoi
				rooms[i] = [];
				for(var j = 0; j < size; j++)
				{
					rooms[i][j] = "room";
				}
			}
			rooms[startPos.y][startPos.x] = true;

			//dodawanie pustych pokoi
			var currentEmptyRooms = 0;
			while(true)
			{
				if(currentEmptyRooms >= emptyRooms)
				{
					break;
				}
				var room = MathHelper.randomInRange(0, (size * size) - 1);
				var side = MathHelper.GetRandomSide(Room.GetRoomsOnSides(rooms, room));
				pos = Room.GetRoomOnSide(room, side, rooms);

				if(rooms[pos.y][pos.x] == "room")
				{
					rooms[pos.y][pos.x] = "empty";
					currentEmptyRooms++;
				}
			}

		
			// safe++;
			var _copy = [];
			for(var i = 0; i < rooms.length; i++)
			{
				_copy[i] = [];
				for(var j = 0; j < rooms[i].length; j++)
				{
					_copy[i][j] = rooms[i][j];
				}
			}

			var iterations = Location.TestRooms(_copy, startPos) + 1;
			
			if((iterations == roomsNumber) || safe > 1000)
			{
				break;
			}
		}



		//generate boss chambers nad secret rooms

		var emptyChambersList = [];
		var bossChambersList = [];
		var bossChambersList2 = [];

		for(var i = 0; i < rooms.length; i++)
		{
			for(var j = 0; j < rooms[i].length; j++)
			{
				var room = rooms[i][j];
				if(room == "empty")
				{
					emptyChambersList.push([j, i]);
				}
				else if(room == "room")
				{
					var sides = Room.GetRoomsOnSides(rooms, {x: j, y: i});
					var emptyRoomsNear = 0;

					if(sides.top)
					{
						var _pos = Room.GetRoomOnSide({x: j, y: i}, SIDE.TOP, rooms);
						if(rooms[_pos.y][_pos.x] == "empty")
						{
							emptyRoomsNear++;
						}
					}
					else
					{
						emptyRoomsNear++;
					}

					if(sides.left)
					{
						var _pos = Room.GetRoomOnSide({x: j, y: i}, SIDE.LEFT, rooms);
						if(rooms[_pos.y][_pos.x] == "empty")
						{
							emptyRoomsNear++;
						}
					}
					else
					{
						emptyRoomsNear++;
					}

					if(sides.bottom)
					{
						var _pos = Room.GetRoomOnSide({x: j, y: i}, SIDE.BOTTOM, rooms);
						if(rooms[_pos.y][_pos.x] == "empty")
						{
							emptyRoomsNear++;
						}
					}
					else
					{
						emptyRoomsNear++;
					}

					if(sides.right)
					{
						var _pos = Room.GetRoomOnSide({x: j, y: i}, SIDE.RIGHT, rooms);
						if(rooms[_pos.y][_pos.x] == "empty")
						{
							emptyRoomsNear++;
						}
					}
					else
					{
						emptyRoomsNear++;
					}

					if(emptyRoomsNear == 3)
					{
						bossChambersList.push([j, i]);
					}
					else if(emptyRoomsNear == 2)
					{
						bossChambersList2.push([j, i]);
					}
				}
			}
		}

		for(var i = 0; i < RoomInfo.BossChambers; i++)
		{
			if(bossChambersList.length > 0)
			{
				var chamber = MathHelper.randomInRange(0, bossChambersList.length - 1);

				var bossChamber = bossChambersList[chamber];
				rooms[bossChamber[1]][bossChamber[0]] = "boss";
				bossChambersList.splice(chamber, 1);
			}
			else if(bossChambersList2.length > 0)
			{
				var chamber = MathHelper.randomInRange(0, bossChambersList2.length - 1);

				var bossChamber = bossChambersList2[chamber];
				rooms[bossChamber[1]][bossChamber[0]] = "boss";
				bossChambersList2.splice(chamber, 1);
			}
		}

		for(var i = 0; i < RoomInfo.SecretChambers; i++)
		{
			if(emptyChambersList.length > 0)
			{
				var isBossNear = 0;
				var isRoomNear = 0;
				var chamber = MathHelper.randomInRange(0, emptyChambersList.length - 1);
				var secretChamber = emptyChambersList[chamber];
				var currentChamber = {y: secretChamber[1], x: secretChamber[0]};
				var roomNear;


					roomNear = Room.GetRoomOnSide(currentChamber, SIDE.TOP, rooms).room;
					if(roomNear == "boss" || roomNear == "secret")
					{
						isBossNear++;
					}
					if(roomNear == "room" || roomNear == true)
					{
						isRoomNear++;
					}

					roomNear = Room.GetRoomOnSide(currentChamber, SIDE.LEFT, rooms).room;
					if(roomNear == "boss" || roomNear == "secret")
					{
						isBossNear++;
					}
					if(roomNear == "room" || roomNear == true)
					{
						isRoomNear++;
					}

					roomNear = Room.GetRoomOnSide(currentChamber, SIDE.BOTTOM, rooms).room;
					if(roomNear == "boss" || roomNear == "secret")
					{
						isBossNear++;
					}
					if(roomNear == "room" || roomNear == true)
					{
						isRoomNear++;
					}

					roomNear = Room.GetRoomOnSide(currentChamber, SIDE.RIGHT, rooms).room;
					if(roomNear == "boss" || roomNear == "secret")
					{
						isBossNear++;
					}
					if(roomNear == "room" || roomNear == true)
					{
						isRoomNear++;
					}


				if((isBossNear < 1) && (isRoomNear > 0) && (isRoomNear < 4))
				{
					rooms[currentChamber.y][currentChamber.x] = "secret";
				}
				else
				{
					i--;
				}
				emptyChambersList.splice(chamber, 1);
			}
		}

		return {rooms:rooms, startRoom:startRoom};
	}
	

	generateRooms(RoomInfo)
	{
		var roomsNumber = MathHelper.randomInRange(RoomInfo.MinRooms, RoomInfo.MaxRooms);
		var min_empty = roomsNumber / 2;

		//maksymalnie 100 pokojowe lokacje mozna wygenerowac
		if(roomsNumber > 100) roomsNumber = 100;
		
		var generatedRoomsData = this.generateRandomRooms(RoomInfo, roomsNumber, min_empty);
		var rooms = generatedRoomsData.rooms;
		var startRoom = generatedRoomsData.startRoom;


		//Konczenie
		var id = 0;
		for(var i = 0; i < rooms.length; i++)
		{
			for(var j = 0; j < rooms[i].length; j++)
			{
				var room = rooms[i][j];
				var entities = 0;

				if(RoomInfo.EntityTypes)
				{
					entities = MathHelper.randomInRange(RoomInfo.MinEntities, RoomInfo.MaxEntities);
				}

				if(room == "room")
				{
					//zwykly pokoj
					var radius = MathHelper.randomInRange(RoomInfo.MinRadius, RoomInfo.MaxRadius);
					var entitiesNumber = MathHelper.randomInRange(RoomInfo.MinEntities, RoomInfo.MaxEntities);
					var entities = [];

					if(RoomInfo.EntityTypes)
					{
						if(RoomInfo.EntityTypes.length > 0)
						{
							var types = [];
							var max  = RoomInfo.MaxEntityTypes < RoomInfo.EntityTypes.length ? RoomInfo.MaxEntityTypes : RoomInfo.EntityTypes.length;
							var typesNumber = MathHelper.randomInRange(RoomInfo.MinEntityTypes ?? 1, max ?? RoomInfo.EntityTypes.length);
							var k = 0;

							while(true)
							{
								var entityType = MathHelper.randomInRange(0, RoomInfo.EntityTypes.length - 1);
								var type = RoomInfo.EntityTypes[entityType];
								if(types.indexOf(type) == -1) types.push(type);
								if(types.length == typesNumber) break;
								k++;
							}

							for(k = 0; k < entitiesNumber; k++)
							{
								var entityType = k%(types.length);
								entities.push([types[entityType], false]);
							}
						}
					}

					var _room = new Room(id, radius, entities);
						if(RoomInfo.Titles)
						{
							_room.Title = RoomInfo.Titles.Room;
						}
						if(RoomInfo.Subtitles)
						{
							_room.Subtitle = RoomInfo.Subtitles.Room;
						}
						if(RoomInfo.onUpdates)
						{
							_room.onUpdate = RoomInfo.onUpdates.Room;
						}

					rooms[i][j] = _room;
				}
				else if(room == "boss")
				{
					//boss
					var radius = MathHelper.randomInRange(RoomInfo.MinRadius, RoomInfo.MaxRadius);
					var entities = [];

					if(RoomInfo.BossTypes)
					{
						if(RoomInfo.BossTypes.length > 0)
						{
							var bossType = MathHelper.randomInRange(0, RoomInfo.BossTypes.length - 1);

							var entityName = RoomInfo.BossTypes[bossType];
							entities.push([entityName, true]);
						}
					}

					var _room = new Room(id, radius, entities, false, true);
						if(RoomInfo.Titles)
						{
							_room.Title = RoomInfo.Titles.Boss;
						}
						if(RoomInfo.Subtitles)
						{
							_room.Subtitle = RoomInfo.Subtitles.Boss;
						}
						if(RoomInfo.onUpdates)
						{
							_room.onUpdate = RoomInfo.onUpdates.Boss;
						}

					rooms[i][j] = _room;
				}
				else if(room == "secret")
				{
					//secret room
					var radius = MathHelper.randomInRange(RoomInfo.MinRadius, RoomInfo.MaxRadius);

					var _room = new Room(id, radius, [], false, false, true);
						if(RoomInfo.Titles)
						{
							_room.Title = RoomInfo.Titles.Secret;
						}
						if(RoomInfo.Subtitles)
						{
							_room.Subtitle = RoomInfo.Subtitles.Secret;
						}
						if(RoomInfo.onUpdates)
						{
							_room.onUpdate = RoomInfo.onUpdates.Secret;
						}

					rooms[i][j] = _room;
				}
				else if(room == true)
				{
					//start

					var radius = MathHelper.randomInRange(RoomInfo.MinRadius, RoomInfo.MaxRadius);

					var _room = new Room(id, radius, [], true);
						if(RoomInfo.Titles)
						{
							_room.Title = RoomInfo.Titles.Start;
						}
						if(RoomInfo.Subtitles)
						{
							_room.Subtitle = RoomInfo.Subtitles.Start;
						}
						if(RoomInfo.onUpdates)
						{
							_room.onUpdate = RoomInfo.onUpdates.Start;
						}

					rooms[i][j] = _room;
				}
				else
				{
					rooms[i][j] = null;
				}

				id++;
			}
		}


		return {rooms: rooms, startRoom: startRoom};
	}

	static TestRooms(rooms, pos, iterations = 0)
	{
		var sides = Room.GetRoomsOnSides(rooms, pos);
		rooms[pos.y][pos.x] = null;

		//sprawdza czy pokoj sasiaduje z jakimkolwiek innym pokojem
		if(sides.top)
		{
			var room = Room.GetRoomOnSide(pos, SIDE.TOP);
			if(rooms[room.y][room.x] == "room")
			{
				iterations++;
				iterations = Location.TestRooms(rooms, room, iterations);
			}
		}

		if(sides.right)
		{
			var room = Room.GetRoomOnSide(pos, SIDE.RIGHT);
			if(rooms[room.y][room.x] == "room")
			{
				iterations++;
				iterations = Location.TestRooms(rooms, room, iterations);
			}
		}

		if(sides.bottom)
		{
			var room = Room.GetRoomOnSide(pos, SIDE.BOTTOM);
			if(rooms[room.y][room.x] == "room")
			{
				iterations++;
				iterations = Location.TestRooms(rooms, room, iterations);
			}
		}

		if(sides.left)
		{
			var room = Room.GetRoomOnSide(pos, SIDE.LEFT);
			if(rooms[room.y][room.x] == "room")
			{
				iterations++;
				iterations = Location.TestRooms(rooms, room, iterations);
			}
		}

		return iterations;
	}
	
	onLoad()
	{
		
	}
}class Room
{
	constructor(id, radius, entities = [], isStart = false, isBoss = false, isSecret = false)
	{
		this.id = id;
		this.Radius = radius;
		this.Entities = entities;
		this.isBossChamber = isBoss;
		this.isStartChamber = isStart;
		this.isSecretChamber = isSecret;
		this.Title = "";
		this.Subtitle = "";
		this.playerWasThere = false;
		this.isCleared = false;
		this.lastCleared = false;
		this.onUpdate = null;
		this.allowExpReward = true;

		this.SecretTheme = 'interface.SecretRoom';

		this.savedEntities = [];

		if(isStart || isSecret)
		{
			//nie wyswietla komunikatu po ukonczeniu poziomu
			this.isCleared = true;
			this.lastCleared = true;
		}

		this.spawnHeartChance = 50;
		this.summonedNPC = {};
	}

	Update()
	{
		if(isFunction(this.onUpdate))
		{
			this.onUpdate();
		}
		this.lastCleared = this.isCleared;
		this.isCleared = true;
		for(var i = 0; i < World.Entities.length; i++)
		{
			if(!World.Entities[i].isFromPlayer && 
				(!(World.Entities[i] instanceof Oxygen)) && 
				(!(World.Entities[i] instanceof EntityUpgrade)) && 
				(!World.Entities[i].isNPC) && 
				(!(World.Entities[i] instanceof EntityItem)) && 
				(World.Entities[i].mustBeKilled)
			)
			{
				this.isCleared = false;
				break;
			}
		}

		if(this.isCleared != this.lastCleared) this.UpdateNPC();

		if(this.isBossChamber && !this.Title)
		{
			if(World.Boss)
			{
				if(World.Boss.Title)
				{
					this.Title = World.Boss.Title;
					World.Location.Title = this.Title;
				}
				if(World.Boss.Subtitle)
				{
					this.Subtitle = World.Boss.Subtitle;
					World.Location.Subtitle = this.Subtitle;
				}
			}
		}

		World.Location.isCleared = this.isCleared;

		if(this.isCleared && !this.lastCleared)
		{
			World.Player.RunStats.setRoomInfo();
			
			var exp = World.Player.oxygenGainedInRoom;
			for(var i = 0; i < World.Entities.length; i++)
			{
				if(World.Entities[i] instanceof Oxygen)
				{
					var o = World.Entities[i];
					exp += Oxygen.GetOxygenValue(o.value, World.Player.stats.Level, o.level, o.isFromBoss);
				}
			}
			World.Location.Perfect = !World.Player.hurted;


			if(World.Location.Perfect && this.allowExpReward)
			{
				World.AddEntity(new Oxygen(World.CenterPoint.x, World.CenterPoint.y, Math.round(exp / 2), World.Player.stats.Level));

				if(MathHelper.GetChance(this.spawnHeartChance))
				{
					var value = MathHelper.randomInRange(1, 2);
					World.AddEntity(new Oxygen(World.CenterPoint.x, World.CenterPoint.y, value, 1, true));
				}
			}


			

			InGame.ShowTitle(true);

			if(this.isMobRush)
			{
				Upgrade.Spawn(World.Player, World.CenterPoint.x, World.CenterPoint.y);
			}

			//zabicie bossa powoduje ukonczenie lokacji
			if(this.isBossChamber)
			{
				World.Player.CompleteLocation(World.Location.constructor.name);
			}
		}
	}

	GetEntityLevels()
	{
		return getLocationLevel(World.Location);
	}

	UpdateNPC()
	{
		for(var i in this.summonedNPC)
		{
			this.summonedNPC[i].NoAI = false;
			console.log(this.summonedNPC[i]);
		}
	}

	GetNPCtoSummon()
	{
		var info = World.Location.RoomInfo.availableNPC;
		if(this.isStartChamber && info.Start) return info.Start;
		if(this.isBossChamber && info.Boss) return info.Boss;
		if(this.isSecretChamber && info.Secret) return info.Secret;
		if(info.Room) return info.Room;

		return null;
	}

	SummonNPC()
	{
		if(!World.Location.RoomInfo.availableNPC) return;

		var data = this.GetNPCtoSummon();
		if(!data) return;

		if(MathHelper.GetChance(data.chance))
		{
			var _constructor = World.EntityList[data.id];
			if(!isNPCMet(data.id) && !this.summonedNPC[data.id] && _constructor)
			{
				var npc = new _constructor(World.CenterPoint.x, World.CenterPoint.y);
				this.summonedNPC[data.id] = npc;
				this.summonedNPC[data.id].NoAI = true;
				World.Spawn(npc);
			}
		}
	}

	Enter()
	{
		if(isFunction(this.onEnter)) this.onEnter();

		if(!this.playerWasThere)
		{
			this.SummonNPC();

			if(this.isSecretChamber)
			{
				World.Player.RunStats.foundSecretRooms++;

				if(SoundManager.Playing.Background)
				{
					if((SoundManager.Playing.Background.name != this.SecretTheme) && !SoundManager.isPlayingBossTheme)
					{
						if(SoundManager.GetAudio(this.SecretTheme))
						{
							SoundManager.Play(this.SecretTheme, "BACKGROUND");
						}
					}
				}

				var chance = MathHelper.randomInRange(0, 100);
				if(chance < 5)
				{
					//boss
				}
				else if(chance < 15)
				{
					this.isCleared = false;
					this.lastCleared = false;
					this.isMobRush = true;

					//Mob Rush
					var RoomInfo = World.Location.RoomInfo;

					if(RoomInfo.EntityTypes)
					{
						if(RoomInfo.EntityTypes.length > 0)
						{
							var types = [];
							for(var k = 0; k < RoomInfo.MaxEntityTypes; k++)
							{
								var entityType = MathHelper.randomInRange(0, RoomInfo.EntityTypes.length - 1);
								types.push(RoomInfo.EntityTypes[entityType]);
							}

							for(var k = 0; k < RoomInfo.MaxEntities * 3; k++)
							{
								var entityType = MathHelper.randomInRange(0, types.length - 1);

								this.Entities.push([types[entityType], false]);
							}
						}
					}


				}
				else if(chance < 95)
				{
					// Upgrade.Spawn(World.Player, World.CenterPoint.x, World.CenterPoint.y);
				}
			}

			if(this.isStartChamber)
			{
				InGame.ShowTitle(true, World.Location.GetDisplayName());
			}
		}

		this.playerWasThere = true;
		World.Location.Room = this.id;
		World.currentRoom = this;
		World.Location.Radius = this.Radius;
		World.Location.Title = this.Title;
		World.Location.Subtitle = this.Subtitle;
		World.timeSinceLocationChange = 0;
		World.isPortalOpen = false;

		World.SetRadius(this.Radius);
		
		var y = MathHelper.GetRoomByIndex(World.Location.Rooms, this.id).y;
		World.deep = (World.MinimalDeep + y);

		if(World.Player)
		{
			World.Player.hurted = false;
			World.Player.oxygenGainedInRoom = 0;
			World.Player.movedInRoom = false;

			var wpn = World.Player.GetWeapon();
			if(wpn) wpn.Throws = 0;
		}

		//usuwa wszystkie pociski i czasteczki
		World.Kill(Projectile, true);
		if(!World.isChangingLocation) World.Kill(Particle, true);		//clear particles if player is not smoothly entering new room

		if(!this.isCleared)
		{
			for(var i = 0; i < this.Entities.length; i++)
			{
				
				var pos = MathHelper.getRandomPointInRange(World.CenterPoint, this.Radius - 150);
				var name = this.Entities[i][0];
				var isBoss = this.Entities[i][1];
				if(isBoss)
				{
					pos.x = World.CenterPoint.x;
					pos.y = World.CenterPoint.y;
				}

				var entity = new World.EntityList[name](pos.x, pos.y);
					entity.setLevel(this.GetEntityLevels());

				World.Spawn(entity);
			}
		}

		if(this.savedEntities.length > 0)
		{
			for(var i = 0; i < this.savedEntities.length; i++)
			{
				World.Entities.push(this.savedEntities[i]);
			}
		}
	}

	Quit()
	{
		this.savedEntities = [];

		for(var i = World.Entities.length - 1; i >= 0; i--)
		{
			if(World.Entities[i].isFromPlayer) continue;

			this.savedEntities.push(World.Entities[i]);
			World.Entities.splice(i, 1);
		}

		if(this.isSecretChamber)
		{
			if(SoundManager.Playing.Background)
			{
				if(SoundManager.Playing.Background.name == this.SecretTheme)
				{
					setTimeout(function(){SoundManager.Play(World.Location.BackgroundTheme, "BACKGROUND"); SoundManager.isPlayingBossTheme = false}, 2000);
				}
			}
		}

		if(World.Location.canSave) World.Player.Save();
	}

	static GetRoomsOnSides(rooms, position)
	{
		if(!isObject(position))
		{
			//podano index
			position = MathHelper.GetRoomByIndex(rooms, position);
		}

		var Sides = {top: false, bottom: false, right: false, left: false};

		if(rooms[position.y - 1])
		{
			if(rooms[position.y - 1][position.x]) Sides.top = true;
		}

		if(rooms[position.y + 1])
		{
			if(rooms[position.y + 1][position.x]) Sides.bottom = true;
		}

		if(rooms[position.y][position.x + 1]) Sides.right = true;
		if(rooms[position.y][position.x - 1]) Sides.left = true;

		return Sides;
	}

	static GetRoomPosition(rooms, room)
	{
		for(var i = 0; i < rooms.length; i++)
		{
			for(var j = 0; j < rooms[i].length; j++)
			{
				var r = rooms[i][j];
				if(r == room)
				{
					return {x: j, y: i};
				}
			}
		}
	}

	GetSides()
	{
		var rooms = World.Location.Rooms;
		var pos = Room.GetRoomPosition(rooms, this);
		return Room.GetRoomsOnSides(rooms, pos);
	}

	static GetRoomOnSide(position, side, rooms)
	{
		if(!isObject(position))
		{
			//podano index
			position = MathHelper.GetRoomByIndex(rooms, position);
		}

		var pos = {x: position.x, y: position.y};

		switch(side)
		{
			case SIDE.TOP:
				pos.y -= 1;
				break;

			case SIDE.RIGHT:
				pos.x += 1;
				break;

			case SIDE.BOTTOM:
				pos.y += 1;
				break;

			case SIDE.LEFT:
				pos.x -= 1;
				break;
		}

		pos.room = null;
		if(rooms)
		{
			if(rooms[pos.y])
			{
				pos.room = rooms[pos.y][pos.x];
			}
		}
		

		return pos;
	}
}class Tile
{
	constructor(texture, width = TileSize, height = TileSize)
	{
		this.Texture = texture;
		this.Width = width;
		this.Height = height;
		this.x = 0;
		this.y = 0;
	}
	
	Render()
	{		
		ctx.drawImage(TextureManager.Get(this.Texture), this.x - Camera.xView, this.y - Camera.yView, this.Width, this.Height);
	}
}class TriggerPoint
{
	constructor(x, y, radius, id, onActive, customTrigger)
	{
		this.x = x;
		this.y = y;
		this.id = id;

		this.Radius = radius;
		this.onActive = onActive;
		this.customTrigger = customTrigger;
		this.inRange = false;
	}

	Update(entity)
	{
		if(!entity) return;
		var call = false;
		var distance = MathHelper.GetDistance([this.x, this.y], [entity.x, entity.y]);
		this.inRange = false;
		if(distance <= this.Radius)
		{
			this.inRange = true;
		}

		if(isFunction(this.customTrigger))
		{
			call = this.customTrigger(entity);
		}
		else
		{
			call = this.inRange;
		}

		if(call && isFunction(this.onActive))
		{
			this.onActive(entity);
		}

	}

}class World
{
	static Initialize()
	{
		Camera.Initialize();
		this.Location;
		this.Players = [new Player()];
		this.Player = this.Players[0];
		this.PlayerEntities = [];
		this.Entities = [];
		this.Projectiles = [];
		this.Particles = [];
		this.MinimalDeep = 0;
		this.deep = 0;
		this.isChangingLocation = false;
		this.timeSinceLocationChange = 0;
		this.ageInTicks = 0;
		this.timeSinceRoomChange = 0;

		this.Border = 4000;
		this.HighestRadius = 2000;

		this.Width = (this.Border + this.HighestRadius) * 2;
		this.Height = (this.Border + this.HighestRadius) * 2;

		this.backgroundTranslateX = 0;
		this.backgroundTranslateY = 0;
		

		this.CenterPoint = {x: this.Width / 2, y: this.Height / 2};	

		this.currentRoom = null;
		this.isPortalOpen = false;
		this.portalGradient = null;

		this.BorderTrigger = new TriggerPoint(0, 0, 0, "BorderTrigger", function(entity)
		{
			if(!entity) return;
			if(!Main.BorderLess)
			{
				var motion = Motion.Get([entity.x, entity.y], [this.x, this.y], 1000);
				entity.ApplyMove(motion);
			}
		}, function()
		{
			if(!this.inRange && !World.isChangingLocation)
			{
				return true;
			}
			return false;
		});



		var method = function()
		{
			World.Location?.onBorderTrigger?.(this);
			if(!World.Location.isCleared) return;
			if(World.isChangingLocation) return;

			var currentRoom = MathHelper.GetRoomByIndex(World.Location.Rooms, World.Location.Room);
			var Sides = Room.GetRoomsOnSides(World.Location.Rooms, currentRoom);

			switch(this.id)
			{
				case "borderTrigger1":
					//right
					if((Sides.right) && World.Player.velocityX > 0)
					{
						var room = Room.GetRoomOnSide(currentRoom, SIDE.RIGHT);
						if(World.Location.Rooms[room.y][room.x])
						{
							World.changeLocation(SIDE.RIGHT);
						}
					}
					
					
					break;

				case "borderTrigger2":
					//down
					if((Sides.bottom) && World.Player.velocityY > 0)
					{
						var room = Room.GetRoomOnSide(currentRoom, SIDE.BOTTOM);
						if(World.Location.Rooms[room.y][room.x])
						{
							World.changeLocation(SIDE.BOTTOM);
						}
					}
					
					break;

				case "borderTrigger3":
					//left
					
					if((Sides.left) && World.Player.velocityX < 0)
					{
						var room = Room.GetRoomOnSide(currentRoom, SIDE.LEFT);
						if(World.Location.Rooms[room.y][room.x])
						{
							World.changeLocation(SIDE.LEFT);
						}
					}
					
					
					break;

				case "borderTrigger4":
					//top
					if((Sides.top) && World.Player.velocityY < 0)
					{
						var room = Room.GetRoomOnSide(currentRoom, SIDE.TOP);						
						if(World.Location.Rooms[room.y][room.x])
						{
							World.changeLocation(SIDE.TOP);
						}
					}

					break;
			}
		};

		var trigger = function(entity)
		{
			if( (entity instanceof Player) && (this.inRange))
			{
				return true;
			}
			return false;
		};

		this.roomChangeTriggerRange = 100;
		var triggersRange = this.roomChangeTriggerRange * 1.1;
		this.roomTrigger1 = new TriggerPoint(0, 0, triggersRange, "borderTrigger1", method, trigger);
		this.roomTrigger2 = new TriggerPoint(0, 0, triggersRange, "borderTrigger2", method, trigger);
		this.roomTrigger3 = new TriggerPoint(0, 0, triggersRange, "borderTrigger3", method, trigger);
		this.roomTrigger4 = new TriggerPoint(0, 0, triggersRange, "borderTrigger4", method, trigger);

		this.changeLocationTrigger = new TriggerPoint(this.CenterPoint.x, this.CenterPoint.y, 180, "test", function(player)
		{
			if(!player.isMoving)
			{
				var motion = Motion.Get([player.x, player.y], [this.x, this.y], 50);
				player.ApplyMove(motion);

				if(!player.isRecalling)
				{
					if(World.currentRoom.isStartChamber && World.Location.prevLocation)
					{
						Commands.GoToLocation(World.Location.prevLocation, 3);
					}
					else if(World.currentRoom.isBossChamber && World.currentRoom.isCleared && World.Location.nextLocation)
					{
						Commands.GoToLocation(World.Location.nextLocation, 3);
					}
				}
			}
		}, trigger);
	}

	static InitializeLocation(location)
	{
		this.LocationList = this.LocationList || {};
		var _class = new location();
		this.LocationList[_class.constructor.name] = _class;

		ItemHelper.InitLocationDrop(_class);
	}

	static InitializeDimension(dimension)
	{
		this.DimensionsList = this.DimensionsList || {};
		var _class = new dimension();
		this.DimensionsList[_class.constructor.name.toUpperCase()] = _class;
	}
	
	static RegisterEntity(entity)
	{
		this.EntityList = this.EntityList || {};
		this.EntityList[entity.name] = entity;
	}

	static changeLocation(Side)
	{
		if(Side)
		{
			this.currentChangeTime = 0;
			this.Side = Side;
			this.isChangingLocation = true;
			return;
		}

		var screenX = canvas.width * .66;		//position on screen
		var screenY = canvas.height * .66;		//position on screen
		// var changeTime = 1.5 * Main.FPS;
		
		this.currentChangeTime++;

		var spd = 1500;
		// var timeToChange = Math.round((spd / dist) * Main.FPS);
		var timeToChange = 45;
		var isChangeTick = (this.currentChangeTime == timeToChange);

		
		this.changeTime = timeToChange * 2;

		var nextPos = [];
		var motion;
		this.Player.allowMove = false;
		this.Player.allowControl = false;
		this.canChangeLocation = false;


		if(isChangeTick)
		{
			//w polowie drogi zmienia pozycje gracza oraz pokoj
			var currentRoomIndex = MathHelper.GetRoomByIndex(this.Location.Rooms, this.Location.Room);
			var nextRoomPos = Room.GetRoomOnSide(currentRoomIndex, this.Side);
			var nextRoom = this.Location.Rooms[nextRoomPos.y][nextRoomPos.x];

			this.currentRoom.Quit();
			nextRoom.Enter();
		}
		
		if(this.Side == SIDE.TOP)
		{
			motion = Motion.Get([this.Player.x, this.Player.y], [this.Player.x, 0], spd);

			if(isChangeTick) nextPos = [this.Player.x, (this.CenterPoint.y + this.Radius) + screenY];
		}
		else if(this.Side == SIDE.BOTTOM)
		{
			motion = Motion.Get([this.Player.x, this.Player.y], [this.Player.x, this.Height], spd);
			
			if(isChangeTick) nextPos = [this.Player.x, (this.CenterPoint.y - this.Radius) - screenY];
		}
		else if(this.Side == SIDE.RIGHT)
		{
			motion = Motion.Get([this.Player.x, this.Player.y], [this.Width, this.Player.y], spd);

			if(isChangeTick) nextPos = [(this.CenterPoint.x - this.Radius) - screenX, this.Player.y];
		}
		else if(this.Side == SIDE.LEFT)
		{
			motion = Motion.Get([this.Player.x, this.Player.y], [0, this.Player.y], spd);

			if(isChangeTick) nextPos = [(this.CenterPoint.x + this.Radius) + screenX, this.Player.y];
		}
		else
		{
			return;
		}

		this.Player.ApplyMove(motion);

		if(isChangeTick)
		{
			//w polowie drogi zmienia pozycje gracza oraz pokoj
			var oldX = this.Player.x;
			var oldY = this.Player.y;

			this.Player.x = nextPos[0];
			this.Player.y = nextPos[1];

			//tp particles
			for(var i = 0; i < this.Particles.length; i++)
			{
				var particle = this.Particles[i];
					particle.x += nextPos[0] - oldX;
					particle.y += nextPos[1] - oldY;
			}

			//reset laser rotation
			this.Player.laserRotation = null;

			return;
		}

		var distance = MathHelper.GetDistance([this.Player.x, this.Player.y], [this.CenterPoint.x, this.CenterPoint.y]);
		if((distance < this.Radius) && (distance < this.Radius - 30) && (this.currentChangeTime > timeToChange))
		{
			//zeby nie mrygal przy przechodzeniu po ukonczonych pokojach
			//aktywuje tarcze przy wejsciu do babla
			this.Player.timeInRoom = (!this.currentRoom.isCleared) ? 0 : this.Player.timeInRoom;
			this.timeSinceRoomChange = 0;
		}

		if((distance < this.Radius - 120) && (this.currentChangeTime > timeToChange))
		{
			this.isChangingLocation = false;
			this.Player.allowMove = true;
			this.Player.allowControl = true;
		}
	}

	static GetBackgroundPosition()
	{
		var x = this.backgroundTranslateX;
		var y = -Camera.yView - (this.deep * this.Height) + this.backgroundTranslateY;

		return {x, y};
	}
	
	static LoadMap(name, init)
	{
		if(init)
		{
			this.LocationList[name] = new this.LocationList[name].constructor();
		}
		this.Location = this.LocationList[name];

		//usuwa wszystkie byty z mapy
		this.Kill(Entity, true);

		if(isFunction(this.Location.onLoad))
		{
			this.Location.onLoad();
		}
		
		this.changeLocationTrigger.x = this.CenterPoint.x;
		this.changeLocationTrigger.y = this.CenterPoint.y;

		this.Player.totalDamageReceived = 0;
		this.Player.RunStats = this.Player.getDefaultRunStats();
		this.Player.Save();

		var tX = this.Location.startX ?? 0;
		var tY = this.Location.startY ?? 0;

		this.Player.timeInLocation = 0;
		this.Player.x = this.CenterPoint.x + tX;
		this.Player.y = this.CenterPoint.y + tY;
	}

	static SetRadius(r)
	{
		if(r > this.HighestRadius) this.Radius = this.HighestRadius;
		else this.Radius = r;
	}
	
	static Update()
	{
		this.ageInTicks++;
		this.timeSinceRoomChange++;

		if(this.Location)
		{
			this.Location.Update();
		}


		this.Player = this.Players[0];
		this.Player.timeInRoom++;
		if(this.Player.movedInRoom)
		{
			this.timeSinceLocationChange++;
		}

		if(this.isChangingLocation)
		{
			this.changeLocation();
		}

		this.triggerPoints = [];
		// var border_diff = 25;
		var border_diff = 0;
		this.BorderTrigger.x = this.CenterPoint.x;
		this.BorderTrigger.y = this.CenterPoint.y;
		this.BorderTrigger.Radius = this.Radius;

		
		var pos1 = MathHelper.lineToAngle([World.CenterPoint.x, World.CenterPoint.y], World.Radius - border_diff, 0);
		var pos2 = MathHelper.lineToAngle([World.CenterPoint.x, World.CenterPoint.y], World.Radius - border_diff, 90);
		var pos3 = MathHelper.lineToAngle([World.CenterPoint.x, World.CenterPoint.y], World.Radius - border_diff, 180);
		var pos4 = MathHelper.lineToAngle([World.CenterPoint.x, World.CenterPoint.y], World.Radius - border_diff, 270);

		this.roomTrigger1.x = pos1.x;
		this.roomTrigger1.y = pos1.y;

		this.roomTrigger2.x = pos2.x;
		this.roomTrigger2.y = pos2.y;

		this.roomTrigger3.x = pos3.x;
		this.roomTrigger3.y = pos3.y;

		this.roomTrigger4.x = pos4.x;
		this.roomTrigger4.y = pos4.y;

		this.triggerPoints[0] = this.BorderTrigger;
		this.triggerPoints[1] = this.roomTrigger1;
		this.triggerPoints[2] = this.roomTrigger2;
		this.triggerPoints[3] = this.roomTrigger3;
		this.triggerPoints[4] = this.roomTrigger4;

		if(this.currentRoom)
		{
			if(
				(this.currentRoom.isStartChamber && this.Location.prevLocation) || 
				(this.currentRoom.isBossChamber && this.currentRoom.isCleared && this.Location.nextLocation))
			{
				this.portalLocationName = (this.currentRoom.isBossChamber) ? this.Location.nextLocation : this.Location.prevLocation;

				//Portal otwiera sie 5 sekundy po wejsciu do lokacji
				if(this.timeSinceLocationChange > Main.FPS * 5 && this.Location.canOpenPortal())
				{
					if(!this.isPortalOpen)
					{
						this.portalTextTransition = new Transition(1, 0, 5);
					}
					this.isPortalOpen = true;
					this.triggerPoints.push(this.changeLocationTrigger);

					this.particleAngle = this.particleAngle || new Transition(0, 360, 2, false, 0, 0, true);
					// var angle = this.particleAngle.Update();
					// var count = 6;
					var angle = MathHelper.randomInRange(0, 360);
					var count = 1;

					if(this.ageInTicks % 2 == 0)
					{
						Particle.SummonCirclePattern(this.Location.TunnelTexture, this.changeLocationTrigger.x, this.changeLocationTrigger.y, 0.4, 100, count, 
							this.changeLocationTrigger.Radius - 30, angle, null, false);
					}
				}
			}
		}
		


		if(this.Location)
		{
			if(this.Location.triggerPoints)
			{
				this.triggerPoints = this.triggerPoints.concat(this.Location.triggerPoints);
			}
		}

		

		
		for(var i = this.Projectiles.length - 1; i >= 0 ; i--)
		{
			this.Projectiles[i].isOnScreen = isOnScreen(this.Projectiles[i]);
			this.Projectiles[i].Update();
		}
		
		for(var i = 0; i < this.Players.length; i++)
		{
			var entity = this.Players[i];
				entity.Update();

			for(var j = 0; j < this.triggerPoints.length; j++)
			{
				this.triggerPoints[j].Update(entity);
			}
		}
		
		Camera.Update(this.Player.x, this.Player.y, this.Player.posX, this.Player.posY);
		
		if(!this.Player.isAlive) return;

		for(var i = this.Entities.length - 1; i >= 0 ; i--)
		{
			var entity = this.Entities[i];
				entity.isOnScreen = isOnScreen(entity);
				entity.Update();
				

			// for(var j = 0; j < this.triggerPoints.length; j++)
			// {
			// 	this.triggerPoints[j].Update(entity);
			// }

			// var _x = entity.x;
			// var _y = entity.y;

			// var posX = _x - Camera.xView;
			// var posY = _y - Camera.yView;

			// if ((posX >= -100) && (posX <= canvas.width + 100) && (posY >= -100) && (posY <= canvas.height + 100))
			// {
				//Players[0].nearestEntities.Add(entity);
			// }
		}
	}

	static GetDifficultyLevel()
	{
		return this.Player.Difficulty;
	}
	
	static Spawn(entity)
	{
		if(entity instanceof Projectile)
		{
			this.AddProjectile(entity);
			return;
		}
		
		if(entity instanceof Particle)
		{
			this.AddParticle(entity);
			return;
		}
		
		if(entity instanceof Entity)
		{
			this.AddEntity(entity);
			return;
		}
	}
	
	static Kill(entity, all = false)
	{
		if(!all)
		{
			if(typeof entity !== "object") return;

			if(entity instanceof Projectile)
			{
				this.RemoveProjectile(entity);
				return;
			}
			
			if(entity instanceof Particle)
			{
				this.RemoveParticle(entity);
				return;
			}
			
			if(entity instanceof Entity)
			{
				this.RemoveEntity(entity);
				return;
			}
		}
		else
		{
			if(entity === Projectile)
			{
				this.Projectiles = [];
				return;
			}

			if(entity === Particle)
			{
				this.Particles = [];
				return;
			}

			if(entity === Entity)
			{
				this.Entities = [...this.PlayerEntities];
				return;
			}
		}
	}
	
	static AddEntity(entity, onTop = true)
	{
		if(onTop) this.Entities.push(entity);
		else this.Entities.unshift(entity);
		
		if(entity.isFromPlayer) this.PlayerEntities.push(entity);
		entity.onSummon();
	}
	
	static RemoveEntity(entity)
	{
		if(entity.isFromPlayer)
		{
			for(var i = 0; i < this.PlayerEntities.length; i++)
			{
				if(this.PlayerEntities[i] === entity)
				{
					this.PlayerEntities.splice(i, 1);
				}
			}
		}

		for(var i = 0; i < this.Entities.length; i++)
		{
			if(this.Entities[i] === entity)
			{
				this.Entities.splice(i, 1);
			}
		}
	}
	
	static AddProjectile(projectile)
	{
		this.Projectiles.push(projectile);
	}
	
	static RemoveProjectile(projetile)
	{
		for(var i = 0; i < this.Projectiles.length; i++)
		{
			if(this.Projectiles[i] === projetile)
			{
				this.Projectiles.splice(i, 1);
			}
		}
	}
	
	static AddParticle(particle)
	{
		this.Particles.push(particle);
	}
	
	static RemoveParticle(particle)
	{
		for(var i = 0; i < this.Particles.length; i++)
		{
			if(this.Particles[i] === particle)
			{
				this.Particles.splice(i, 1);
			}
		}
	}

	
	static Render()
	{
		if(!this.Location) return;

		this.deep = (this.deep < 0) ? 0 : this.deep;
		ChangeLayer(Graphic.Layer.Background);

			this.Location.Render();

			if(this.isPortalOpen)
			{
				var outerRadius = World.changeLocationTrigger.Radius - 60;

				var x = World.CenterPoint.x - Camera.xView;
				var y = World.CenterPoint.y - Camera.yView;
				var innerRadius = 10;

				var portal_gradient = ctx.createRadialGradient(x, y, innerRadius, x, y, outerRadius);
					portal_gradient.addColorStop(0, 'black');
					portal_gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');

				ctx.save();
				ctx.fillStyle = portal_gradient;
				ctx.fillRect(x - outerRadius, y - outerRadius, outerRadius * 2, outerRadius * 2);
				ctx.restore();
			}
			
			var title = " ";
			var subtitle = " ";

			if(this.Location)
			{
				title = this.Location.Title || " ";
				subtitle = this.Location.Subtitle || " ";
			}
			
			var alpha = 0.7;
			var multiplier = (this.isPortalOpen) ? this.portalTextTransition.Update() : 1;
			this.style = Style.GetStyleByName("stage");
			this.style.fontSize = 100 * multiplier;
			Style.FillText(ctx, this, Lang.Get(title), this.CenterPoint.x - Camera.xView, this.CenterPoint.y - (80 * multiplier)- Camera.yView, null, null, alpha);
		
			this.style.fontSize = 70 * multiplier;
			Style.FillText(ctx, this, Lang.Get(subtitle), this.CenterPoint.x -Camera.xView, this.CenterPoint.y + (40 * multiplier)- Camera.yView, null, null, alpha);
		
		RestoreLayer();
		

		ChangeLayer(Graphic.Layer.Main);

		for(var i = 0; i < this.Projectiles.length; i++)
		{
			if(!this.Projectiles[i].isOnScreen && !this.Projectiles[i].alwaysRender) continue;
			this.Projectiles[i].Render(ctx);
		}

		for(var i = 0; i < this.Players.length; i++)
		{
			this.Players[i].Render(ctx);
		}
		
		for(var i = 0; i < this.Entities.length; i++)
		{
			if(!this.Entities[i].isOnScreen && !this.Entities[i].alwaysRender) continue;
			this.Entities[i].Render(ctx);
		}

		RestoreLayer();




		ChangeLayer(Graphic.Layer.Particle);

			ctx.save();
			ctx.clearRect(0, 0, canvas.width, canvas.height);
			ctx.globalCompositeOperation = "destination-over";

			for(var i = this.Particles.length - 1; i >= 0 ; i--)
			{
				this.Particles[i].isOnScreen = isOnScreen(this.Particles[i]);
				this.Particles[i].Render(ctx);
			}

			ctx.restore();

		

		if(Main.ShowHitbox)
		{
			for(var i = 0; i < this.triggerPoints.length; i++)
			{
				var x = this.triggerPoints[i].x - Camera.xView;
				var y = this.triggerPoints[i].y - Camera.yView;

				ctx.save();
				ctx.strokeStyle = "red";
				ctx.fillRect(x - 1, y - 1, 2, 2);

				ctx.beginPath();
				ctx.arc(x, y, this.triggerPoints[i].Radius, 0, 2 * Math.PI);
				ctx.stroke();
				ctx.restore();
			}
		}

		RestoreLayer();

		if(this.isPortalOpen)
		{
			var distance = MathHelper.GetDistance([this.CenterPoint.x - Camera.xView, this.CenterPoint.y - Camera.yView], [Mouse.x, Mouse.y]);
			if(distance <= outerRadius / 2)
			{
				this.style = Style.GetStyleByName();
				var name = (this.LocationList[this.portalLocationName]) ? this.LocationList[this.portalLocationName].GetDisplayName() : " ";
				Style.FillText(ctx, this, name, this.CenterPoint.x - 16 - Camera.xView, this.CenterPoint.y - Camera.yView + (outerRadius / 2));
			}
		}


		var LightLevelInfo = this.Location.getLightLevelInfo();
		if(LightLevelInfo) 
		{
			Graphic.addLightSource(Mouse.x, Mouse.y, 100);
			Graphic.RenderLightLevelShader(LightLevelInfo);
		}
	}
}class AnimationBase
{
    constructor(model, data = [], duration = 1, triggerFunction = function(){return true}, keepLastValues = true)
    {
        this.Model = model;
        this.Owner = model.Owner;
        this.Duration = duration * Main.FPS;
        this.ageInTicks = 0;
        this.Data = data;
        this.triggerFunction = triggerFunction;
        this.Progress = 0;
        this.keepLastValues = keepLastValues;

        this.completeAt = 1;
        this.revertAt = null;
        this.FreezeAnimation = false;
        this.resetParts = true;
        this.iteration = 0;
        this.iterations = 1;
        this.lastDuration = this.Duration;

        this.setAnimationSpacing(this.completeAt, this.revertAt);
    }

    setAnimationSpacing(completeAt = 1, revertAt = null)
    {
        if(revertAt == null) revertAt = 1 - completeAt;
        this.completeAt = completeAt;
        this.revertAt = revertAt;

        var d = this.getAnimationDuration();

        this.ticksToComplete = d * this.completeAt;
        this.ticksToRevert = d * this.revertAt;
    }

    getAnimationDuration()
    {
        return this.Duration;
    }

    setAnimationDuration(duration)
    {
        this.Duration = Math.ceil(duration);
        this.lastDuration = this.Duration;
    }

    Update()
    {
        if(!this.triggerFunction?.(this)) 
        {
            if(this.ageInTicks == 0) return;

            //if animation cannot be played reset it
            if(!this.FreezeAnimation) 
            {
                this.ageInTicks = 0;
                if(this.resetParts) this.ResetParts();
            }
            return;
        }
        var reverting = false;
        var duration = this.getAnimationDuration();
        this.ageInTicks++;
        this.Progress = this.ageInTicks / duration;

        if(this.lastDuration != duration)
        {
            this.setAnimationSpacing(this.completeAt, this.revertAt);
            this.Progress = this.ageInTicks / this.lastDuration;
            this.ageInTicks = Math.floor(duration * this.Progress);       //set ticks to match new duration
        }

        if(this.ageInTicks == duration)
        {
            this.iteration++;
            this.ageInTicks = -1;
            return;
        }
        if(this.ageInTicks > duration && (this.iterations != 'INFINITE' && this.iteration >= this.iterations)) return;
  

        var animation_progress = this.Progress;
        if(this.ageInTicks <= this.ticksToComplete)
        {
            animation_progress = this.ageInTicks / this.ticksToComplete;
        }
        if(this.ageInTicks >= this.ticksToRevert && this.revertAt)
        {
            var step = duration - this.ticksToRevert;
            var p = (this.ageInTicks - this.ticksToRevert) / step;
            animation_progress = 1 - p;
            reverting = true;
        }

        //freeze animation beetwen complete and revert
        if(this.ageInTicks > this.ticksToComplete && this.revertAt && this.ageInTicks < this.ticksToRevert) return;

        for(var i in this.Data)
        {
            var data = this.Data[i];
            var part = data.partName;
            var property = data.propertyName;
            var to_move = data.To - data.From;
            var p = animation_progress;

            if(data.Direction == -1) p = 1 - animation_progress;
            var step = to_move * p;

            if(property == 'Rotation') property = 'selfRotation';
            set(this.Model.Parts[part], property, data.From+step, true);
        }

        this.lastDuration = duration;
    }

    ResetParts()
    {
        for(var i in this.Data)
        {
            var data = this.Data[i];
            var part = this.Model.Parts[data.partName];

            part.ResetProperties();
        }
    }


    ApplyRotation(partName, rotation)
    {
        this.Model.Parts[partName].selfRotation = rotation;
    }

    ApplyTransform(partName, x, y)
    {
        this.Model.Parts[partName].Transform.x = x;
        this.Model.Parts[partName].Transform.y = y;
    }

    ResetElementProperties(partName)
    {
        this.Model.Parts[partName].ResetProperties();
    }

    ApplyTransform(partName, transformX, transformY)
    {
        this.Model.Parts[partName].Transform = {x: transformX, y: transformY};
    }

}

class AnimationData
{
    constructor(partName, propertyName, from, to, direction = 1)
    {
        this.partName = partName;
        this.propertyName = propertyName;
        this.From = from;
        this.To = to;
        this.Direction = direction;
    }
}

class AnimationInfo
{
    constructor(data, owner, id)
    {
        this.owner = owner;
        this.id = id;
        this.cancelAble = true;
        this.Frames = 0;
        this.FrameDelay = 1;
        this.Frame = 0;
        this.FrameDirection = 1;
        this.TimeInTicks = 0;
        this.LoopMode = LOOP.BREAK;

        this.onAnimationEnd = null;
        this.onBreak = null;

        if(data)
        {
            if(isObject(data))
            {
                for(var property in data)
                {
                    this[property] = data[property];
                }
            }
        }
    }

    Update()
    {
        this.TimeInTicks++;

        //co ile klatek animacja ma byc aktualizowana
        if(this.TimeInTicks % this.FrameDelay == 0)
        {
            if(this.owner && this.id)
            {
                if(typeof this.owner[this.id] === "function")
                {
                    this.owner[this.id]();
                }
            }

            this.Frame += 1 * this.FrameDirection;
            if( (this.Frame > this.Frames - 1) || (this.Frame == -1))
            {
                switch(this.LoopMode)
                {
                    case LOOP.BREAK:
                        if(this.onAnimationEnd)
                        {
                            this.onAnimationEnd();
                        }
                        this.Break();
                        break;

                    case LOOP.RETURN:
                        this.FrameDirection *= -1;
                        this.Frame = (this.Frame == -1) ? 1 : this.Frame - 2;
                        break;

                    case LOOP.CONTINUE:
                        this.Frame = 0;
                        break;
                }
            }
        }
    }
}class ItemModel
{
	constructor(texture, width = null, height = null, scale = null, tX = null, tY = null, onUpdate)
	{
		this.Texture = texture;
		this.Scale = scale;
		this.Width = width;
		this.Height = height;
		this.Translation =
		{
			x: tX,
			y: tY
		};
		this.onUpdate = onUpdate;
		this.frame = 0;
		this.frames = 1;
	}
}


function itemCannonUpdate(owner)
{
	var _texture = (typeof this.Texture === "string") ? TextureManager.Get(this.Texture) : this.Texture;
	this.frames = _texture.height / this.Height;
	this.frame = Math.round((this.frames - 1) * owner.attackGauge);
}class ModelBase
{
	constructor(owner, textureFamily = '', autoFitTexture = false)
	{
		this.textureFamily = textureFamily;
		this.autoFitTexture = autoFitTexture;
		
		this.Width = 64;
		this.Height = 64;

		this.Scale = 1.0;
		this.Mirrored = false;
		this.visible = true;

		this.Offset = {x: 0, y: 0};
		this.x = 0;
		this.y = 0;

		this.endX = 0;
		this.endY = 0;

		this.Rotation = 0;
		this.selfRotation = 0;

		this.Parts = {};
		this.RenderOrder = null;
		this.MirrorOrder = null;
		this.Owner = owner;
		this.Animations = {};
		this.ArmorModel = null;

		this.EquipsParts = [];
		this.Transparency = 1.0;
	}

	Update(noAnimation = false)
	{
		this.Rotation = this.selfRotation + this.Owner.Rotation;

		this.scale = this.Scale * Camera.Scale * this.Owner.Scale;
		this.Transparency = this.Owner.Transparency;

		this.x = this.Owner.x - (this.Offset.x * this.scale) - Camera.xView;
		this.y = this.Owner.y - (this.Offset.y * this.scale) - Camera.yView;

		this.endX = this.x;
		this.endY = this.y;

		if(!noAnimation)
		{
			for(var i in this.Animations) this.Animations[i].Update();
		}

		for(var part in this.Parts)
		{
			if(this.Parts[part].Parent == null)
			{
				this.Parts[part].Update(this);
			}
		}

		
	}

	ApplyArmorModel(armor_model)
	{
		if(armor_model)
		{
			this.ArmorModel = new armor_model(this);
		}  
	}

	ApplyModelAnimation(animation)
	{
		if(animation)
		{
			var name = animation.name;
			this.Animations[name] = new animation(this);
		}
	}

	UpdateEquipParts()
	{
		var equips = this.Owner.equips;

		for(var slot in equips)
		{
			var item = this.Owner.equips[slot];
			if(this.EquipsParts[slot])
			{
				if(item)
				{
					this.EquipItem(this.EquipsParts[slot], item);
				}
				else
				{
					this.EquipsParts[slot].visible = false;
				}
			}
		}
	}

	EquipItem(part, item)
	{
		var itemModel = JSON.parse(item.Model);

		if(part)
		{
			part.visible = true;
			for(var property in itemModel)
			{
				if(property != "Scale" && property != "Rotation")
				{
					part[property] = itemModel[property];
				}
			}

			if(!itemModel.Width)
			{
				part.Width = TextureManager.Get(itemModel.Texture).width;
			}
			if(!itemModel.Height)
			{
				part.Height = TextureManager.Get(itemModel.Texture).height;
			}

			if(!itemModel.TextureWidth)
			{
				part.TextureWidth = TextureManager.Get(itemModel.Texture).width;
			}
			if(!itemModel.TextureHeight)
			{
				part.TextureHeight = TextureManager.Get(itemModel.Texture).height;
			}

			if(itemModel.Rotation)
			{
				part.selfRotation = itemModel.Rotation;
			}

			if(itemModel.Scale)
			{
				part.RotationOffset.x *= itemModel.Scale;
				part.RotationOffset.y *= itemModel.Scale;

				part.Transform.x = itemModel.Scale * 100;
				part.Transform.y = itemModel.Scale * 100;
			}
		}
	}

	Render(context)
	{
		if(!this.RenderOrder)
		{
			this.RenderOrder = this.GetRenderOrder();
			this.MirrorOrder = this.GetRenderOrder(true);
		}

		if(this.visible)
		{
			if(this.Mirrored)
			{
				for(var part in this.MirrorOrder)
				{
					this.MirrorOrder[part].Render(context);
				}
			}
			else
			{
				for(var part in this.RenderOrder)
				{
					this.RenderOrder[part].Render(context);
				}
			}
		}
	}

	GetRenderOrder(mirrored)
	{
		var order = [];
			
		for(var part in this.Parts)
		{
			if(this.Parts[part] != null)
			{
				if(mirrored)
				{
					order[this.Parts[part].mirrorIndex] = this.Parts[part];
				}
				else
				{
					order[this.Parts[part].renderIndex] = this.Parts[part];
				}
			}
		}
			
		return order;
	}

}class Part
{
	constructor(width, height, length, offsetX, offsetY)
	{
		this.x = 0;
		this.y = 0;
		this.endX = 0;
		this.endY = 0;

		this.Offset = {x: offsetX, y: offsetY};

		this.RotationOffset = {x: 0, y: 0};
		this.Rotation = 0;
		this.selfRotation = 0;
		this.lockRotation = false;

		this.Width = width;
		this.Height = height;
		this.Scale = 1.0;
		this.length = length;
		this.Axis = "y";
		this.visible = true;

		this.Mirrored = false;

		this.Texture = "";
		this.TextureWidth = 0;
		this.TextureHeight = 0;
		this.TextureOffset = {x: 0, y: 0};
		this.TextureTranslation = {x: 0, y: 0};
		this.TextureFlip = {x: 0, y: 0};
		this.FlipTextureOnMirror = true;
		this.useTexturesFamily = true;
	
		this.Parent = null;
		this.Childs = [];
		this.ArmorChilds = [];

		this.Transform = {x: 100, y: 100};
		this.Transparency = 1.0;
		this.Model;

		this.SaveDefaultProperties();
	}

	Update(model)
	{
		this.Model = model;
		this.Scale = model.scale;
		this.Mirrored = model.Mirrored;

		var _parent = (this.Parent) ? this.Parent : model;
		var lengthAcrossDiff = 0;

		this.x = _parent.endX;
		this.y = _parent.endY;

		if(this.Axis == "y")
		{
			lengthAcrossDiff = 90;
			this.length = this.Height * this.Transform.y / 100 - (2 * this.RotationOffset.y);
		}
		else
		{
			this.length = this.Width * this.Transform.x / 100 - (2 * this.RotationOffset.x);
		}

		if(this.lockRotation)
		{
			this.Rotation = this.selfRotation;					
		}
		else
		{
			this.Rotation = this.selfRotation + _parent.Rotation;
		}

		if(this.Mirrored)
		{
			var endX = (MathHelper.lineToAngle([this.x, this.y], (this.length * this.Scale), this.Rotation + lengthAcrossDiff)).x;
			var distance2 = -(this.x - endX);
			this.endX = this.x - distance2;
		}
		else
		{
			this.endX = (MathHelper.lineToAngle([this.x, this.y], (this.length * this.Scale), this.Rotation + lengthAcrossDiff)).x;
		}

		this.endY = (MathHelper.lineToAngle([this.x, this.y], (this.length * this.Scale), this.Rotation + lengthAcrossDiff)).y;


		for(var child in this.ArmorChilds)
		{
			this.ArmorChilds[child].Transform = this.Transform;
		}

		for(var child in this.Childs)
		{
			this.Childs[child].Update(model);
		}
	}

	Render(context)
	{
		if(this.visible)
		{
			var _textureFlip = [this.TextureFlip.x, this.TextureFlip.y];
			var lengthAcrossDiff = 180;

			var textureW = this.TextureWidth;
			var textureH = this.TextureHeight;

			var src = this.Model.textureFamily+this.Texture;
			if(!this.useTexturesFamily) src = this.Texture
			var texture = TextureManager.Get(src);

			if(this.Model.autoFitTexture)
			{
				var textureW = texture.width;
				var textureH = texture.height;
			}
			

			if(this.Axis == "y")
			{
				lengthAcrossDiff = 90;
			}

			if(this.Mirrored)
			{
				this.Rotation = MathHelper.getAngle2([this.x, this.y], [this.endX, this.endY]) - lengthAcrossDiff;
				
				if(this.FlipTextureOnMirror)
				{
					_textureFlip[0] *= -1;
				}
			}

			var txTranslation = {x: 0, y: 0};

			txTranslation.x = this.TextureTranslation.x;
			txTranslation.y = this.TextureTranslation.y;

			if(_textureFlip[1] == -1) txTranslation.y += (this.Height * this.Transform.y / 100) - (2 * this.RotationOffset.y);
			
			if(this.Transform.x != 100 && this.TextureTranslation.x != 0)
			{
				txTranslation.x = this.TextureTranslation.x + (textureW * (this.Transform[0] - 100) / 100);
			}

			if(this.Transform.y != 100 && this.TextureTranslation.y != 0)
			{
				txTranslation.y = this.TextureTranslation.y + (textureH * (this.Transform[1] - 100) / 100);
			}

			var alpha = this.Transparency * this.Model.Transparency;

			context.save();
			context.translate(this.x, this.y);
			context.rotate(this.Rotation * Math.PI/180);
			context.scale(_textureFlip[0], _textureFlip[1]);
			context.globalAlpha = alpha;
			context.drawImage(
				texture, this.TextureOffset.x, this.TextureOffset.y, textureW, textureH,
				-(this.RotationOffset.x * this.Scale) - txTranslation.x * this.Scale, -(this.RotationOffset.y * this.Scale) - txTranslation.y * this.Scale,
				(this.Width * this.Transform.x / 100 * this.Scale), (this.Height * this.Transform.y / 100 * this.Scale)
			);
			context.restore();

			for(var child in this.ArmorChilds)
			{
				this.ArmorChilds[child].Render(context);
			}

		}
	}

	/**
	 * 
	 * @param {Instance} itemSlot ITEM_SLOT
	 */
	BindItemSlot(itemSlot, model)
	{
		model.EquipsParts[itemSlot] = this;

		this.SaveDefaultProperties();
	}

	SetRotation(rotation, RotOffsetX = 0, RotOffsetY = 0)
	{
		this.selfRotation = rotation;
		this.RotationOffset = {x: RotOffsetX, y: RotOffsetY};

		this.SaveDefaultProperties();
	}

	SetTexture(texture, width, height, useTexturesFamily = true)
	{
		this.Texture = texture;
		this.TextureWidth = width;
		this.TextureHeight = height;
		this.useTexturesFamily = useTexturesFamily;

		this.SaveDefaultProperties();
	}

	SetTextureRender(_renderIndex, _mirrorIndex, translationX = 0, translationY = 0, offsetX = 0, offsetY = 0, flipX = 1, flipY = 1, flipOnMirror = true)
	{
		this.renderIndex = _renderIndex;
		this.mirrorIndex = _mirrorIndex;
		this.TextureTranslation.x = translationX;
		this.TextureTranslation.y = translationY;
		this.TextureOffset.x = offsetX;
		this.TextureOffset.y = offsetY;
		this.TextureFlip = {x: flipX, y: flipY};
		this.FlipTextureOnMirror = flipOnMirror;

		this.SaveDefaultProperties();
	}

	AddChild(child, armor)
	{
		if(child != this)
		{
			//Part cannot be Parent for himself
			child.Parent = this;
			this.Childs.push(child);
			if(armor)
			{
				this.ArmorChilds.push(child);
			}
		}

		this.SaveDefaultProperties();
	}

	SaveDefaultProperties()
	{
		var _default = {};

		var excluded = 'ArmorChilds/Childs/Default/Parent/mirrorIndex/renderIndex/x/y/endX/endY';

		for(var property in this)
		{
		   if(!excluded.includes(property))
		   {
				var value = this[property];

				set(_default, 'Default.'+property, value, true);
		   }
		}

		this.Default = JSON.parse(JSON.stringify(_default));
	}

	ResetProperties()
	{
		var _default = JSON.parse(JSON.stringify(this.Default));
		for(var property in _default)
		{
			this[property] = _default[property];
		}
	}
}class AppearanceGUI
{
    static Open()
    {
        this.CtxList = {};
        this.PreviewList = {};
        this.SkinPreviews = {};
        this.PreviewWidth = 0;
        this.PreviewHeight = 0;

        this.ScrollToPosition = 0;
        this.isScrolling = false;
        this.ScrollDuration = .25;
        this.ScrollStart = 0;

        this.Dummy = new PlayerDummy(World.Player);

        this.isOpen = true;

        this.CreateSkinList();
    }

    static Close()
    {
        this.isOpen = false;
    }

    static Update()
    {
        if(!this.isOpen) return;

        this.Dummy.x = this.PreviewWidth / 2 + Camera.xView;
        this.Dummy.y = this.PreviewHeight * .65 + Camera.yView;
        this.Dummy.Appearance.Scale = 2;

        this.ScrollUpdate();

        var i = 0;
        var scroll = document.querySelector('#skins').scrollLeft;
        var step = this.GetSkinScrollStep();
        var s, pos, diff;
        var skins = document.querySelector('#skins').querySelectorAll('.skin');
        var current = -1;
        var lockLeft = false;
        var lockRight = false;

        skins.forEach(e => 
            {
                pos = step * (i-1);
                diff = Math.abs(scroll - pos);
                s = 1 - (diff / 2000);
                if(s < .8) s = .8;
                if(s > 1) s = 1;

                e.style.transform = 'scale('+s+')';
                
                var c = (World.Player.Appearance.Skin == e.dataset.id) ? 'true' : 'false';
                e.dataset.current = c;

                if(s >= .98) 
                {
                    e.dataset.selected = 'true';
                    AppearanceGUI.selected = e;
                    current = i;
                }
                else e.dataset.selected = 'false';

                i++;

                if(e.className.includes('empty')) return;

                var name = Lang.Get(AppearanceGUI.SkinPreviews[e.dataset.id]?.Name);

                this.PreviewList[e.dataset.id].dataset.variant = '-1';
                var variants = Player.Skins[e.dataset.id]?.Variants;

                if(variants && variants.length > 0)
                {
                    for(var j = -1; j < variants.length; j++)
                    {
                        var v = variants[j] || null;
                        var div = e.querySelector('.variant[data-variant="'+j+'"]');

                        div.dataset.current = 'false';
                        if(v)
                        {
                            if(World.Player.Appearance.Skin == v.name) 
                            {
                                div.dataset.current = 'true';
                                e.dataset.current = 'true';
                                this.PreviewList[e.dataset.id].dataset.variant = j;
                                name = Lang.Get(AppearanceGUI.SkinPreviews[v.name]?.Name);
                            }
                        }
                        else
                        {
                            div.dataset.current = c;
                        }
                    }
                }
                
                set(document.querySelector('.skin[data-id="'+e.dataset.id+'"] .nav_bottom'), 'innerText', name, true);
            });

        if(current == 1) lockLeft = true;
        if(current == i-2) lockRight = true;

        set('#appearance .slider_arrow.left', 'dataset.locked', lockLeft, true);
        set('#appearance .slider_arrow.right', 'dataset.locked', lockRight, true);
    }

    static Scroll(position, ignoreAnimation = false)
    {
        this.ScrollToPosition = position;
        this.isScrolling = true;
        this.ScrollStart = Main.ageInTicks;

        this.ScrollUpdate(ignoreAnimation);
    }

    static GetCurrentScrollPos()
    {
        var scroll = document.querySelector('#skins').scrollLeft;
        return Math.round(scroll / this.GetSkinScrollStep());
    }

    static GetSkinScrollStep()
    {
        return (getCssVariable('#appearance', '--skin-block-width', true) + 2 * (getCssVariable('#appearance', '--skin-block-margin', true))) * Settings.Video.UI_Scale / 100;
    }

    static ScrollUpdate(ignoreAnimation)
    {
        if(!this.isScrolling) return;

        var progress = (Main.ageInTicks - this.ScrollStart) / (Main.FPS * this.ScrollDuration);

        if(progress > 1) 
        {
            this.isScrolling = false;
            return;
        }

        var container = document.querySelector('#skins');
        if(progress == 0) this.scrollFrom = container.scrollLeft;

        var step_size = this.GetSkinScrollStep();
        var scrollTo = (this.ScrollToPosition -1) * step_size;
        var scrollDiff = this.scrollFrom - scrollTo;

        var p = 1 - Math.pow(1 - progress, 1.675);
        if(ignoreAnimation) p = 1;

        var new_pos = this.scrollFrom - (scrollDiff * p);
        container.scrollLeft = new_pos;

        if(new_pos == scrollTo)
        {
            this.isScrolling = false;
            return;
        }
    }

    static Render()
    {
        if(!this.isOpen) return;

        for(var name in this.PreviewList)
        {
            var skin_name = name;
            var _canvas = this.PreviewList[name];
            var _ctx = this.CtxList[name];

            if(_canvas.dataset.variant != '-1')
            {
                var s = Player.Skins[name]?.Variants[_canvas.dataset.variant];
                if(s) skin_name = s.name;
            }
            var skin = this.SkinPreviews[skin_name];

            _ctx.clearRect(0, 0, _canvas.width, _canvas.height);
            skin.Render(_ctx, this.Dummy);
        }
    }

    static SkinListArrowsClick()
    {
        if(DraggableScroll.Scrolling) return;

        var pos = AppearanceGUI.GetCurrentScrollPos() + 1;
        var s = parseInt(this.dataset.step);
        pos += s;
        AppearanceGUI.Scroll(pos);
    }

    static ChangeSkinVariant()
    {
        var skin = Player.Skins[this.dataset.name];
        if(!skin) return;

        var variant = skin.Variants[this.dataset.variant];
        if(this.dataset.variant == -1) variant = skin;
        if(!variant) return;

        World.Player.ChangeSkin(variant.name);
    }

    static CreateSkinList()
    {
        var container = document.getElementById('skins');
            container.innerHTML = '';

        var list = document.createElement('span');
            list.id = 'skin_list';
            list.addEventListener('wheel', function(e)
            {
                var pos = AppearanceGUI.GetCurrentScrollPos() + 1;
                if(e.deltaY > 0) pos += 1;
                else pos -= 1;
                AppearanceGUI.Scroll(pos);
            });
            container.appendChild(list);

        var skins = Player.Skins;
        var available = World.Player.Appearance.AvailableSkins;

        var canvas_width = getCssVariable('#appearance', '--skin-block-canvas-width', true);
        var canvas_height = getCssVariable('#appearance', '--skin-block-canvas-height', true);

        this.PreviewWidth = canvas_width;
        this.PreviewHeight = canvas_height;
        var i = 1;
        var current = 0;

        var skin_container = document.createElement('div');
            skin_container.className = 'skin empty';
            list.appendChild(skin_container);

        for(var name in skins)
        {
            var variants = skins[name].Variants;
            var s = new skins[name](this.Dummy);
            this.SkinPreviews[name] = s;

            if(skins[name].isVariant) continue;
            if(World.Player.Appearance.Skin == name) current = i;

            skin_container = document.createElement('div');
                skin_container.className = 'skin';
                skin_container.dataset.index = i;
                skin_container.dataset.id = name;
                skin_container.addEventListener('click', function()
                {
                    if(DraggableScroll.Scrolling) return;
                    AppearanceGUI.Scroll(this.dataset.index*1);
                });
                skin_container.addEventListener('click', function()
                {
                    if(AppearanceGUI.isScrolling) return;
                    if(AppearanceGUI.selected != this) return;
                    if(this.dataset.current=='true') return;
                    
                    World.Player.ChangeSkin(this.dataset.id);
                });
                if(!available[name]) skin_container.dataset.locked = 'true';

            var nav_top = document.createElement('div');
                nav_top.className = 'nav_top';
                skin_container.appendChild(nav_top);

            if(variants && variants.length > 0)
            {
                for(var j = -1; j < variants.length; j++)
                {
                    var v = variants[j] || null;

                    var div = document.createElement('div');
                        div.className = 'variant';
                        div.dataset.variant = j;
                        div.dataset.name = name;
                        div.addEventListener('click', AppearanceGUI.ChangeSkinVariant);

                    nav_top.appendChild(div);

                    if(v)
                    {
                        if(World.Player.Appearance.Skin == v.name) current = i;
                    }
                    
                }
            }

            var preview = document.createElement('canvas');
                preview.className = 'preview';
                preview.width = canvas_width;
                preview.height = canvas_height;
                preview.dataset.variant = '-1';
                skin_container.appendChild(preview);

            this.PreviewList[name] = preview;
            this.CtxList[name] = preview.getContext('2d');

            var nav_bottom = document.createElement('div');
                nav_bottom.className = 'nav_bottom';
                nav_bottom.innerText = Lang.Get(s.Name);
                skin_container.appendChild(nav_bottom);

            list.appendChild(skin_container);
            i++;
        }

        skin_container = document.createElement('div');
            skin_container.className = 'skin empty';
            list.appendChild(skin_container);

        this.Scroll(current, true);
    }
}class Crafting
{
    static Init()
    {
        this.Items = {
            0: null, 
            1: null,
            2: null,

            3: null,
            4: null,
            5: null,

            6: null,
            7: null
        };

        // var container = document.getElementById('crafting');
        // var height = getCssVariable(document.getElementById('inventory'), '--window-height');

        // container.style.setProperty('--window-height', height);
        // container.style.setProperty('--window-width', height);

        // var els = section.querySelectorAll('.section');
        // els.forEach(e=>
        //     {
        //         e.style.height = height;
        //     });
        this.CreateCraftingSlots();
    }

    static DeleteTemporaryItems()
    {
        for(var name in this.Items)
        {
            var item = this.Items[name];

            if(item?.isTemporary)this.Items[name] = null;
        }
    }

    static TakeOutAutoAdded()
    {
        for(var name in this.Items)
        {
            var item = this.Items[name];

            if(item?.isAutoAdded)
            {
                this.clearUpCraftingItemData(item);
                World.Player.addItemToInventory(item);
                this.Items[name] = null;
            }
        }
    }

    static GetPossibleResults()
    {
        var items = {...this.Items};
        items['crafting_result'] = null;

        for(var name in items)
        {
            if(items[name]?.isAutoAdded) items[name] = null;
        }

        return ItemHelper.getRecipeFrom(items, true);
    }

    static Open()
    {
        // this.UpdateCrafting();
        InventoryGUI.isCraftingOpen = true;
        InventoryGUI.setGlobalHighlight('IS_MATERIAL');
    }

    static Close()
    {
        InventoryGUI.isCraftingOpen = false;
        InventoryGUI.clearGlobalHighlight();

        for(var name in this.Items)
        {
            if(name == 'crafting_result') continue;

            var item = this.Items[name];
            if(item && !item.isTemporary)
            {
                this.clearUpCraftingItemData(item);
                World.Player.addItemToInventory(item);
            }
            this.Items[name] = null;
        }

        this.UpdateCrafting();
    }

    static CreateCraftingSlots()
    {
        var content = document.getElementById('section_crafting_slots');
        content.innerHTML = '';

        var slot_size = getCssVariable(document.body, '--slot-size', true) * Settings.Video.UI_Scale/100;
        var r = 2 * slot_size;
        var content_size = (2*r) + slot_size;
        var slots = 8;
        var angle_step = 360 / slots;
        var angle = -90;
        var pos, slot;
        var center = {x: content_size/2, y: content_size/2};

        // content.style.setProperty('--width', content_size +slot_size +'px');
        // content.style.setProperty('--height', content_size +slot_size +'px');

        for(var i = 0; i < slots; i++)
        {
            pos = MathHelper.lineToAngle(center, r, angle);
            slot = InventoryGUI.getEmptyInventorySlot();
                slot.dataset.slot = i;
                slot.dataset.type='crafting';
                slot.style.left = pos.x+'px';
                slot.style.top = pos.y+'px';
                slot.addEventListener('click', this.craftingSlotClick);
                slot.addEventListener('mouseup', this.craftingSlotRightClick);
                slot.addEventListener('mousemove', this.craftingSlotHover);
                slot.addEventListener('mouseout', InventoryGUI.InventoryOut);
            content.appendChild(slot);

            angle += angle_step;
        }

        slot = InventoryGUI.getEmptyInventorySlot();
            slot.dataset.slot = 'crafting_result';
            slot.dataset.type='crafting';
            slot.style.left = center.x+'px';
            slot.style.top = center.y+'px';
            slot.style.pointerEvents = 'none';
            slot.addEventListener('click', this.craftingResultClick);
            slot.addEventListener('mousemove', this.craftingSlotHover);
            slot.addEventListener('mouseout', InventoryGUI.InventoryOut);
        content.appendChild(slot);
    }

    static UpdateCrafting()
    {
        var slot;
        for(slot in this.Items)
        {
            var el = document.querySelector('.inventory_slot[data-type="crafting"][data-slot="'+slot+'"]');
            if(!el) continue;

            var item = this.Items[slot];
            InventoryGUI.UpdateSlot(el, item);
        }

        var result_slot = 'crafting_result';
        var result_slot_el = document.querySelector('.inventory_slot[data-type="crafting"][data-slot="'+result_slot+'"]');
        this.Items[result_slot] = null;
        result_slot_el.style.pointerEvents = 'none';

        var availableResult = ItemHelper.getRecipeFrom(this.Items);
        if(availableResult)
        {
            this.Items[result_slot] = availableResult.Result;
            result_slot_el.style.pointerEvents = 'all';
            set('#section_crafting_slots', 'dataset.animation', 'true', true);
        }
        else
        {
            set('#section_crafting_slots', 'dataset.animation', 'false', true);
        }

        this.DeleteTemporaryItems();

        var possible_results = this.GetPossibleResults();
        var results_container = document.getElementById('possible_crafting_results');
            results_container.innerHTML = '';

        for(var i = 0; i < possible_results.length; i++)
        {
            var item = possible_results[i].Result;
            slot = InventoryGUI.getEmptyInventorySlot();
                slot.dataset.slot = i;
                slot.dataset.type = 'crafting';
                slot.dataset.item = item.GetId();
                slot.style.setProperty('--order', i);
                slot.addEventListener('click', this.possibleResultsClick);
                slot.addEventListener('mousemove', this.possibleResultsHover);
                slot.addEventListener('mouseout', InventoryGUI.InventoryOut);
            results_container.appendChild(slot);

            
            slot.querySelector('img').src = TextureManager.Get(item.Texture).src;
        }


        InventoryGUI.UpdateSlot(result_slot_el, this.Items[result_slot]);
    }

    static possibleResultsClick()
    {
        if(this.dataset.disabled == 'true') return;
        Crafting.TakeOutAutoAdded();

        var possible_results = Crafting.GetPossibleResults();
        var slot = this.dataset.slot;
        var item = possible_results[slot]?.Result;
        var recipe = item.Recipe;
        var currentItems = Crafting.Items;
        var empty_slot = null;

        for(var i = 0; i < recipe.Ingredients.length; i++)
        {
            var ing_id = recipe.Ingredients[i][0];
            var ing_count = recipe.Ingredients[i][1];
            var gotIt = false;

            for(var id in currentItems)
            {
                var _item = currentItems[id];
                if(!_item) 
                {
                    if(empty_slot == null) empty_slot = id;
                    continue;
                }

                if(_item.GetId() == ing_id)
                {
                    gotIt = true;
                    //one of required ingredients is currently in slot
                    // if(_item.count >= ing_count) continue;
                    
                    _item.requiredCount = ing_count;
                }
            }

            if(!gotIt)
            {
                for(var j = 0; j < World.Player.inventory.length; j++)
                {
                    var _item = World.Player.inventory[j];
                    if(!_item) continue;

                    if(_item.GetId() == ing_id)
                    {
                        if(!Crafting.Items[empty_slot]) 
                        {
                            _item.isAutoAdded = true;
                            _item.requiredCount = ing_count;
                            Crafting.Items[empty_slot] = _item;
                            World.Player.inventory[j] = null;
                        }
                        else 
                        {
                            Crafting.Items[empty_slot].count += _item.count;
                            if(Crafting.Items[empty_slot].count > _item.maxStackSize)
                            {
                                World.Player.inventory[j].count = Crafting.Items[empty_slot].count - _item.maxStackSize;
                                Crafting.Items[empty_slot].count = _item.maxStackSize;
                            }
                            else
                            {
                                World.Player.inventory[j] = null;
                            }
                        }
                    }
                }

                if(!Crafting.Items[empty_slot]) //player dont have this item in inventory
                {
                    var _item = Item.Get(ing_id);
                        _item.count = 0;
                        _item.requiredCount = ing_count;
                        _item.isTemporary = true;

                    Crafting.Items[empty_slot] = _item;
                }
            }


            empty_slot = null;
        }

        Crafting.UpdateCrafting();
        InventoryGUI.Update();

        ItemInfo.Hide();

        var slot = document.querySelectorAll('#possible_crafting_results .inventory_slot')[this.dataset.slot];
            slot.style.opacity = .5;
            slot.dataset.disabled = 'true';
    }

    static craftingSlotHover()
    {
        var slot = this.dataset.slot;
        var item = Crafting.Items[slot];
        ItemInfo.Show(item);
    }

    static possibleResultsHover()
    {
        var possible_results = Crafting.GetPossibleResults();
        var slot = this.dataset.slot;
        var item = possible_results[slot]?.Result;
        if(!item) return;
        ItemInfo.Show(item);
    }

    static craftingSlotClick()
    {
        var slot = this.dataset.slot;
        var item = Crafting.Items[slot];
        var temp = item;
        var in_hand = World.Player.hand;

        if(!item && !in_hand) return;
        if(item?.isTemporary) return;
        if(in_hand && !in_hand.isMaterial()) return;

        Crafting.Items[slot] = in_hand;
        World.Player.hand = temp;

        Crafting.clearUpCraftingItemData(World.Player.hand);

        InventoryGUI.Update();
        InventoryGUI.UpdateHand();
        Crafting.UpdateCrafting();
    }

    static craftingSlotRightClick(e)
    {
        if(e.button != 2) return;

        var slot = this.dataset.slot;
        var item = Crafting.Items[slot];

        if(!item) return;
        if(item.isTemporary) return;

        World.Player.addItemToInventory(item);
        Crafting.Items[slot] = null;

        Crafting.clearUpCraftingItemData(item);

        InventoryGUI.Update();
        Crafting.UpdateCrafting();
    }

    static clearUpCraftingItemData(item)
    {
        if(!item) return;

        delete item.isTemporary;
        delete item.requiredCount;
        delete item.isAutoAdded;
    }

    static craftingResultClick()
    {
        var slot = this.dataset.slot;
        var item = Crafting.Items[slot];
        var in_hand = World.Player.hand;

        if(in_hand)
        {
            if(in_hand.GetId() == item.GetId() && item.stackAble)
            {
                if(World.Player.hand.count >= item.maxStackSize) return;
                World.Player.hand.count++;
            }
            else return;
        }
        else
        {
            World.Player.hand = ItemHelper.CopyItem(item);
        }
        

        var recipe = item.Recipe;
        for(var i = 0; i < recipe.Ingredients.length; i++)
        {
            var ing = recipe.Ingredients[i];
            for(var name in Crafting.Items)
            {
                var _item = Crafting.Items[name];
                if(!_item) continue;

                if(_item.GetId() == ing[0])
                {
                    _item.count -= ing[1];
                    if(_item.count == 0) 
                    {
                        Crafting.Items[name] = null;
                    }
                }
            }
        }

        InventoryGUI.Update();
        InventoryGUI.UpdateHand();
        Crafting.UpdateCrafting();
    }
}class CustomSelect
{
    static Init(element, parent_id)
    {
        var id = element.id;
        var options = [];
        var onchange = element.onchange;

        var childs = element.childNodes;
        var i = 0;
        var selected = 0;
        childs.forEach(e => 
        {
            if(e.nodeName == 'OPTION')
            {
                var opt = {value: e.value, name: e.innerText, disabled: e.disabled};
                options.push(opt);
                if(e.selected) selected = i;
                i++;
            }
        });

        var custom = CustomSelect.Create(id, options, selected, onchange);
        element.remove();
        document.getElementById(parent_id).appendChild(custom);
    }

    static Create(id, options = [], selected = 0, onchange = null)
    {
        var container = document.createElement('div');
            container.className = 'custom-select';
            container.id = id;
            container.setAttribute('tabindex', '-1')
            container.dataset.active = 'false';
            if(onchange) container.onchange = onchange;
            container.addEventListener('blur', function()
            {
                this.dataset.active = 'false';
            });
            container.addEventListener('click', function()
            {
                if(this.dataset.active == 'false')
                {
                    this.dataset.active = 'true';
                    this.focus();
                }
                else
                {
                    this.blur();
                }
            });

        var container_name = document.createElement('span');
            container_name.className = 'name';
            container.appendChild(container_name);

        var options_container = document.createElement('div');
            options_container.className = 'options-container';
            container.appendChild(options_container);

        for(var i = 0; i < options.length; i++)
        {
            var opt = options[i];

            var option = document.createElement('div')
                option.className = 'option';
                option.dataset.value = opt.value;
                option.dataset.name = Lang.Get(opt.name) || opt.value;
                option.innerHTML = option.dataset.name;
                if(opt.icon) option.dataset.icon = opt.icon;
                if(opt.disabled) option.dataset.disabled = 'true';
                option.dataset.id = id;
                option.addEventListener('click', function()
                {
                    var container = document.getElementById(this.dataset.id);
                    if(container.dataset.value != this.dataset.value)
                    {
                        container.dataset.value = this.dataset.value;
                        container.value = container.dataset.value;
                        container.querySelector('.name').innerHTML = this.dataset.name;
                        container.onchange();  
                    }
                });

            if(selected == i)
            {
                container.dataset.value = opt.value;
                container.value = container.dataset.value;
                container_name.innerHTML = Lang.Get(opt.name) || opt.value;
            }

            options_container.appendChild(option);
        }

        return container;
    }
}class DialogGUI
{
	static Initialize()
	{
        DialogGUI.showQuests = true;

        document.querySelector('#dialog_content').addEventListener('click', function(){DialogGUI.SkipTextAnimation()});
	}

	static AddDialogLine(dialogLine)
	{
		if(!Dialog.DialogLines) Dialog.DialogLines = {};

		Dialog.DialogLines[dialogLine.id] = dialogLine;
	}

	static canBeOpened()
	{
		if(DialogGUI.isOpen) return false;
		if(!World.Player.interactionWith) return false;
		if(World.Player.interactionWith.isTrading) return false;
		return true;
	}

    static Open()
    {
        if(!this.canBeOpened()) return;

        this.currentDialog = World.Player.interactionWith.GetDialogLine();
		this.currentDialog.Reset();
		
        this.charNum = 0;
		DialogGUI.isOpen = true;

        UI_Helper.Open('talk_with', false, null, DialogGUI.Close);

        this.setOptions();
        this.setContent();

        var name = World.Player.interactionWith.getDisplayName();
        set('#dialog_window', 'dataset.name', name);

		if(isFunction(World.Player.interactionWith.onDialogStart)) World.Player.interactionWith.onDialogStart();

        this.showQuests = false;
    }

	static ChangeLine(new_line)
	{
		this.currentDialog = new_line;
        this.charNum = 0;

        this.setOptions();
        this.setContent();

        var name = World.Player.interactionWith.getDisplayName();
        set('#dialog_window', 'dataset.name', name);
	}

    static Close()
    {
        // World.Player.isTalking = false;
		DialogGUI.isOpen = false;
		World.Player.interactionWith = null;

        var el = document.getElementById('talk_with');
        el.style.setProperty("display", "block", "important");
        setTimeout(()=>{el.style.display = ''}, 550);

        DialogGUI.showQuests = true;
    }

	static Update()
	{
		if(!DialogGUI.isOpen) return;
        this.charNum++;
        this.setContent();
	}

    static SkipTextAnimation()
    {
        this.charNum = this.currentDialog.GetText().length-1;
    }

    static setContent()
    {
        var content = '#dialog_content';
        var text = this.currentDialog.GetText();

        var textToShow = '';
        if(text.length < this.charNum) textToShow = text;
        else textToShow = text.slice(0, this.charNum);

        if(this.charNum > text.length) return;  //no need to update content anymore
        set(content, 'innerText', textToShow, true);
    }

    static getQuestOptions()
    {
        var opt = [];
        if(!this.showQuests) return opt;
        var npc = World.Player.interactionWith.constructor.name;

        var completedQuest = QuestList.GetQuestsToComplete(npc);
        for(var i in completedQuest)
        {
            var q = completedQuest[i];
            var option = new DialogOption(q.getDisplayName(true), () => DialogLine.ChangeDialogLine(q.dialogLineComplete), 'quest');
                option.isQuest = true;

            opt.push(option);
        }

        var availableQuests = QuestList.GetAvailableQuests(npc);
        for(i in availableQuests)
        {
            var q = availableQuests[i];
            var option = new DialogOption(q.getDisplayName(), () => DialogLine.ChangeDialogLine(q.dialogLine), 'quest');
                option.isQuest = true;

            opt.push(option);
        }


       

        return opt;
    }

    static setOptions()
    {
        var container = document.getElementById('dialog_options');
            container.innerHTML = '';
        var options = this.getQuestOptions().concat(this.currentDialog.GetOptions());

        for(var i = 0; i < options.length; i++)
        {
            var opt = this.getOption(options[i]);
            if(i == options.length-1) opt.className += ' last';
            container.appendChild(opt);
        }

        container.style.setProperty('--options', options.length);
    }

    static getOption(option)
    {
        var opt = document.createElement('div');
            opt.className = 'option';
            if(option.isQuest) opt.className += ' quest';

        if(option)
        {
            if(option.icon)
            {
                var icon = document.createElement('div');
                    icon.className = 'icon';
                    icon.dataset.icon = option.icon;
                    opt.appendChild(icon);
            }

            var text = document.createElement('div');
                text.className = 'text';
                text.innerText = option.GetText();
                opt.appendChild(text);
            
            if(isFunction(option.onClick)) opt.addEventListener('click', option.onClick);
        }

        return opt;
    }
}class DraggableScroll
{
    static Init(element, info = null)
    {
        DraggableScroll.Dragging = null;
        DraggableScroll.Scrolling = null;
        DraggableScroll.SmoothInterval = null;
        DraggableScroll.Moved = false;

        DraggableScroll.DragStart = 0;
        DraggableScroll.startX = 0;
        DraggableScroll.startY = 0;
        DraggableScroll.startScrollX = 0;
        DraggableScroll.startScrollY = 0;

        DraggableScroll.scrollTick = 0;
        DraggableScroll.scrollDuration = 60;
        DraggableScroll.smoothLeft = 0;
        DraggableScroll.smoothTop = 0;

        if(info)
        {
            if(info.accX) element.dataset.accx = info.accX;
            if(info.accY) element.dataset.accx = info.accY;
            if(info.step) element.dataset.step = info.step;
        }

        element.addEventListener('mousedown', DraggableScroll.MouseDown);
        element.addEventListener('mouseup', DraggableScroll.MouseUp);
        element.addEventListener('mouseenter', DraggableScroll.MouseEnter);
        element.addEventListener('mousemove', DraggableScroll.MouseMove);
    }

    static changeChildsPointers(disable = true)
    {
        if(DraggableScroll.Dragging)
        {
            DraggableScroll.Dragging.dataset.childpointers = (disable) ? 'none' : '';
            // for(var i = 0; i < DraggableScroll.Dragging.childNodes.length; i++)
            // {
            //     var child = DraggableScroll.Dragging.childNodes[i];
            //     if(!child.style) continue;
            //     child.style.pointerEvents = (disable) ? 'none' : '';
            // }
        }
    }

    static MouseEnter()
    {
        DraggableScroll.changeChildsPointers(false);

        DraggableScroll.Moved = false;
        DraggableScroll.Dragging = null;
    }

    static MouseDown(e)
    {
        if(e.button != 0) return;

        DraggableScroll.Moved = false;

        if (e.offsetX > e.target.clientWidth || e.offsetY > e.target.clientHeight) 
        {
            //scrollbar click
            return;
        }

        DraggableScroll.Dragging = this;
        DraggableScroll.DragStart = Date.now();

        DraggableScroll.startX = e.clientX;
        DraggableScroll.startY = e.clientY;

        DraggableScroll.startScrollX = this.scrollLeft;
        DraggableScroll.startScrollY = this.scrollTop;
    }

    static MouseMove(e)
    {
        if(DraggableScroll.Dragging != this) return;


        if(!DraggableScroll.Moved) DraggableScroll.changeChildsPointers();

        DraggableScroll.Moved = true;
        clearInterval(DraggableScroll.SmoothInterval);
        

        var x = e.clientX;
        var y = e.clientY;

        var distanceX = DraggableScroll.startX - x;
        var distanceY = DraggableScroll.startY - y;

        var scrollLeft = DraggableScroll.startScrollX + distanceX;
        var scrollTop = DraggableScroll.startScrollY + distanceY;

        if(this.scrollTop != scrollTop || this.scrollLeft != screenLeft)
        {
            
            DraggableScroll.Scroll(this, scrollLeft, scrollTop); 
        }
    }

    static MouseUp(e)
    {
        if(DraggableScroll.Dragging != this) return;
        DraggableScroll.changeChildsPointers(false);

        var dragTime = Date.now() - DraggableScroll.DragStart;
        var multiplier = (500 / dragTime);
        if(multiplier < 1) multiplier = 1;
        if(multiplier > 15) multiplier = 15;


        var x = e.clientX;
        var y = e.clientY;

        var distanceX = (DraggableScroll.startX - x) * multiplier;
        var distanceY = (DraggableScroll.startY - y) * multiplier;

        var scrollLeft = DraggableScroll.startScrollX + distanceX;
        var scrollTop = DraggableScroll.startScrollY + distanceY;

        if(this.dataset.step)
        {
            var s = parseInt(this.dataset.step);
            scrollLeft = Math.round(scrollLeft / s) * s;
            scrollTop = Math.round(scrollTop / s) * s;
        }

        if(Math.abs(distanceX) > 10 || Math.abs(distanceY) > 10) DraggableScroll.SoftScroll(this, scrollLeft, scrollTop);
        else DraggableScroll.Scroll(this, scrollLeft, scrollTop);

        DraggableScroll.Dragging = null;
    }


    static SoftScroll(element, scrollLeft, scrollTop)
    {
        clearInterval(DraggableScroll.SmoothInterval);

        DraggableScroll.Scrolling = element;
        DraggableScroll.scrollTick = 0;
        DraggableScroll.smoothLeft = element.scrollLeft;
        DraggableScroll.smoothTop = element.scrollTop;

        DraggableScroll.smoothDistanceY = scrollTop - element.scrollTop;
        DraggableScroll.smoothDistanceX = scrollLeft - element.scrollLeft;

        DraggableScroll.SmoothInterval = setInterval(DraggableScroll.SoftScrollUpdate, 1000/60);
    }

    static SoftScrollUpdate()
    {
        if(DraggableScroll.scrollTick > DraggableScroll.scrollDuration)
        {
            clearInterval(DraggableScroll.SmoothInterval);
            DraggableScroll.Scrolling = null;  
            return;
        }

        var p = 1.675;
        var k = (DraggableScroll.scrollTick / DraggableScroll.scrollDuration);
        var acc = 1 - Math.pow(1 - k, p);

        var accX = DraggableScroll.Scrolling.dataset.accx || 1;
        var accY = DraggableScroll.Scrolling.dataset.accy || 1;

        scrollX = DraggableScroll.smoothLeft + (DraggableScroll.smoothDistanceX * acc * accX);
        scrollY = DraggableScroll.smoothTop + (DraggableScroll.smoothDistanceY * acc * accY);

        var scrolled = DraggableScroll.Scroll(DraggableScroll.Scrolling, scrollX, scrollY);
        if(!scrolled && DraggableScroll.scrollTick > 5)
        {
            DraggableScroll.Scroll(DraggableScroll.Scrolling, DraggableScroll.smoothLeft + DraggableScroll.smoothDistanceX, DraggableScroll.smoothTop + DraggableScroll.smoothDistanceY);
            clearInterval(DraggableScroll.SmoothInterval);
            DraggableScroll.Scrolling.style.scrollBehavior = '';
            DraggableScroll.Scrolling = null; 
        }
        DraggableScroll.scrollTick++;

        // if(scrolled && DraggableScroll.scrollTick%5 == 0)
        // {
        //     SoundManager.Play('tick', 'EFFECT');
        // }
    }


    static Scroll(element, scrollLeft, scrollTop)
    {
        var previous = {top: element.scrollTop, left: element.scrollLeft};

        element.scrollLeft = scrollLeft;
        element.style.scrollBehavior = 'unset';
        element.scrollTop = scrollTop;

        if(element.scrollTop == previous.top && element.scrollLeft == previous.left) return false;
        return true;
    }
}class DraggableWindow
{
    static Init(handler, borderless = false)
    {
        if(typeof DraggableWindow.Dragging === 'undefined')
        {
            DraggableWindow.Dragging = false;
            window.addEventListener('mouseup', DraggableWindow.EndDrag);
            window.addEventListener('mousemove', DraggableWindow.Drag);
        }
        
        if(!handler) return;

        var window_id = handler.dataset.handle;
        if(!window_id) return;

        var container_window = document.getElementById(window_id);
        if(!container_window) return;

        handler.addEventListener('mousedown', DraggableWindow.StartDrag);

        container_window.dataset.started = 'false';
        container_window.dataset.draggable = 'true';
        container_window.dataset.borderless = borderless;
        container_window.dataset.offsetparent = handler.dataset.offsetparent;
    }

    static setStartPosition(element)
    {
        var rect = element.getBoundingClientRect();
        var x, y, tx, ty;

        x = rect.x;
        y = rect.y;

        if(element.dataset.offsetparent)
        {
            var offset_container = document.getElementById(element.dataset.offsetparent);
            var offset_rect = offset_container.getBoundingClientRect();

            tx = offset_rect.x;
            ty = offset_rect.y;
        }

        element.style.left = (x - tx) + 'px';
        element.style.top = (y - ty) + 'px';
        element.style.transform = 'unset';
        element.dataset.started = 'true';
    }

    static setZ_index(element)
    {   
        var i = 1;
        var indexed = [];
        var els = document.querySelectorAll('[data-draggable="true"');
        els.forEach(e => 
        {
            if(e.style.zIndex)
            {
                var index = parseInt(e.style.zIndex);
                indexed[index] = e;
            }
        });

        for(var index in indexed)
        {
            var el = indexed[index];
            el.style.zIndex = i;
        }

        element.style.zIndex = i + 1;
    }

    static GetStartPosition(element)
    {
        var style = getComputedStyle(element);
        var tX = 0;
        var tY = 0;

        var transform = element.computedStyleMap().get('transform');
        for(var index in transform)
        {
            var property = transform[index];
            if(property instanceof CSSTranslate)
            {
                if(property.x.value) tX = property.x.value + ((property.x.unit == 'percent') ? '%' : '');
                if(property.y.value) tY = property.y.value + ((property.y.unit == 'percent') ? '%' : '');
            }
        }

        var pos = 
        {
            x: style.left,
            y: style.top,
            translateX: tX,
            translateY: tY
        };
        return pos;
    }

    static StartDrag(e)
    {
        if(!Settings.General.AllowDraggableWindows) return;
        DraggableWindow.Dragging = this;

        this.dataset.startx = e.clientX;
        this.dataset.starty = e.clientY;

        var container_window = document.getElementById(this.dataset.handle);

        DraggableWindow.setZ_index(container_window);
        if(container_window.dataset.started == 'false') DraggableWindow.setStartPosition(container_window);
    }

    static EndDrag()
    {
        DraggableWindow.Dragging = null;
    }

    static ResetPosition(container_window)
    {
        container_window.style.top = '';
        container_window.style.left = '';

        container_window.style.right = '';
        container_window.style.bottom = '';

        container_window.style.transform = '';
        container_window.style.zIndex = '';

        DraggableWindow.setZ_index(container_window);
    }

    static Drag(e)
    {
        if(!DraggableWindow.Dragging) return;

        var el = DraggableWindow.Dragging;
        var container_window = document.getElementById(el.dataset.handle);

        var window_rect = container_window.getBoundingClientRect();

        var currentX = window_rect.x;
        var currentY = window_rect.y;

        var x = e.clientX;
        var y = e.clientY;
        
        var startX = parseInt(el.dataset.startx); 
        var startY = parseInt(el.dataset.starty);

        var diffX = startX - x;
        var diffY = startY - y;

        var offsetX = 0;
        var offsetY = 0;


        var border_width = window.innerWidth;
        var border_height = window.innerHeight;


        if(el.dataset.offsetparent)
        {
            var offset_container = document.getElementById(el.dataset.offsetparent);
            var offset_rect = offset_container.getBoundingClientRect();

            offsetX = offset_rect.x;
            offsetY = offset_rect.y;

            border_width = offset_rect.width;
            border_height = offset_rect.height;
        }

        

        var new_y = currentY - offsetY - diffY;
        var new_x = currentX - offsetX - diffX;

        if(container_window.dataset.borderless == 'false')
        {
            if(new_y < 0) new_y = 0;
            if(new_x < 0) new_x = 0;

            if(new_x + window_rect.width > border_width) new_x = border_width - window_rect.width;
            if(new_y + window_rect.height > border_height) new_y = border_height - window_rect.height;
        }

        container_window.style.top = new_y + 'px';
        container_window.style.left = new_x + 'px';

        container_window.style.right = 'unset';
        container_window.style.bottom = 'unset';

        el.dataset.startx = x;
        el.dataset.starty = y;
    }
}class InventoryGUI
{
    static Init(container_id = 'inventory', required_slots, type)
    {
        if(!InventoryGUI.Containers) InventoryGUI.Containers = {};

        var container = document.getElementById(container_id);
        var content = container.querySelector('.content');

        var c_style = getComputedStyle(container);


        var slot_size = parseFloat(c_style.getPropertyValue('--slot-size').replace('px', ''));
        var slot_margin = parseFloat(c_style.getPropertyValue('--slot-margin').replace('px', ''));
        var rows = c_style.getPropertyValue('--rows');
        var cols = c_style.getPropertyValue('--cols');

        var width = (slot_size + slot_margin) * cols;
        var height = (slot_size + slot_margin) * rows;

        container.style.setProperty('--window-width', width + 'px');
        container.style.setProperty('--window-height', height + 'px');

        if(required_slots)
        {
            var current_slots = cols * rows;
            var required_rows = Math.ceil(required_slots / cols);

            rows = required_rows;
        }

        if(!type) type = container_id.toUpperCase();

        InventoryGUI.createSlots(container_id, content, rows, cols, type);
    }

    static InitEquips()
    {
        var container_id = 'inventory_equips';
        var container = document.getElementById(container_id);

        var equips_container = document.getElementById('inventory_equips_content');
            equips_container.innerHTML = '';

        var equips_order = Player.GetEquipSlots(true);

        for(var i = 0; i < equips_order.length; i++)
        {
            var slot = InventoryGUI.getEmptyInventorySlot();
                slot.dataset.index = equips_order[i];
                slot.dataset.id = container_id;
                slot.dataset.highlightfilter = ';';
                equips_container.appendChild(slot);

            InventoryGUI.addEvents(slot, 'EQUIPS');
        }

        var slot_margin = getCssVariable(container, '--slot-margin', true);
        var slot_size = getCssVariable(container, '--slot-size', true);

        var height = (slot_size + slot_margin) * i;

        container.style.setProperty('--window-height', height + 'px');
    }

    static createSlots(container_id, slots_container, rows, cols, type = 'INVENTORY')
    {
        slots_container.innerHTML = '';

        for(var i = 0; i < rows * cols; i++)
        {
            var slot = InventoryGUI.getEmptyInventorySlot();
                slot.dataset.index = i;
                slot.dataset.id = container_id;
                slots_container.appendChild(slot);

            InventoryGUI.addEvents(slot, type);
        }
    }

    static getEmptyInventorySlot()
    {
        var slot = document.createElement('div');
            slot.className = 'inventory_slot text-stroke';

        var img_container = document.createElement('div');
            img_container.className = 'image_container';
            slot.appendChild(img_container);

        var img = document.createElement('img');
            img_container.appendChild(img);

        return slot;
    }

    static addEvents(slot, type)
    {
        switch(type)
        {
            case 'INVENTORY':
                slot.addEventListener('click', InventoryGUI.InventoryClick);
                slot.addEventListener('mouseup', InventoryGUI.InventoryRightClick);
                slot.addEventListener('mousemove', InventoryGUI.InventoryHover);
                slot.addEventListener('mouseout', InventoryGUI.InventoryOut);
                break;

            case 'EQUIPS':
                slot.addEventListener('click', InventoryGUI.EquipsClick);
                slot.addEventListener('mouseup', InventoryGUI.EquipsRightClick);
                slot.addEventListener('mousemove', InventoryGUI.InventoryHover);
                slot.addEventListener('mouseout', InventoryGUI.InventoryOut);
                break;

            case 'SHOP':
                slot.addEventListener('click', InventoryGUI.ShopClick);
                slot.addEventListener('mouseup', InventoryGUI.ShopRightClick);
                slot.addEventListener('mousemove', InventoryGUI.InventoryHover);
                slot.addEventListener('mouseout', InventoryGUI.InventoryOut);
                break;
        }
    }

    static getContainerData(element)
    {
        var slot = element.dataset.index;
        var id = element.dataset.id;

        if(!InventoryGUI.Containers[id]) return null;
        var owner = InventoryGUI.Containers[id][0];
        var items_path = InventoryGUI.Containers[id][1];
        var items = get(owner, items_path) ?? [];

        return {slot, id, owner, items_path, items};
    }


    static InventoryHover()
    {
        var data = InventoryGUI.getContainerData(this);
        var item = data.items[data.slot];
        var in_hand = World.Player.hand;

        var highlight_enchant = 'ENCHANT';
        var highlight_bless = 'BLESS';
        var filters = this.dataset.highlightfilter ?? null;
        var showEnchant = false;
        var showBlessing = false;


        if(item) item.showNewItemInfo = false;
        delete this.dataset.isnew;

        if(item && in_hand?.type == TYPE.ENCHANT && ItemHelper.CanBeEnchanted(item, in_hand) !== null) 
            // if(filter(highlight_enchant, filters) && ItemHelper.CanBeEnchanted(item, in_hand) !== false) 
            {
                // this.dataset.highlight = highlight_enchant;
                showEnchant = true;
            }

        if(in_hand?.type == TYPE.BLESSING && ItemHelper.CanBeBlessed(item, in_hand))
        {
            // if(filter(highlight_bless, filters)) this.dataset.highlight = highlight_bless;
            showEnchant = false;
            showBlessing = true;
        } 


        if(InventoryGUI.isShopOpen || InventoryGUI.isCraftingOpen) 
        {
            ItemInfo.Show(item); 
            return;
        }

        ItemInfo.Show(item, showEnchant);

        if(this.dataset.id == 'inventory' && item?.equipAble && !showEnchant && !showBlessing)
        {
            var equipped = World.Player.equips[item.slot];
            var equip_slot = document.querySelector('#inventory_equips_content [data-index="'+item.slot+'"]');
            if(!equipped || !equip_slot) return;

            var rect = equip_slot.getBoundingClientRect();
            ItemInfo.ShowCompared(equipped, rect.x, rect.y);
        }

        if(showBlessing)
        {
            var infos = document.querySelectorAll('.item_info_container');
            if(infos.length == 1)
            {
                var next_tier_item = ItemHelper.CopyItem(item);
                    next_tier_item.Bless(in_hand, true);
                
                ItemInfo.ShowCompared(next_tier_item);

                infos = document.querySelectorAll('.item_info_container');
            }

            var main = infos[0];
            var compared = infos[1];
            ItemInfo.ReposeIfNeeded(main, compared);

            set(main, 'dataset.iscomparing', 'true', true);
        }
    }

    static InventoryOut()
    {
        InventoryGUI.clearHighlights(this);
    }

    static clearHighlights(slot)
    {
        delete slot.dataset.highlight;

        ItemInfo.Hide();
    }

    static InventoryClick(e)
    {
        if(e.button != 0) return;
        
        var data = InventoryGUI.getContainerData(this);
        var item_path = data.items_path + '.' + data.slot;
        var item = data.items[data.slot];
        var temp = data.items[data.slot];
        var in_hand = World.Player.hand;

        if(!in_hand && !item) return;   //do nothing if clicked slot and hand are empty 

        if(in_hand && item)
        {
            if(in_hand.constructor.name == item.constructor.name)
            {
                //przedmioty sa tego samego typu
                if(in_hand.stackAble)
                {
                    //stackowanie przedmiotow
                    var new_count = in_hand.count + item.count;
                    if(new_count <= item.maxStackSize)
                    {
                        item.count = new_count;
                        World.Player.hand = null;
                    }
                    else
                    {
                        //przekroczono max stack
                        item.count = item.maxStackSize;
                        World.Player.hand.count = new_count - item.maxStackSize;
                    }

                    InventoryGUI.UpdateData(data);
                    return;
                }
            }
            else if(in_hand.type == TYPE.ENCHANT && item.enchantAble && !InventoryGUI.isShopOpen && !InventoryGUI.isCraftingOpen)
            {
                var result = item.Enchant(in_hand);
                if(result)
                {
                    World.Player.hand = null;
                    //playsound
                    // DamageIndicator.AddObject(Mouse.x + Camera.xView, Mouse.y - 25 + Camera.yView, "Enchant Successful!", "UPGRADE_SUCCESS");
                    InventoryGUI.UpdateData(data);
                    InventoryGUI.clearHighlights(this);
                    ItemInfo.Show(item);
                    return;
                }
            }
            else if(in_hand.type == TYPE.BLESSING && ItemHelper.CanBeBlessed(item, in_hand) && !InventoryGUI.isShopOpen && !InventoryGUI.isCraftingOpen)
            {
                var result = item.Bless(in_hand);
                if(result)
                {
                    if(in_hand.count == 1) World.Player.hand = null;
                    else 
                    {
                        World.Player.hand.count--;
                        World.Player.addItemToInventory(World.Player.hand);
                        World.Player.hand = null;
                    }


                    //playsound
                    // DamageIndicator.AddObject(Mouse.x + Camera.xView, Mouse.y - 25 + Camera.yView, "Enchant Successful!", "UPGRADE_SUCCESS");
                    InventoryGUI.UpdateData(data);
                    InventoryGUI.clearHighlights(this);
                    ItemInfo.Show(item);
                    return;
                }
            }
        }

        set(data.owner, item_path, in_hand);
        World.Player.hand = temp;

        InventoryGUI.UpdateData(data);
        InventoryGUI.clearHighlights(this);
        ItemInfo.Show(in_hand);
    }

    static ShopClick(e)
    {
        if(e.button != 0) return;
        
        var data = InventoryGUI.getContainerData(this);
        var item_path = data.items_path + '.' + data.slot;
        var item = data.items[data.slot];
        var temp = data.items[data.slot];
        var in_hand = World.Player.hand;

        if(!in_hand && !item) return;   //do nothing if clicked slot and hand are empty 

        
        if(in_hand)
        {
           //player is gonna sell item in hand
           data.owner.Buy(in_hand, World.Player);
        }
        else if(item)
        {
            //player got empty hand so its gonna to buy item in slot
            data.owner.Sell(data.slot, World.Player, true);
        }

        InventoryGUI.UpdateData(data);
    }

    static ShopRightClick(e)
    {
        if(e.button != 2) return;

		var data = InventoryGUI.getContainerData(this);
        var item_path = data.items_path + '.' + data.slot;
        var item = data.items[data.slot];
        var in_hand = World.Player.hand;

        if(!in_hand && !item) return;   //do nothing if clicked slot and hand are empty 

        if(!in_hand) data.owner.Sell(data.slot, World.Player, false, 1); //buy item from slot
        else data.owner.Buy(in_hand, World.Player, true, 1); //player is gonna sell 1 item from hand

        InventoryGUI.UpdateData(data);
    }

    static EquipsClick(e)
    {
        if(e.button != 0) return;
        var equipped = false;
        
        var data = InventoryGUI.getContainerData(this);
        var item_path = data.items_path + '.' + data.slot;
        var item = data.items[data.slot];
        var temp = data.items[data.slot];
        var in_hand = World.Player.hand;

        if(!in_hand && !item) return;   //do nothing if clicked slot and hand are empty 

        if(isFunction(item?.onTakeOut)) item.onTakeOut();
        
        if(in_hand)
        {
            if(in_hand.equipAble) equipped = InventoryGUI.Equip(in_hand, data.slot);
            InventoryGUI.UpdateData(data);

            if(equipped)
            {
                InventoryGUI.clearHighlights(this);
                ItemInfo.Show(in_hand);
            }
            return;
        }
        

      

        set(data.owner, item_path, in_hand);
        World.Player.hand = temp;
        World.Player.UpdateStats();

        InventoryGUI.UpdateData(data);
    }

    static EquipsRightClick(e)
    {
        if(e.button != 2) return;
        
        var data = InventoryGUI.getContainerData(this);
        var item_path = data.items_path + '.' + data.slot;
        var item = data.items[data.slot];
        var in_hand = World.Player.hand;

        if(!item) return;   //do nothing if clicked slot and is empty 
        if(in_hand) return;
        
        World.Player.addItemToInventory(item);
        set(data.owner, item_path, null);

        if(isFunction(item.onTakeOut)) item.onTakeOut();

        World.Player.UpdateStats();
        InventoryGUI.UpdateData(data);
        InventoryGUI.Update('inventory', World.Player, 'inventory');
    }

    static UpdateData(data)
    {
        InventoryGUI.UpdateHand();
        InventoryGUI.Update(data.id, data.owner, data.items_path);
    }

    static InventoryRightClick(e)
    {
        if(e.button != 2) return;

		var data = InventoryGUI.getContainerData(this);
        var item_path = data.items_path + '.' + data.slot;
        
        var item = data.items[data.slot];
        var in_hand = World.Player.hand;

		// if(InGame.GUI.Inventory.isShopOpen)
		// {
		// 	var shop_owner = InGame.GUI.Inventory.shopOwner;
		// 	var item = this.GetItem();
		// 	var id = parseInt(this.id.replace('slot', ''));

		// 	if(!shop_owner) return;
		// 	if(!item) return;
			
		// 	shop_owner.Buy(item, InGame.GUI.Inventory.Owner);
		// 	this.Owner.inventory[id] = null;
		// 	return;	//disable quick equip while trading
		// }

        if(InventoryGUI.isShopOpen)
        {
            //sell
            if(!item) return;
            if(!item.canBeSold) return;

            World.Player.interactionWith.Buy(item, World.Player, false, 1); //player is gonna sell 1 item from slot
            item.count -= 1;
            if(item.count == 0) set(data.owner, item_path, null);

            InventoryGUI.Update('shop', World.Player.interactionWith, 'inventory');
            InventoryGUI.UpdateData(data);
            ItemInfo.Hide();
            if(item.count) ItemInfo.Show(item);
            return;
        }

        if(InventoryGUI.isCraftingOpen) 
        {
            if(item)
            {
                if(!item.isMaterial()) return;
                for(var i in Crafting.Items)
                {
                    if(Crafting.Items[i] == null) 
                    {
                        Crafting.Items[i] = item;
                        set(data.owner, item_path, null);
                        Crafting.UpdateCrafting();
                        InventoryGUI.UpdateData(data);
                        return;
                    }
                }
            }

            return;
        }



		if(item)
		{
			if(isFunction(item.onUse) && !in_hand) item.onUse(data.owner);      //you can use item only with empty hand
			else
			{
				if(item.equipAble) InventoryGUI.Equip(item);
				else if(item.stackAble)
				{
                    //take half of stack
					if(!in_hand && item.count > 1)
					{
						World.Player.hand = ItemHelper.CopyItem(item);
						var count = Math.floor(item.count / 2);

						World.Player.hand.count -= count;
						item.count = count;
					}
					else
					{
						if(in_hand)
						{
							if(in_hand.constructor.name === item.constructor.name)
							{
								if(in_hand.count > 1) in_hand.count -= 1;
								else World.Player.hand = null;

                                item.count += 1;
							}
						}
					}
				}
			}
		}
		else if(in_hand)
		{
			if(in_hand.stackAble && in_hand.count > 1)
			{
				item = ItemHelper.CopyItem(in_hand);
                item.count = 1;
                
				in_hand.count -= 1;
                set(data.owner, item_path, item);
			}
			
		}

        InventoryGUI.UpdateData(data);
    }

    static Equip(item, dedicated_slot)
    {
        var slot = item.slot;
        var owner = World.Player;

        if(!item.canBeEquipped(owner, 'equips', dedicated_slot)) return false;

		if(slot == SLOT.SPECIAL)
		{
            var special_slots = World.Player.getSpecialSlots();
            for(var i = 0; i < special_slots; i++)
            {
                if(!owner.equips[slot + i])
                {
                    slot += i;
                    break;
                }
            }
			
            //there is no empty slot
            if(slot == SLOT.SPECIAL) return false;

			if(dedicated_slot) slot = dedicated_slot;
		}

        if(dedicated_slot && slot != dedicated_slot) return false;
		
		if(owner.hand === item)		//przedmiot jest zakladany z reki
		{		
			if(owner.hand.requiredLevel <= owner.stats.Level)
			{
				var temp = owner.equips[slot];
				owner.equips[slot] = owner.hand;
				owner.hand = temp;
			}
		}
		else
		{
			if(item.requiredLevel <= owner.stats.Level)
			{
				var id = owner.inventory.indexOf(item);

				if(id >= 0)
				{
					var temp = owner.equips[slot];
					owner.equips[slot] = item;
					owner.inventory[id] = temp;
				}
			}
		}

        if(isFunction(item.onEquip)) item.onEquip();
		
        ItemInfo.Hide();
		owner.UpdateStats();
        InventoryGUI.Update('inventory_equips', World.Player, 'equips');

        return true;
    }

    static UpdateHand(onlyPos = false)
    {
        var item_in_hand = document.getElementById('item_in_hand');

        if(World.Player.hand)
        {
            set(item_in_hand, 'style.display', '', true);
            set(item_in_hand, 'style.top', Mouse.absY + 'px', true);
            set(item_in_hand, 'style.left', Mouse.absX + 'px', true);

            if(!onlyPos) 
            {
                InventoryGUI.UpdateSlot(item_in_hand, World.Player.hand);
                if(InventoryGUI.isShopOpen) return;
                if(InventoryGUI.isCraftingOpen) return;

                if(World.Player.hand.type == TYPE.BLESSING) InventoryGUI.setGlobalHighlight(TYPE.BLESSING);
                if(World.Player.hand.type == TYPE.ENCHANT) InventoryGUI.setGlobalHighlight(TYPE.ENCHANT);
            }
            return;
        }
        else
        {
            InventoryGUI.clearGlobalHighlight();
            if(InventoryGUI.isCraftingOpen) InventoryGUI.setGlobalHighlight('IS_MATERIAL');
        }

        set(item_in_hand, 'style.display', 'none', true);
    }

    static setGlobalHighlight(type, args)
    {
        var inv_slots = document.querySelectorAll('.inventory_slot[data-id="inventory"]');
        if(type == TYPE.BLESSING)
        {
            inv_slots.forEach(e => 
                {
                    var data = InventoryGUI.getContainerData(e);
                    var item = data.items[data.slot];
                    if(item) e.dataset.locked = !ItemHelper.CanBeBlessed(item, World.Player.hand);
                });
        }

        if(type == TYPE.ENCHANT)
        {
            inv_slots.forEach(e => 
                {
                    var data = InventoryGUI.getContainerData(e);
                    var item = data.items[data.slot];
                    if(item) e.dataset.locked = !(ItemHelper.CanBeEnchanted(item, World.Player.hand) !== null);
                });
        }

        if(type == 'IS_MATERIAL')
        {
            inv_slots.forEach(e => 
                {
                    var data = InventoryGUI.getContainerData(e);
                    var item = data.items[data.slot];
                    if(item) 
                    {
                        e.dataset.locked = !(item.isMaterial());
                    }
                });
        }
    }

    static clearGlobalHighlight()
    {
        var inv_slots = document.querySelectorAll('.inventory_slot[data-id="inventory"]');
        inv_slots.forEach(e => 
            {
                delete e.dataset.locked;
            });
    }


    static Update(id = 'inventory', owner = World.Player, items_path = 'inventory')
    {
        if(!owner) return;

        InventoryGUI.Containers[id] = [owner, items_path];

        var items = get(owner, items_path);
        var container = document.getElementById(id);
        var content = container.querySelector('.content');
        var slots = content.querySelectorAll('.inventory_slot');

        slots.forEach(slot => 
        {
            InventoryGUI.UpdateSlot(slot, items[slot.dataset.index]);
        });

    }

    static UpdateSlot(slot, item)
    {
        var img = slot.querySelector('.image_container img');
        var texture = null;

        delete slot.dataset.grade;
        delete slot.dataset.count;
        delete slot.dataset.item;
        delete slot.dataset.shine;
        delete slot.dataset.temporary;
        delete slot.dataset.enough;
        delete slot.dataset.isnew;
        delete slot.dataset.animated;

        if(item)
        {
            texture = TextureManager.Get(item.Texture).src;
            var shine = item.getShineStrength();

            if(item.Grade) slot.dataset.grade = item.Grade;
            if(item.count) slot.dataset.count = item.count;
            if(shine) slot.dataset.shine = shine;

            if(item.isTemporary) slot.dataset.temporary = true;
            if(item.requiredCount) 
            {
                slot.dataset.count = item.count +'/' + item.requiredCount;
                if(item.count < item.requiredCount) slot.dataset.enough = 'false';
            }

            if(item.TextureAnimation)
            {
                var img_container = slot.querySelector('.image_container');
                slot.dataset.animated = 'true';

                img_container.style.setProperty('--frames-x', item.TextureAnimation.framesX);
                img_container.style.setProperty('--frames-y', item.TextureAnimation.framesY);
                img_container.style.setProperty('--speed', item.TextureAnimation.speed+'s');
                if(item.TextureAnimation.scale) img_container.style.setProperty('--item-scale', item.TextureAnimation.scale);
                img_container.style.setProperty('background-image', 'url("'+texture+'")');
                texture = null;
            }

            if(item.showNewItemInfo) slot.dataset.isnew = 'true';

            set(slot, 'dataset.item', item.constructor.name, true);
        }
        
        set(img, 'style.display', (texture) ? '' : 'none', true);
        if(texture) set(img, 'src', texture, true);
    }

    static updateItemsShine()
    {
        if(document.getElementById('inventory').dataset.open != 'true') return;
        //only visible slots
        var slots = document.querySelectorAll('.inventory_slot[data-shine]');
        slots.forEach(e => 
            {
                if(e.id=='item_in_hand' && e.style.display=='none') return;

                var strength  = parseFloat(e.dataset.shine);
                if(MathHelper.GetChance(.25 * (strength**2))) InventoryGUI.drawShine(e);
            });
    }

    static drawShine(slot)
    {
        var img_container = slot.querySelector('.image_container');
        if(!img_container) return;

        var strength  = parseFloat(slot.dataset.shine);
        var size = getCssVariable(document.body, '--slot-size', true);
        var m = 5;
        var x = MathHelper.randomInRange(m, size/2) - 15;
        var y = MathHelper.randomInRange(m, size/2) - 15;

        var shine = document.createElement('div');
            shine.className = 'shine';
            shine.style.setProperty('--x', x+'px');
            shine.style.setProperty('--y', y+'px');
            shine.style.setProperty('--strength', strength);
            shine.onanimationend = function(){this.remove()}

        img_container.appendChild(shine);
    }
}class ItemInfo
{
    static ReposeIfNeeded(first, second)
    {
        var first_rect = first.getBoundingClientRect();
        var second_rect = second.getBoundingClientRect();

        var width = first_rect.width + second_rect.width;
        var height = first_rect.height > second_rect.height ? first_rect.height : second_rect.height;

        var new_pose = this.setPosition(first_rect.x, first_rect.y, first, width, height);

        set(second, 'style.top', new_pose.y + 'px', true);
        set(second, 'style.left', (new_pose.x + first_rect.width) + 'px', true);
    }

    static setPosition(x, y, container = this.container, container_width, container_height)
    {
        var margin = 40;
        var game_container_rect = document.getElementById('game_container').getBoundingClientRect();
        var rect = container.getBoundingClientRect();
        var endX = game_container_rect.x + game_container_rect.width;
        var endY = game_container_rect.y + game_container_rect.height;


        container_width = container_width ?? rect.width;
        container_height = container_height ?? rect.height;

        x = x ?? Mouse.absX;
        y = y ?? Mouse.absY;

        if(x + container_width + margin >= endX) x = endX - container_width - margin;  
        if(y + container_height + margin >= endY) y = endY - container_height - margin;
        

        set(container, 'style.top', y + 'px', true);
        set(container, 'style.left', x + 'px', true);

        return {x,y};
    }

    static GetPrimaryBonusesDisplayValues(bonus, value, item = this.item)
    {
        var text = bonus.name + ": +" + value;

        switch(bonus.id)
        {
            case STAT.ATTACK_DAMAGE:
                if(item.slot == SLOT.CANNON)
                {
                    var dmg = World.Player.GetDamageValues(value);
                    return bonus.name + ": " + dmg.min + " - " + dmg.max;
                }
                return bonus.name + ': +' + bonus.value + ((bonus.isPercent) ? '%' : '');

            case STAT.ATTACK_SPEED:
                value = (value == parseInt(value)) ? value + ".0" : value;
                return bonus.name + ": " + value;

            case STAT.COOLTIME:
                return bonus.name + ': ' + MathHelper.ticksToSeconds(value) + 's';

            case STAT.DURATION:
                return bonus.name + ': ' + MathHelper.ticksToSeconds(value) + 's';

            case STAT.DASH_DISTANCE:
                var duration = 0;
                for(var i in item.primary)
                {
                    if(item.primary[i].id == STAT.DASH_DURATION) duration = item.primary[i].value;
                }
                return bonus.name + ': ' + World.Player.GetDashDistance(value, duration);

            case STAT.DASH_DURATION:
                return bonus.name + ': ' + MathHelper.ticksToSeconds(value) + 's';

            case STAT.DASH_COOLTIME:
                return bonus.name + ': ' + value + 's';

            case STAT.ATTACK_RANGE:
                return bonus.name + ": " + value;
            
            case STAT.SUMMON_DAMAGE:
                return bonus.name + ": " + value;
        }

        return text;
    }

    static setInterline()
    {
        this.container.appendChild(this.GetLine());
    }

    static GetEnchantBonusLine(bonus, bonusValue = 0, itemGrade)
    {
        var line = this.GetLine();
            
        if(!bonus)
        {
            line.innerText = 'No effect';
            line.className += ' no-effect';
        }
        else
        {
            var name = bonus.name;
            var value = bonus.value;
            var isPercent = (bonus.isPercent) ? "%" : "";
            if(bonus.id == STAT.BLOCK_CHANCE || bonus.id == STAT.CR || bonus.id == STAT.CD) isPercent = '%';
    
            line.innerText = name + " +" + value + isPercent;
        }

        if(bonusValue) 
        {
            var new_value = Math.ceil(value * bonusValue / 100);
            if(bonus.id == STAT.BULLETS_COUNT) new_value = Math.round(value * bonusValue / 100);

            if(new_value)
            {
                var add_line = this.GetLine(" (+" + new_value + ')', 'span');
                add_line.dataset.grade = itemGrade;
                line.appendChild(add_line);
            }
        }

        return line;
    }

    static GetBonusLine(item, bonus)
    {
        var id = bonus.id;
        var bonus_name = bonus.name;
        var value = bonus.value;
        var line = this.GetLine();

        if (value != 0)
        {
            if (value < 0)
            {
                line.className += ' negative';
                line.innerText = bonus_name + ": " + value;
            }
            else
            {
                line.innerText = this.GetPrimaryBonusesDisplayValues(bonus, value);
            }

            //Critical stats are ment to be %, but calculate as non %
            if(id == STAT.CR || id == STAT.CD || id == STAT.BLOCK_CHANCE) line.innerText += "%";
        }

        return line;
    }

    static GetItemNameLine(item, isOnGround)
    {
        var grade = item?.Grade;
        var item_name_info = this.GetItemName(item);
        var display_grade = (grade && grade != GRADE.NORMAL && item.showGrade) ? Lang.Get(grade) : '';

        var name = document.createElement('div');
            name.className = 'line';
            name.dataset.grade = grade;
            if(item_name_info.color) name.style.color = item_name_info.color;       //custom colors
            name.innerText = display_grade + ' ' + item_name_info.name;

            if(isOnGround) name.innerText = '[' + display_grade + ' ' + item_name_info.name + ']';

        return name;
    }

    static GetLine(text, type = 'div', classNames = '')
    {
        var line = document.createElement(type);
            line.className = 'line ' + classNames;
            if(text) line.innerText = text;
        return line;
    }

    static Hide()
    {
        document.querySelectorAll('.item_info_container').forEach(e => e.remove());
        this.item = null;
        this.comparedItem = null;
    }

    static ShowCompared(item, x, y)
    {
        if(!item) return;
        if(this.comparedItem == item) return;

        var tmp = this.container;

        this.comparedItem = item;
        this.Render(item, false, x, y);

        if(tmp) this.container = tmp;
    }
    
    static Show(item, showHandEnchant = true, x, y, isOnGround = false)
    {
        if(!item) return;
        if(this.item == item) 
        {
            this.setPosition(x, y);
            return;
        }

        this.item = item;

        this.Render(item, showHandEnchant, x, y, isOnGround);
    }

    static Render(item, showHandEnchant = true, x, y, isOnGround = false)
    {
        var line, text;

        var bonusValue = 0;
        var HandEnchant = null;
        var HandBlessing = null;
        var HandEnchantIndex = null;
        var gradeInfo = null;

        if(World.Player.hand)
        {
            if(World.Player.hand.type == TYPE.ENCHANT)
            {
                HandEnchantIndex = ItemHelper.CanBeEnchanted(item, World.Player.hand);
                if(HandEnchantIndex != null) HandEnchant = World.Player.hand;
            }

            if(World.Player.hand.type == TYPE.BLESSING)
            {
                if(ItemHelper.CanBeBlessed(item, World.Player.hand)) HandBlessing = World.Player.hand;
            }
        }


        var container = document.createElement('div');
            container.className = 'item_info_container text-stroke';
            document.getElementById('item_infos').appendChild(container);

        this.container = container;
       
        // this.setInterline();
        var name_line = this.GetItemNameLine(item, isOnGround);
            container.appendChild(name_line);

        if(isOnGround)
        {
            this.setPosition(x, y);
            UI_Helper.setTranscendentalText();
            return;
        }


        var primary = item.GetPrimaryBonuses();

        if(primary != null)
        {
            for (var i = 0; i < primary.length; i++)
            {
                var item_bonus = primary[i];
                if(item_bonus)
                {
                    line = this.GetBonusLine(item, item_bonus);
                        container.appendChild(line);
                }
                else break;
            }
        }

        var showEmptySlots = false;

        if(item.enchantAble)
        {
            if(item.Grade != GRADE.NORMAL)
            {
                gradeInfo = ItemHelper.GetGradeInfo(item.Grade);
                if(gradeInfo != null) bonusValue = gradeInfo.bonus;
            }

            var slots = item.getEnchantSlots();
            if(slots > 0)
            {
                for(var i = 0; i < slots; i++)
                {
                    var enchant = item.Enchants[i];
                    var isHandEnchant = false;

                    if(HandEnchant && HandEnchantIndex == i && showHandEnchant)
                    {
                        enchant = HandEnchant;
                        isHandEnchant = true;
                    }

                    if(!enchant && !showEmptySlots) continue;


                    var enchant_line = document.createElement('div');
                        enchant_line.className = 'line enchant';

                    var slot = InventoryGUI.getEmptyInventorySlot();
                        slot.dataset.index = i;
                        enchant_line.appendChild(slot);

                    

                    var enchant_name = this.GetItemNameLine(enchant);
                        enchant_line.appendChild(enchant_name);

                    if(enchant) 
                    {
                        showEmptySlots = true;
                        enchant_name.innerText = '[' + enchant_name.innerText.trim() + ']';
                        slot.querySelector('.image_container img').src = TextureManager.Get(enchant.Texture).src;
                    }
                    else
                    {
                        enchant_name.innerText = "[Empty]";
                        enchant_name.className += ' empty';
                        container.appendChild(enchant_line);
                        continue;
                    }

                    if(item.isEquiped && isHandEnchant) continue;


                    if(enchant instanceof EnchantLock)
                    {
                        enchant_name.innerText = "[Broken slot]";
                        enchant_name.className += ' locked';
                    }
                    else
                    {
                        var enchant_bonus = this.GetEnchantBonusLine(enchant.bonus, bonusValue, item.Grade);
                            enchant_line.appendChild(enchant_bonus);

                        if(isHandEnchant) enchant_line.className += ' hand';
                    }

                    container.appendChild(enchant_line);
                }
            }
        }


        if(item.type == TYPE.ENCHANT)
        {
            if(item.bonus)
            {
                var isPercent = (item.bonus.isPercent) ? "%" : "";
                if(item.bonus.id == STAT.CR || item.bonus.id == STAT.CD || item.bonus.id == STAT.BLOCK_CHANCE) isPercent = "%";

                text = item.bonus.name + " +" + item.bonus.value + isPercent;

                line = this.GetLine(text);
                    container.appendChild(line);
            }
        }


        if(bonusValue && gradeInfo)
        {
            text =  "Enchants` power +" + bonusValue + "%";
            line = this.GetLine(text);
            line.dataset.grade = item.Grade;
                container.appendChild(line);

            if(gradeInfo.specialBonus)
            {
                for(var i = 0; i < gradeInfo.specialBonus.length; i++)
                {
                    var line = this.GetEnchantBonusLine(gradeInfo.specialBonus[i]);
                        line.dataset.grade = item.Grade;
                        container.appendChild(line);
                }
            }
        }

        if(item.ammoCost)
        {
            this.setInterline();
            text =  "Consumes " + item.ammoCost + " oxygen";
            line = this.GetLine(text);
            line.className += ' negative';
                container.appendChild(line);
        }


        if(item.requiredMP && item.showRequiredMP)
        {
            this.setInterline();
            text =  "Required Charge: " + item.requiredMP;
            line = this.GetLine(text);
                container.appendChild(line);
        }

        if(item.Charged)
        {
            var damage = item.Charged.damage ?? World.Player.GetDamageValues(item.Charged.AD, item.Charged.element);
            text =  "Damage: " + damage.min + " - " + damage.max;
            line = this.GetLine(text, 'div', item.Charged.element);
                container.appendChild(line);
        }

        var desc = item.getChargeDescription();
        if(desc)
        {
            for(var i = 0; i < desc.length; i++)
            {
                if(desc[i] != null)
                {
                    text = desc[i];
                    line = this.GetLine(text);
                    // line.className += ' lore';
                        container.appendChild(line);

                    var color_data = Style.GetCustomTextColor(desc[i]);
                    if(color_data.color) line.style.color = color_data.color;
                    line.innerHTML = Style.ColorizeTextParts(color_data.text);
                }
            }
        }



        desc = item.getDescription();
        if(desc)
        {
            this.setInterline();
            for(var i = 0; i < desc.length; i++)
            {
                if(desc[i] != null)
                {
                    text = desc[i];
                    line = this.GetLine(text);
                    // line.className += ' lore';
                        container.appendChild(line);

                    var color_data = Style.GetCustomTextColor(desc[i]);
                    if(color_data.color) line.style.color = color_data.color;
                    line.innerHTML = Style.ColorizeTextParts(color_data.text);
                }
            }
        }


        if(item.Lore)
        {
            this.setInterline();
            var lore = item.getLore();

            for(var i = 0; i < lore.length; i++)
            {
                if(lore[i] != null)
                {
                    text = lore[i];
                    line = this.GetLine(text);
                    line.className += ' lore';
                        container.appendChild(line);

                    var color_data = Style.GetCustomTextColor(lore[i]);
                    if(color_data.color)
                    {
                        line.style.color = color_data.color;
                        line.innerText = color_data.text;
                    }
                }
            }
        }


        if(item.isMaterial())
        {
            this.setInterline();
            text = "Material";
            line = this.GetLine(text);
                container.appendChild(line);
        }


        if(HandEnchantIndex != null && !item.isEquiped && item.enchantAble && showHandEnchant)
        {
            this.setInterline();
            text = "Drop to enchant";
            line = this.GetLine(text);
            line.className += ' start_ench';
                container.appendChild(line);
        }


        // if(HandBlessing && !item.isEquiped)
        // {
        //     this.setInterline();
        //     text = "Drop to bless";
        //     line = this.GetLine(text);
        //     line.className += ' start_bless';
        //         container.appendChild(line);
        // }


        // if (item.equipAble)
        // {
        //     interLine += interLineStep;
        //     this.style.color = "lightgray";
        //     text = "[Slot: " + Lang.Translate(item.slot) + "]";

        //     width = Style.GetTextSize(text, this.style).width;

        //     if (width > heighestWidth)
        //     {
        //         heighestWidth = width;
        //     }

        //     DisplayLines.push(new ItemInfoDisplayLine(width, this.height, interLine, text, this.style.color));

        //     interLine += interLineStep;
        // }


        if(item.type == TYPE.QUEST_ITEM)
        {
            this.setInterline();
            text = Lang.Get('ITEM.QUEST.DESCRIPTION');
            line = this.GetLine(text);
            line.dataset.grade = item.Grade;
                container.appendChild(line);
        }

        if(item.isUnique)
        {
            this.setInterline();
            text = '~'+Lang.Get('ITEM.UNIQUE')+'~';
            line = this.GetLine(text);
            line.dataset.grade = item.Grade;
                container.appendChild(line);
        }


        if((InventoryGUI.isShopOpen || Settings.General.AlwaysShowItemPrice) && item.showPriceInfo && item.type != TYPE.QUEST_ITEM && !item.isUnique)
        {
            var priceInfo = ItemHelper.GetItemPrice(item);
            var price = priceInfo.sell;

            if(item.isInShop || item.isFromMerchant) price = priceInfo.buy;

            if(price)
            {
                if(item.canBeSold)
                {
                    text = "Price: " + Style.DottedText(price);
                    if(item.count >= 10) text += ' (' + Style.DottedText(price / item.count) + ' / x1)';
                }

                this.setInterline();

                line = this.GetLine(text);
                if(price > 100000) line.className += ' price';

                if(!item.canBeSold) 
                {
                    line.className += ' negative';
                    line.innerText = 'Cannot be sold.';
                }
                
                container.appendChild(line);
            }
        }

        this.setPosition(x, y);
        UI_Helper.setTranscendentalText();
    }

    static GetItemName(item)
    {
        if(!item) return {name: '', color: null}

        var color_data = Style.GetCustomTextColor(item.getDisplayName());

        var name = color_data.text;
        var color = color_data.color;

        return {name, color};
    }
}

class KnowledgeGUI
{
    static Open()
    {
        this.isOpen = true;

        this.CreateLocationList();
    }

    static Close()
    {
        this.isOpen = false;
    }

    static Update()
    {
        if(!this.isOpen) return;

    }

    static Render()
    {
        if(!this.isOpen) return;
    }


    static ShowLocationInfo(id)
    {
        var container = document.getElementById('knowledge_location_info');
            container.innerHTML = '';

        document.getElementById('knowledge_location_list').querySelectorAll('.item').forEach(e => e.dataset.selected = 'false');
        document.getElementById('knowledge_location_list').querySelector('.item[data-id="'+id+'"]').dataset.selected = 'true';

        var locations = World.LocationList;
        var locationInfo = World.Player.locationInfo;
        var location = locations[id];

        if(!location) return;
        if(!locationInfo[id].isCleared) return;

        if(!locationInfo[id].gotKnowledge) this.ShowBuyInfo(container, id);
        else this.ShowInfo(container, id);        
    }

    static GetKnowledgePrice(id)
    {
        var base_price = 1000;

        var locationsId = getLocationOrder(true);
        var index = locationsId.indexOf(id);

        return base_price * index;
    }

    static BuyKnowledge(id)
    {
        var price = this.GetKnowledgePrice(id);

        if(World.Player.coins >= price)
        {
            World.Player.coins -= price;
            World.Player.locationInfo[id].gotKnowledge = true;
            Save();

            this.ShowLocationInfo(id);
        }
    }

    static ShowBuyInfo(container, id)
    {
        var button = document.createElement('div');
            button.className = 'buy_knowledge';
            button.dataset.id = id;
            button.addEventListener('click', function(){KnowledgeGUI.BuyKnowledge(this.dataset.id)});

        var icon = document.createElement('div');
            icon.className = 'icon';
            icon.dataset.icon = 'knowledge';

        var title_container = document.createElement('div');
            title_container.className = 'title_container';
        
        var title = document.createElement('div');
            title.className = 'button_title';
            title.innerText = Lang.Get('MENU.KNOWLEDGE.UNLOCK');

        var price = document.createElement('div');
            price.className = 'price';
            price.innerText = Lang.Get('MENU.KNOWLEDGE.PRICE', {price: Style.DottedText(this.GetKnowledgePrice(id))});;

        button.appendChild(icon);
        button.appendChild(title_container);

        title_container.appendChild(title);
        title_container.appendChild(price);

        container.appendChild(button);
    }

    static UpdatePreviews()
    {
        document.querySelectorAll('#knowledge_location_info .preview .image_container').forEach(e => 
        {
            var id = e.dataset.entityid;
            var entity = KnowledgeGUI.Entities[id];
            if(!entity) return;

            if(entity.Model) entity.Model.Update();

            var _canvas = e.querySelector('canvas');
            var _ctx = _canvas.getContext('2d');

            _ctx.clearRect(0, 0, _canvas.width, _canvas.height);

            entity.Render(_ctx);
        });
    }


    static ShowInfo(container, id)
    {
        var locations = getLocationOrder(false, {VILLAGE: true});
        var locationsId = getLocationOrder(true, {VILLAGE: true});
        var locationInfo = World.Player.locationInfo;

        var location = locations[locationsId.indexOf(id)];
        var entities = location.RoomInfo.EntityTypes;
        var bosses = location.RoomInfo.BossTypes;
        var entityList = World.EntityList;

        var rank = locationInfo[id].rank ?? 'F';

        var rank_color = 'var(--color-rank-' + (rank.replace('+', '').replace('-', '').toLowerCase()) + ')';

        KnowledgeGUI.Location = id;
        KnowledgeGUI.Entities = [];

        var content = document.createElement('div');
            content.className = 'content';

        var title = document.createElement('div');
            title.className = 'title';

        var title_name = document.createElement('span');
            title_name.className = 'text-stroke-2';
            title_name.innerText = Lang.Get(location.Name);

        var grade = document.createElement('span');
            grade.className = 'grade';
            grade.innerText = rank;
            grade.style.setProperty('color', rank_color)

        title.appendChild(title_name);
        title.appendChild(grade);


        var preview_container = document.createElement('div');
            preview_container.className = 'preview';

        for(var i in entities)
        {
            var entity = new entityList[entities[i]]();
                entity.setLevel(getLocationLevel(KnowledgeGUI.Location));

            KnowledgeGUI.Entities.push(entity);
            
            var icon_img = Graphic.createEntityPreview(entity);

            var image_container = document.createElement('div');
                image_container.className = 'image_container';
                image_container.dataset.entityid = i;
                image_container.dataset.current = 'false';
                image_container.addEventListener('click', function()
                {
                    document.querySelectorAll('#knowledge_location_info .preview .image_container').forEach(e => 
                    {
                        e.dataset.current = 'false';
                    });

                    this.dataset.current = 'true';
                    KnowledgeGUI.showEntityInfo(this.dataset.entityid);
                });
            if(i == 0) image_container.dataset.current = 'true';

            image_container.appendChild(icon_img);
            preview_container.appendChild(image_container);
        }

        for(var j in bosses)
        {
            var entity = new entityList[bosses[j]]();
                entity.setLevel(getLocationLevel(KnowledgeGUI.Location));
                entity.knowledgeBoss = true;
            
            KnowledgeGUI.Entities.push(entity);
            
            var icon_img = Graphic.createEntityPreview(entity);

            var image_container = document.createElement('div');
                image_container.className = 'image_container boss';
                image_container.dataset.entityid = (j*1)+(i*1)+1;
                image_container.dataset.current = 'false';
                image_container.addEventListener('click', function()
                {
                    document.querySelectorAll('#knowledge_location_info .preview .image_container').forEach(e => 
                    {
                        e.dataset.current = 'false';
                    });

                    this.dataset.current = 'true';
                    KnowledgeGUI.showEntityInfo(this.dataset.entityid);
                });

            image_container.appendChild(icon_img);
            preview_container.appendChild(image_container);
        }




        var entity_info_container = document.createElement('div');
            entity_info_container.id = 'enemy_info_container';



        content.appendChild(title);
        content.appendChild(preview_container);
        content.appendChild(entity_info_container);

        container.appendChild(content);


        DraggableScroll.Init(document.querySelector('#enemy_info_container'), {accY: .1});
        this.showEntityInfo(0);
    }

    static showEntityInfo(id)
    {
        // var entityList = World.EntityList;
        // var entity = new entityList[id]();
        //     entity.setLevel(getLocationLevel(KnowledgeGUI.Location));
        var entity = KnowledgeGUI.Entities[id];

        var container = document.getElementById('enemy_info_container');
            container.innerHTML = '';

        if(!entity) return;

        var display_name = entity.getDisplayName() ?? "";
        if(entity.isBoss || entity.knowledgeBoss) display_name = '[BOSS] ' + display_name;

        var lootTable = entity.LootTable?.itemList ?? [];

        var name = document.createElement('div');
            name.className = 'name text-stroke';
            name.innerText = display_name;

        var level_container = document.createElement('div');
            level_container.className = 'level text-stroke';

        var level = document.createElement('span');
            level.innerText = Lang.Get('MENU.KNOWLEDGE.LEVEL', {LEVEL: entity.level});

        var xp = document.createElement('span');
            xp.innerText = Lang.Get('MENU.KNOWLEDGE.XP', {XP: Oxygen.GetOxygenValue(entity.getOxygen(), World.Player.stats.Level, entity.level, entity.isBoss)});

        var section_top = document.createElement('div');
            section_top.className = 'section_top text-stroke';

        var hp_stat_container = document.createElement('div');
            hp_stat_container.className = 'stat';

        var hp_icon = document.createElement('div');
            hp_icon.className = 'icon';
            hp_icon.dataset.icon = 'heart';

        var hp = document.createElement('div');
            hp.innerText = Style.DottedText(entity.MAXHP);

        var description = document.createElement('div');
            description.className = 'description text-stroke';
            description.innerText = entity.getDescription() ?? '';

        var drop_list = document.createElement('div');
            drop_list.className = 'drop_list';

        var drop_items = [new LootTableItemData('ItemOxygen')].concat(lootTable);

        for(var i in drop_items)
        {
            var item_id = drop_items[i].Type;
            var item = ItemHelper.getInstanceOfItem(item_id, {Grade: GRADE.NORMAL, count: 1});
            if(item_id == 'ItemOxygen') item = ItemHelper.getInstanceOfItem(item_id, {Grade: GRADE.NORMAL, count: entity.getOxygen()*2});

            var slot = InventoryGUI.getEmptyInventorySlot();
                slot.dataset.item = item_id;
                slot.style.setProperty('--order', i)
                slot.addEventListener('mousemove', function()
                {
                    if(!KnowledgeGUI.showingItem)
                    {
                        KnowledgeGUI.showingItem = ItemHelper.getInstanceOfItem(this.dataset.item, {Grade: GRADE.NORMAL, count: 1});
                    }
                    ItemInfo.Show(KnowledgeGUI.showingItem);
                });
                slot.addEventListener('mouseout', function()
                {
                    KnowledgeGUI.showingItem = false;
                    InventoryGUI.clearHighlights(this);
                });

            InventoryGUI.UpdateSlot(slot, item);

            drop_list.appendChild(slot);
        }

        
        level_container.appendChild(level);
        level_container.appendChild(xp);

        hp_stat_container.appendChild(hp_icon);
        hp_stat_container.appendChild(hp);

        section_top.appendChild(name);
        section_top.appendChild(level_container);
        section_top.appendChild(hp_stat_container);

        container.appendChild(section_top);
        container.appendChild(description);
        container.appendChild(drop_list);
    }


    static CreateLocationList()
    {
        var container = document.getElementById('knowledge_location_list');
            container.innerHTML = '';

        var location, id, cleared;
        var locations = getLocationOrder(false, {VILLAGE: true});
        var locationsId = getLocationOrder(true, {VILLAGE: true});
        var locationInfo = World.Player.locationInfo;

        for(var i in locationsId)
        {
            id = locationsId[i];
            location = locations[i];

            cleared = locationInfo[id].isCleared;

            var item = document.createElement('div');
                item.className = 'item';
                item.innerText = location.GetDisplayName();
                item.dataset.id = id;
                item.addEventListener('click', function(){KnowledgeGUI.ShowLocationInfo(this.dataset.id)});

            if(!cleared)
            {
                item.innerText = '???';
                item.dataset.locked = 'true';
            }

            container.appendChild(item);
        }



        this.ShowLocationInfo(locationsId[0]);
    }
}class MiniMap
{
    static Init()
    {
        
    }


    static drawPoint(x, y, data, isActiveMapTile = false)
    {
        var container = document.getElementById('world_map_points');
        var rank = data.rank ?? '';
        var abs_rank = rank.replace('+', '').replace('-', '').toLowerCase();

        var p = document.createElement('div');
            p.className = 'point text-stroke';
            p.style.top = y + 'px';
            p.style.left = x + 'px';
            p.innerText = rank;
            p.dataset.location_id = data.id;
            p.dataset.name = data.name;
            p.dataset.inactivehex = isActiveMapTile;
            if(data.specialIcon)
            {
                p.dataset.icon = data.specialIcon;
                p.className += ' icon';
            }

            p.style.setProperty('color', 'var(--color-rank-' + abs_rank + ')');
            if(data.isCurrent) p.dataset.current = 'true';

            p.dataset.village = data.isVillage;
            p.dataset.cleared = data.isCleared;
            p.dataset.locationfamily = data.id.toLowerCase().replace(/[0-9]/, '').replace(' ', '');
            if(!data.canInteract) p.style.pointerEvents = 'none';
            else
            {
                p.addEventListener('click', function()
                {
                    var result = Commands.GoToLocation(this.dataset.location_id);
                    if(result == true)
                    {
                        UI_Helper.Hide('#world_map');
                    }
                    else
                    {
                        console.error(result);
                    }
                });
            }

        container.appendChild(p);

        this.LOCATION_POINTS_HISTORY[data.id] = {x, y, cleared: data.isCleared};
    }




    static Render()
    {
        
    }
}class QuestLine
{
    constructor()
    {
        this.requiredLevel = 0;
        this.requiredQuest = null;

        this.name = 'QUEST';
        this.Description = '';
        this.Icon = 'quest';
        this.NPC = null;
        this.dialogLine = this.constructor.name;
        this.dialogLineComplete = this.dialogLine+'Complete';
    }

    getDisplayName(isComplete = false)
    {
        var name = Lang.Get(this.name);
        if(isComplete) name += ' ('+Lang.Get('QUEST.COMPLETE')+')';

        return name;
    }

    getDescription()
    {
        return Lang.Get(this.Description);
    }

    getId()
    {
        return this.constructor.name.toUpperCase();
    }

    isCompleted()
    {
        return World.Player.QuestData[this.getId()]?.complete;
    }

    checkForCompletion()
    {
        return false;
    }

    Update()
    {
        if(this.isCompleted()) return;
    }

    isAvailable()
    {
        if(this.isActive()) return false;
        if(this.requiredQuest) 
            if(!World.Player.QuestData[this.requiredQuest.toUpperCase()]?.complete) return false;

        return (World.Player.stats.Level >= this.requiredLevel);
    }

    isActive()
    {
        return World.Player.QuestData[this.getId()]?.active;
    }


    Activate()
    {
        if(!this.isAvailable()) return;

        World.Player.QuestData[this.getId()] = new QuestData();
        Save();
    }


    Complete()
    {
        World.Player.QuestData[this.getId()].complete = true;

        this.GetReward();

        Save();
    }

    GetProgress(){return 0;}

    GetReward()
    {

    }

    CheckEntityDeath(entityId, entity)
    {

    }
}






class QuestLineFindItem extends QuestLine
{
    constructor()
    {
        super();

        this.requiredItem = '';
        this.Chance = 100;
        this.EntityList = [];
        this.WholeLocation = '';
    }

    checkForCompletion()
    {
        if(World.Player.haveItemInInventory(this.requiredItem) > -1) return true;

        return super.checkForCompletion();
    }

    CheckEntityDeath(entity)
    {
        var id = entity.constructor.name;
        if(this.WholeLocation) 
            this.EntityList = get(World, 'LocationList.'+this.WholeLocation+'.RoomInfo.EntityTypes').concat(get(World, 'LocationList.'+this.WholeLocation+'.RoomInfo.BossTypes'));
        
        if(this.EntityList.indexOf(id) == -1) return;
        
        if(MathHelper.GetChance(this.Chance))
        {
            var item = Item.Get(this.requiredItem);

            World.AddEntity(new EntityItem(item, entity.x, entity.y));
        }
    }

    Complete()
    {
        var slot_id = World.Player.haveItemInInventory(this.requiredItem);
        World.Player.inventory[slot_id] = null;

        super.Complete();
    }
}




class QuestList
{
    static Init(quest)
    {
        if(!this.List) this.List = {};

        var id = quest.name.toUpperCase();
        this.List[id] = new quest();
    }

    static Accept(id)
    {
        id = id.toUpperCase();
        if(!this.List[id]) return;

        this.List[id].Activate();
    }

    static Complete(id)
    {
        id = id.toUpperCase();
        if(!this.List[id]) return;

        this.List[id].Complete();
    }

    static GetAvailableQuests(npc_id = null)
    {
        if(npc_id) npc_id = npc_id.toUpperCase();
        var available = [];
        for(var i in this.List)
        {
            var quest = this.List[i];
            if(quest.isAvailable()) 
            {
                if(!npc_id || quest.NPC == npc_id) available.push(quest);
            }
        }

        return available;
    }

    static GetQuestsToComplete(npc_id = null)
    {
        if(npc_id) npc_id = npc_id.toUpperCase();

        var to_complete = [];
        for(var i in this.List)
        {
            var quest = this.List[i];
            if(!quest.isCompleted() && quest.isActive() && quest.checkForCompletion()) 
            {
                if(!npc_id || quest.NPC == npc_id) to_complete.push(quest);
            }
        }

        return to_complete;
    }

    static GetCompletedQuests(npc_id = null)
    {
        if(npc_id) npc_id = npc_id.toUpperCase();

        var completed = [];
        for(var i in this.List)
        {
            var quest = this.List[i];
            if(quest.isCompleted()) 
            {
                if(!npc_id || quest.NPC == npc_id) completed.push(quest);
            }
        }

        return completed;
    }


    static GetActiveQuests(npc_id = null)
    {
        if(npc_id) npc_id = npc_id.toUpperCase();

        var active = [];
        for(var i in this.List)
        {
            var quest = this.List[i];
            if(!quest.isCompleted() && quest.isActive()) 
            {
                if(!npc_id || quest.NPC == npc_id) active.push(quest);
            }
        }

        return active;
    }

    static CheckEntityDeath(entity)
    {
        var quest_to_check = this.GetActiveQuests();

        for(var i in quest_to_check)
        {
            var quest = quest_to_check[i];
                quest.CheckEntityDeath(entity);
        }
    }



    static CreateList()
    {
        var container = document.getElementById('quest_list');
            container.innerHTML = '';

        var active = this.GetActiveQuests();
        var completed = this.GetCompletedQuests();

        var list = active.concat(completed);
        for(var i in list)
        {
            var quest = list[i];
            var progress = quest.GetProgress();
            var completed = quest.isCompleted();
            var img = TextureManager.Get(quest.Icon);
            if(completed) progress = 100;

            var item = document.createElement('div');
                item.className = 'item';
                item.dataset.completed = completed;
            
            var icon = document.createElement('div');
                icon.className = 'icon';
                icon.dataset.icon = quest.Icon;

            var title = document.createElement('div');
                title.className = 'quest_title';
                title.innerText = quest.getDisplayName();

            var description = document.createElement('div')
                description.className = 'quest_description';
                description.innerHTML = quest.getDescription();

            var quest_bar = document.createElement('div');
                quest_bar.className = 'progress_bar';
                quest_bar.style.setProperty('--progress', progress+'%');

            var quest_bar_bg_container = document.createElement('div');
                quest_bar_bg_container.className = 'progress_bar_background_container';

            var quest_bar_bg = document.createElement('div');
                quest_bar_bg.className = 'progress_bar_background bubble-progress';

            item.appendChild(icon);
            item.appendChild(title);
            item.appendChild(description);
            item.appendChild(quest_bar);

            quest_bar.appendChild(quest_bar_bg_container);
            quest_bar_bg_container.appendChild(quest_bar_bg);

            container.appendChild(item);

            if(img.name != 'none')
            {
                var _img = document.createElement('img');
                _img.src = img.src;
                icon.appendChild(_img);
            }
        }
    }
}


class QuestData
{
    constructor()
    {
        this.complete = false;
        this.active = true;
    }
}class LocationRadar
{
    static getColors()
    {
        var c =
        {
            player: '#0088FF',
            entity: 'red',
            npc: 'white'

        };
        return c;
    }

    static Render()
    {
        var canvas = document.getElementById('location_radar_canvas');
        var ctx = canvas.getContext('2d');

        var size = getCssVariable('#location_radar', '--size', true);
		var point_size = 7;
		var entity_point = point_size - 2;
		
		var scale = (World.Radius * 2) / size;

        canvas.width = size;
        canvas.height = size;
        ctx.clearRect(0, 0, size, size);


        //dont render entities while moving to new room
        if(World.isChangingLocation) return;

        var color, s, entity, x, y;
        var colors = this.getColors();
		
		// ctx.save();
		// // ctx.fillStyle = "black";
		// // ctx.globalAlpha = 0.2;
		// ctx.fillStyle = "white";
		// ctx.globalAlpha = 0.1;
		// ctx.beginPath();
		// ctx.arc(x + width / 2, y + height / 2, width / 2 + 5, 0, 2 * Math.PI);
		// ctx.fill();
		// ctx.restore();
		
		// ctx.save();
		// ctx.lineWidth = 5;
		// ctx.strokeStyle  = "lightgray";
		// ctx.beginPath();
		// ctx.arc(x + width / 2, y + height / 2, (width / 2) + 5, 0, 2 * Math.PI);
		// ctx.stroke();
		// ctx.restore();

		for(var i = 0; i < World.Entities.length; i++)
		{
			s = 0;
			color = "red";
			entity = World.Entities[i];

			if(entity.isHidden) continue;
			if(entity.isFromPlayer) continue;		//do not show player dummies
			if(entity.hideOnRadar) continue;

			if((entity instanceof Oxygen) || (entity instanceof EntityItem))
			{
				s = 3;
				color = colors.npc;

                //do not show 'empty' oxygens
				if(!entity.value) continue;
			}
            if(entity instanceof EntityItem)
            {
                if(entity?.item?.Grade)
                {
                    var g_name = entity.item.Grade.replace('GRADE_', '').toLowerCase();
                    if(g_name != 'normal' && g_name != 'transcendental')
                        color = getCssVariable(document.body, '--color-grade-'+g_name);
                }
            }

			if(entity.isNPC) color = colors.npc;
			
			x = (entity.x / scale) - ((World.Width / 2 - World.Radius) / scale);
			y = (entity.y / scale) - ((World.Width / 2 - World.Radius) / scale);
			
			ctx.save();
			ctx.fillStyle = color;
			ctx.beginPath();
			ctx.arc(x, y, entity_point - s, 0, 2 * Math.PI);
			ctx.fill();
			ctx.restore();
		}

        x = (World.Player.x / scale) - ((World.Width / 2 - World.Radius) / scale);
        y = (World.Player.y / scale) - ((World.Width / 2 - World.Radius) / scale);

		ctx.save();
		ctx.fillStyle = colors.player;
		ctx.beginPath();
		ctx.arc(x, y, point_size, 0, 2 * Math.PI);
		ctx.closePath();
		ctx.fill();
		ctx.restore();
    }
}class SaveSelectionGUI
{
    static Open()
    {
        this.CtxList = {};
        this.PreviewList = {};
        this.SavesPreviews = {};
        this.PreviewWidth = 0;
        this.PreviewHeight = 0;

        this.saveSlots = 3;

        this.Dummies = [];
        this.isOpen = true;

        this.CreateList();
        this.OpenedAt = Main.ageInTicks;
    }

    static Close()
    {
        this.isOpen = false;
    }

    static Update()
    {
        if(!this.isOpen) return;
    }

    static Render()
    {
        if(!this.isOpen) return;

        for(var i in this.Dummies)
        {
            var _canvas = this.PreviewList[i];
            var _ctx = this.CtxList[i];
            var dummy = this.Dummies[i];

            _ctx.clearRect(0, 0, _canvas.width, _canvas.height);
            dummy.Render(_ctx);
        }
    }


    static CreateList()
    {
        this.Dummies = {};
        var container = document.getElementById('saves');
            container.innerHTML = '';

        var delete_container = document.getElementById('saves_nav_bottom');
            delete_container.innerHTML = '';


        var canvas_width = getCssVariable('#save_selection_gui', '--save-block-canvas-width', true);
        var canvas_height = getCssVariable('#save_selection_gui', '--save-block-canvas-height', true);

        this.PreviewWidth = canvas_width;
        this.PreviewHeight = canvas_height;

        for(var i = 0; i < this.saveSlots; i++)
        {
            var gotSavedData = false;
            var save_id = "PLAYER_SAVE_"+i;
            var save = localStorage.getItem(save_id);

		    if(save && save != 'null' && isJSON(save))
            {
                var Dummy = new Player();
                    Dummy.LoadData(save);
                    Dummy.Update();
                    Dummy.Rotation = 180;
                    Dummy.Scale = 2;
                    Dummy.x = this.PreviewWidth / 2;
                    Dummy.y = this.PreviewHeight * .6;
                    Dummy.ChangeSkin(Dummy.Appearance.Skin);
                this.Dummies[i] = Dummy;

                gotSavedData = true;
            }

            var save_container = document.createElement('div');
                save_container.className = 'save';
                if(!gotSavedData) 
                {
                    save_container.className +=' empty';
                    save_container.innerText = Lang.Get('SAVE_SLOT.EMPTY');
                }
                save_container.dataset.save = save_id;
                save_container.addEventListener('click', function()
                {
                    if(Main.ageInTicks <= SaveSelectionGUI.OpenedAt + Main.FPS/2) return;

                    Main.SaveSlot = this.dataset.save;
                    Menu.Transition(function()
                    {
                        InGame.Run();
                        World.Initialize();
                        World.Player.Load();
                    });
                });

            var preview = document.createElement('canvas');
                preview.className = 'preview';
                preview.width = canvas_width;
                preview.height = canvas_height;
                save_container.appendChild(preview);

            this.PreviewList[i] = preview;
            this.CtxList[i] = preview.getContext('2d');

            var info = document.createElement('div');
                info.className = 'info';
                save_container.appendChild(info);

            var div = document.createElement('div');
                div.innerText = Lang.Get('MENU.LOADING.READY');
                div.className = 'start';
                info.appendChild(div);

            if(gotSavedData)
            {
                var data = 
                {
                    'LOCATION': World.LocationList[Dummy.startLocation]?.Name,
                    'STAT.LEVEL': Dummy.stats.Level,
                    'DIFFICULTY': Dummy.Difficulty == 0 ? 'DIFFICULTY.EASY.NAME' : Dummy.Difficulty == 1 ? 'DIFFICULTY.MEDIUM.NAME' : 'DIFFICULTY.HARD.NAME'
                };

                for(var j in data)
                {
                    var div = document.createElement('div');
                        div.innerText = Lang.Get(j) + ': ' + Lang.Get(data[j]);
                    info.appendChild(div);
                }
            }

            container.appendChild(save_container);




            var delete_icon = document.createElement('div');
                delete_icon.className = 'delete icon';
                delete_icon.dataset.icon = 'icon_trash';
                if(gotSavedData)
                {
                    delete_icon.dataset.save = save_id;
                    delete_icon.addEventListener('click', function()
                    {
                        if(Main.ageInTicks <= SaveSelectionGUI.OpenedAt + Main.FPS/2) return;

                        UI_Helper.showConfirm('SAVE_SLOT.DELETE', 'CONFIRM.YES', 'CONFIRM.NO', ()=>{localStorage.setItem(this.dataset.save, null); SaveSelectionGUI.CreateList()});    
                    });
                }
                else
                {
                    delete_icon.style.opacity = 0;
                }
                delete_container.appendChild(delete_icon);
        }
    }
}class UI_Helper
{
    static Init()
    {
        UI_Helper.History = [];
        UI_Helper.addHistory = true;
        
        UI_Helper.TranslateUI();
        UI_Helper.InitDraggableWindows();
        UI_Helper.InitSliders();

        UI_Helper.InitSettings();
        UI_Helper.InitMenu();
        UI_Helper.InitPause();
        UI_Helper.InitInGame();

        WorldMap.Init();
    }


    static CatchEscape()
    {
        var isHistoryEmpty = (UI_Helper.History.length == 0) ? true : false;

        if(isHistoryEmpty && Main.RUNNING == RUNNING.INGAME)
        {
            InGame.Pause();
            return;
        }

        if(isHistoryEmpty && Main.RUNNING == RUNNING.MENU)
        {
            //QUIT
            return;
        }

        UI_Helper.removeHistoryElement();
    }

    static addHistoryElement(element, property, value, id = '', onRemove, removeSound)
	{
		UI_Helper.History.push(
            {
                id: id,
                element: element,
                property: property,
                value: value,
                onRemove: onRemove,
                removeSound: removeSound
            }
        );
	}

    static getHistoryIndex(id)
    {
        for(var i in UI_Helper.History)
        {
            var entry = UI_Helper.History[i];
            if(entry.id == id) return i;
        }
        return -1;
    }

	static removeHistoryElement(id = null)
	{
		var index = UI_Helper.History.length - 1;

        if(id) index = UI_Helper.getHistoryIndex(id);
        if(index == -1) return;

        var entry = UI_Helper.History[index];
        if(!entry) return;

        var id = entry.id;
        var element = entry.element;
        var property = entry.property;
        var value = entry.value;
        var onRemove = entry.onRemove;
        var removeSound = entry.removeSound;

        if(removeSound) SoundManager.Play(removeSound, 'EFFECT');
        UI_Helper.History.splice(index, 1);
        if(isFunction(onRemove)) onRemove();

        if(property == 'remove')
        {
            element.remove();
            return;
        }

        set(element, property, value);
	}

    static TranslateUI()
    {
        var els = document.querySelectorAll('[data-translate]');
        els.forEach(e => {e.innerText = Lang.Get(e.dataset.translate)});
    }

    static setBarProgress(id, progress, updateContent = true, _content = false)
    {
        var bar = document.getElementById(id);
        if(!bar) return;
        bar.style.setProperty('--progress', progress);

        if(!updateContent) return;
        var content = bar.querySelector('.progress_bar_content');
        if(!content) return;

        var contentInner = (_content) ? _content : progress;
        set(content, 'innerText', contentInner, true);
    }

    static Fade(onEnd, duration = 2)
    {
        var remove = function(){this.remove()};
        var container = document.getElementById('ui_container');

        var fade_trans = document.createElement('div');
            fade_trans.className = 'fade-transition';
            fade_trans.style.animationDuration = duration + 's';
            fade_trans.addEventListener('animationend', onEnd);
            fade_trans.addEventListener('animationend', remove);

            container.appendChild(fade_trans);
    }


    static InitDraggableWindows()
    {
        DraggableWindow.Init(document.getElementById('settings_window_handle'));
        DraggableWindow.Init(document.getElementById('world_map_handle'));
        DraggableWindow.Init(document.getElementById('inventory_handle'));
        DraggableWindow.Init(document.getElementById('inventory_equips_handle'));
        DraggableWindow.Init(document.getElementById('player_stats_handle'));
        DraggableWindow.Init(document.getElementById('knowledge_handle'));
        DraggableWindow.Init(document.getElementById('quests_handle'));
    }

    static isOpen(id)
    {
        var el = document.getElementById(id);
        if(!el) return false;
        if(el.dataset.open != 'true') return false;

        return true;
    }


    static Open(id, hide = true, classSelector, onRemove)
    {
        classSelector = classSelector ?? 'ui';
        if(hide) UI_Helper.Hide('.' + classSelector);
        var el = document.getElementById(id);

        if(el.dataset.draggable == 'true' && Settings.General.AlwaysReposeWindows)
        {
            DraggableWindow.ResetPosition(el);
        }

        el.dataset.open = 'true';
        if(UI_Helper.addHistory) UI_Helper.addHistoryElement(el, 'dataset.open', false, id, onRemove);
        UI_Helper.addHistory = true;
    }

    static Hide(classSelector = '.ui', removeHistory = true)
    {
        var id = classSelector.replace('.', '').replace('#', '');
        if(removeHistory && UI_Helper.getHistoryIndex(id) != -1) UI_Helper.removeHistoryElement(id);

        var uis = document.querySelectorAll(classSelector+':not([data-keep_open="true"])');
        uis.forEach(e => e.dataset.open = 'false');
    }

    static Toggle(id, onRemove, hide = false, classSelector = null)
    {
        var el = document.getElementById(id);
        if(el.dataset.open == 'true')
        {
            if(UI_Helper.getHistoryIndex(id) != -1) UI_Helper.removeHistoryElement(id);
            else UI_Helper.Hide('#' + id);
        }
        else
        {
            UI_Helper.Open(id, hide, classSelector, onRemove);
        }
    }

    static ToggleWorldMap()
    {
        var id = 'world_map';
        var el = document.getElementById(id);

        UI_Helper.Toggle(id);
        

        if(el.dataset.open == 'true')
        {
            //render
            WorldMap.Render();
        }
    }


    static ToggleQuestLog()
    {
        var id = 'quests';
        var el = document.getElementById(id);

        UI_Helper.Toggle(id);

        if(el.dataset.open == 'true') QuestList.CreateList();
    }

    // static ToggleDialog()
    // {
    //     var id = 'talk_with';
    //     var el = document.getElementById(id);

    //     UI_Helper.Toggle(id, DialogGUI.Close);

    //     UI_Helper.Open('talk_with', false, null, DialogGUI.Close);
    //     if(el.dataset.open == 'true') DialogGUI.Open();
    // }


    static TogglePlayerStats(ignoreInv)
    {
        var id = 'player_stats';
        var inv = document.getElementById('inventory');
        var el = document.getElementById(id);

        //cannot hide stats when inventory is open
        if(el.dataset.open == 'true' && inv.dataset.open == 'true' && !ignoreInv) return;

        UI_Helper.Toggle(id);

        if(el.dataset.open == 'false') el.dataset.selfopen = 'false';
    }


    static ToggleInventory(id = 'inventory', owner = World.Player, items_path = 'inventory')
    {
        var el = document.getElementById(id);

        UI_Helper.Toggle(id, () => {
            if(id == 'inventory') 
            {
                if(World.Player.hand)
                {
                    World.Player.addItemToInventory(World.Player.hand);
                    World.Player.hand = null;
                    InventoryGUI.UpdateHand();
                }

                UI_Helper.Hide('#inventory_equips');
                var stats = document.getElementById('player_stats');
                if(stats.dataset.selfopen != 'true' && stats.dataset.open == 'true') UI_Helper.TogglePlayerStats(true);
            }
        });

        if(el.dataset.open == 'true')
        {
            InventoryGUI.Update(id, owner, items_path);
            
            if(id == 'inventory')
            {
                UI_Helper.addHistory = false;
                UI_Helper.Open('inventory_equips', false);
                InventoryGUI.Update('inventory_equips', World.Player, 'equips');

                var stats = document.getElementById('player_stats');
                if(stats.dataset.open == 'true') stats.dataset.selfopen = 'true';
                else 
                {
                    UI_Helper.addHistory = false;
                    UI_Helper.TogglePlayerStats();
                }
            }
        }
    }

    static OpenShop(owner, items_path)
    {
        var remove = function()
        {
            World.Player.interactionWith?.endTrade();
            InventoryGUI.isShopOpen = false;
            UI_Helper.removeHistoryElement('shop');
            UI_Helper.removeHistoryElement('inventory');
        };

        InventoryGUI.isShopOpen = true;
        UI_Helper.Open('shop', false, null, remove);
        InventoryGUI.Update('shop', owner, items_path);

        UI_Helper.Open('inventory', false, null, remove);
        InventoryGUI.Update();

        //repose windows
        var container_rect = document.getElementById('game_container').getBoundingClientRect();
        var width = parseInt(getComputedStyle(document.getElementById('shop')).width.replace('px', ''));
        var x = (container_rect.width - (width * 2)) / 3;
        var x2 = (x * 2) + width;

        set('#inventory', 'style.left', x + 'px');
        set('#shop', 'style.left', x2 + 'px');
    }



    static OpenLargeShop(owner, items_path)
    {
        var remove = function()
        {
            World.Player.interactionWith?.endTrade();
            InventoryGUI.isShopOpen = false;
            UI_Helper.removeHistoryElement('large_shop');
            UI_Helper.removeHistoryElement('inventory');
        };

        InventoryGUI.isShopOpen = true;
        UI_Helper.Open('large_shop', false, null, remove);
        InventoryGUI.Update('large_shop', owner, items_path);

        UI_Helper.Open('inventory', false, null, remove);
        InventoryGUI.Update();

        //repose windows
        var container_rect = document.getElementById('game_container').getBoundingClientRect();
        var width = parseInt(getComputedStyle(document.getElementById('large_shop')).width.replace('px', ''));
        var x = (container_rect.width - (width * 2)) / 3;
        var x2 = (x * 2) + width;

        set('#inventory', 'style.left', x + 'px');
        set('#large_shop', 'style.left', x2 + 'px');
    }




    


    static OpenAppearanceGUI()
    {
        var remove = function()
        {
            AppearanceGUI.Close();
            World.Player.interactionWith = null;
            Save();
            UI_Helper.removeHistoryElement('appearance');
        };

        UI_Helper.Open('appearance', false, null, remove);
        AppearanceGUI.Open();
    }



    static OpenSaveSelection()
    {
        document.getElementById('menu_buttons').style.display = 'none';

        var remove = function()
        {
            SaveSelectionGUI.Close();
            UI_Helper.removeHistoryElement('save_selection');
            document.getElementById('menu_buttons').style.display = ''
        };

        UI_Helper.Open('save_selection', false, null, remove);
        SaveSelectionGUI.Open();
    }



    static OpenKnowledgeGUI()
    {
        var remove = function()
        {
            KnowledgeGUI.Close();
            World.Player.interactionWith = null;
            UI_Helper.removeHistoryElement('knowledge');
        };

        UI_Helper.Open('knowledge', false, null, remove);
        KnowledgeGUI.Open();
    }


    static OpenDifficulties()
    {
        var i = 0;
        document.querySelectorAll('#difficulty .info').forEach(e => 
        {
            var difficultyInfo = GetDifficultyInfo(i);
            var description = Lang.Get(e.dataset.translate, difficultyInfo);

            e.innerText = description;
            i++
        });

        document.getElementById('difficulty').dataset.open = 'true';
    }


    static OpenCrafting()
    {
        var remove = function()
        {
            Crafting.Close();
            World.Player.interactionWith = null;
            UI_Helper.removeHistoryElement('crafting');
            UI_Helper.removeHistoryElement('inventory');
        };

        UI_Helper.Open('crafting', false, null, remove);

        UI_Helper.Open('inventory', false, null, remove);
        InventoryGUI.Update();

        //repose windows
        var container_rect = document.getElementById('game_container').getBoundingClientRect();
        var inv_width = parseInt(getComputedStyle(document.getElementById('inventory')).width.replace('px', ''));
        var craft_width = parseInt(getComputedStyle(document.getElementById('crafting')).width.replace('px', ''));

        var width = inv_width + craft_width + 100;
        var x = (container_rect.width - width) / 2;
        var x2 = x + inv_width+100;

        set('#inventory', 'style.left', x + 'px');
        set('#crafting', 'style.left', x2 + 'px');

        Crafting.Open();
    }



    static setTranscendentalText()
    {
        var els = document.querySelectorAll('[data-grade="'+GRADE.TRANSCENDENTAL+'"]');
        els.forEach(e => e.dataset.text = e.innerText);
    }


    static UpdateSlider(slider)
    {
        slider.dataset.value = slider.value;
        var progress = (slider.value * 1 - slider.min * 1) / (slider.max * 1 - slider.min * 1) * 100;
        slider.style.setProperty('--progress', progress + '%');
    }

    static UpdateSliders()
    {
        var els = document.querySelectorAll('input[type="range"]');
        els.forEach(e => UI_Helper.UpdateSlider(e));
    }

    static InitSliders()
    {
        var els = document.querySelectorAll('input[type="range"]');
        els.forEach(e => 
        {
            UI_Helper.UpdateSlider(e);
            e.addEventListener('input', function()
            {
                UI_Helper.UpdateSlider(this);
            });
        });
    }


    static showConfirm(confirm = '', Yes = '', No = '', onYes = null, onNo = null)
	{
		var id = 'confirm_' + Date.now();

		var container = document.createElement('div');
			container.className = 'confirm_container';
			container.id = id;
		
		var box = document.createElement('div');
			box.className = 'box';
		
		var warning = document.createElement('div');
			warning.className = 'warning';
			warning.innerText = 'Uwaga!';

		var message = document.createElement('p');
			// message.innerText = text;

		var question = document.createElement('p');
			question.innerText = Lang.Get(confirm);

		var nav_bottom = document.createElement('div');

		var button_yes = document.createElement('div');
            button_yes.className = 'button';
			button_yes.innerText = Lang.Get(Yes);
			button_yes.addEventListener('click', ()=>{UI_Helper.hideConfirm(id); onYes?.();});

		var button_no = document.createElement('div');
            button_no.className = 'button';
			button_no.innerText = Lang.Get(No);
			button_no.addEventListener('click', ()=>{UI_Helper.hideConfirm(id); onNo?.()});


		document.body.appendChild(container);
		container.appendChild(box);
		box.appendChild(warning);
		// box.appendChild(message);
		box.appendChild(question);
		box.appendChild(nav_bottom);
		nav_bottom.appendChild(button_yes);
		nav_bottom.appendChild(button_no);

        UI_Helper.addHistoryElement(container, 'remove', '', id);
	}

    static hideConfirm(id)
	{
        UI_Helper.removeHistoryElement(id);
	}


    static InitMenu()
    {
		// if(DEVELOPER_MODE)
		// {
		// 	document.getElementById('menu_testing_chamber').addEventListener('click', function()
		// 	{
		// 		Menu.Transition(function()
		// 		{
        //             Main.inTestMode = true;
                    
		// 			InGame.Run();
		// 			World.Initialize();
		// 			World.LoadMap("TestingChamber", true);
		// 		});
		// 	});
		// }

		document.getElementById('menu_game_ver').innerText = "v." + VERSION;


        document.getElementById('menu_settings').addEventListener('click', function()
		{
            document.getElementById('menu_buttons').style.display = 'none';
            var onRemove = function()
            {
                document.getElementById('menu_buttons').style.display = '';
                Settings.Save();
            };
            
            var settings_window = document.getElementById('settings_window');
            if(!settings_window.style.top) settings_window.style.top = '60%';
			UI_Helper.Open('settings', false, null, onRemove);
		});


        document.getElementById('menu_start').addEventListener('click', function()
		{
			UI_Helper.OpenSaveSelection();
		});

        document.getElementById('menu_credits').addEventListener('click', function()
		{
            var open = document.getElementById('shader_flare').dataset.open;
            var _remove = () => {document.getElementById('shader_flare').dataset.open = open};
            document.getElementById('shader_flare').dataset.open = 'false';
            
			UI_Helper.Open('credits', false, null, _remove);
		});

        document.getElementById('menu_quit').addEventListener('click', function()
		{
            Main.Exit();
		});
    }



    static InitInGame()
    {
        var s = AppearanceGUI.GetSkinScrollStep();
        DraggableScroll.Init(document.querySelector('#skins'), {step: s});
        DraggableScroll.Init(document.querySelector('#knowledge_location_list'), {accY: .1});
        DraggableScroll.Init(document.querySelector('#quest_list'), {accY: .1});


        



        document.querySelector('#appearance').querySelectorAll('.slider_arrow').forEach(e => 
        {
            e.addEventListener('click', AppearanceGUI.SkinListArrowsClick);
        });


        InventoryGUI.Init();
        InventoryGUI.Init('shop');
        if(DEVELOPER_MODE) InventoryGUI.Init('large_shop', ItemHelper.totalItems, 'SHOP');
        InventoryGUI.InitEquips();

        Crafting.Init();

        var height = document.querySelector('#inventory').style.getPropertyValue('--window-height');
        document.getElementById('player_stats').style.setProperty('--window-height', height);

        UI_Helper.CreatePlayerHealthBar();
        UI_Helper.InitDeathScreen();
        UI_Helper.InitPlayerStats();


        document.getElementById('bottom_nav_icons').addEventListener('click', function()
        {
            // this.dataset.hide = (this.dataset.hide == 'false') ? 'true' : 'false';
            UI_Helper.Toggle(this.id);
        });

        document.getElementById('ingame_button_world_map').addEventListener('click', function()
        {
            UI_Helper.ToggleWorldMap();
        });
        document.getElementById('ingame_button_pause').addEventListener('click', function()
        {
            InGame.Pause();
            UI_Helper.Hide('#bottom_nav_icons');
        });



        document.getElementById('difficulty_icon').addEventListener('mousemove', function()
        {
            var difficultyInfo = GetDifficultyInfo();

            var text = Lang.Get('DIFFICULTY') + ': '+ Lang.Get('DIFFICULTY.'+difficultyInfo.Name.toUpperCase()+'.NAME');
            var description = Lang.Get('DIFFICULTY.'+difficultyInfo.Name.toUpperCase()+'.DESCRIPTION', difficultyInfo);

            UI_Helper.ShowTooltip(text, description);
        });

        document.getElementById('difficulty_icon').addEventListener('mouseout', function()
        {
            ItemInfo.Hide();
        });

        DraggableScroll.Init(document.querySelector('#world_map .content'));


        document.getElementById('difficulty_select_easy').addEventListener('click', function()
        {
            World.Player.Difficulty = 0;
            document.getElementById('difficulty').dataset.open = 'false';
            UI_Helper.setDifficultyInfo()
        });

        document.getElementById('difficulty_select_normal').addEventListener('click', function()
        {
            World.Player.Difficulty = 1;
            document.getElementById('difficulty').dataset.open = 'false';
            UI_Helper.setDifficultyInfo()
        });

        document.getElementById('difficulty_select_hard').addEventListener('click', function()
        {
            World.Player.Difficulty = 2;
            document.getElementById('difficulty').dataset.open = 'false';
            UI_Helper.setDifficultyInfo()
        });

    }

    static ShowTooltip(text, description = null)
    {
        var item = new Item();
        item.price = null;
        item.name = text;
        item.Description = description;

        ItemInfo.Hide();
        ItemInfo.Show(item); 
    }

    static InitPlayerStats()
    {
        var container = document.getElementById('player_stat_sp_stats');
        var sp_buttons = container.querySelectorAll('.sp_button');
        var sp_stat_names = container.querySelectorAll('.sp_stat_name');

        sp_buttons.forEach(e => 
        {
            e.addEventListener('click', function()
            {
                World.Player.UseSPpoint(STAT[this.dataset.stat]);
            })
        });


        sp_stat_names.forEach(e => 
        {
            e.addEventListener('mousemove', function()
            {
                var params = {};
                var sp_data = World.Player.SPstats[STAT[this.dataset.translate]];

                params.value = sp_data[0] * sp_data[2];
                var text = Lang.Get('SP.'+this.dataset.translate+'.TITLE', params);

                UI_Helper.ShowTooltip(text);
            });

            e.addEventListener('mouseout', function()
            {
                ItemInfo.Hide();
            });
        });

        var defense_name = document.getElementById('player_stat_defense_name');
        defense_name.addEventListener('mousemove', function()
        {
            var params = {};

            params.def = World.Player.stats[STAT.DEFENSE];
            params.reduction = World.Player.getDamageReduction();

            var text = Lang.Get('STAT.DEFENSE.TITLE', params);

            UI_Helper.ShowTooltip(text);
        });
        defense_name.addEventListener('mouseout', function()
        {
            ItemInfo.Hide();
        });
    }

    static InitDeathScreen()
    {
        document.querySelector('#death_screen_respawn').addEventListener('click', function()
        {
            World.Player.Respawn();
            UI_Helper.removeHistoryElement('death_screen');
        });
    }


    static TriggerHeartAnimation(index = 0)
    {
        var heart = document.querySelector('.heart[data-index="'+index+'"]');
            heart.dataset.beat = 'true';
    }

    static HeartAnimationEnd(el)
    {
        el.dataset.beat = 'false';

        var index = el.dataset.index * 1;
        var next_index = index + 1;
        var next_el = document.querySelector('.heart[data-index="'+next_index+'"]');
        if(next_el) 
        {
            if(next_el.style.getPropertyValue('--health-ratio') != '0')
            {
                UI_Helper.TriggerHeartAnimation(next_index);
                return;
            }
        }

        InGame.setHeartAnimationDelay();
    }

    static CreatePlayerHealthBar(maxHP = 400, avoidUpdate = false)
    {
        var heartValue = Player.GetHeartValue() * 2;
        var hearts = Math.ceil(maxHP / heartValue);

        var el = document.getElementById('player_health_container');
            el.innerHTML = '';
        var el_style = getComputedStyle(el);

        var heartsInRow = el_style.getPropertyValue('--hearts-in-row') * 1;
        var rows = Math.ceil(hearts / heartsInRow);
        var drawedHearts = 0;

        for(var i = 0; i < rows; i++)
        {
            var row = document.createElement('div');
                row.className = 'row';
                row.style.zIndex = i + 1;

            for(var j = 0; j < heartsInRow; j++)
            {
                if(drawedHearts > hearts) break;

                var heart_container = document.createElement('div');
                    heart_container.className = 'heart icon';
                    heart_container.dataset.icon = 'heart-empty';
                    // heart_container.style.setProperty('--index', drawedHearts);
                    heart_container.dataset.index = drawedHearts;
                    heart_container.dataset.beat = 'false';
                    heart_container.addEventListener('animationend', function(){UI_Helper.HeartAnimationEnd(this)});

                row.appendChild(heart_container);

                drawedHearts++;
            }

            el.appendChild(row);
        }

        if(!avoidUpdate) UI_Helper.UpdatePlayerHealthBar(70, 100);
    }


    static UpdatePlayerHealthBar(currentHealth, maxHealth)
    {
        var heartValue = Player.GetHeartValue() * 2;
        var visible_hearts = Math.ceil(maxHealth / heartValue);

        var i = 0;
        var heart_elements = document.querySelectorAll('.heart');
        if(visible_hearts > heart_elements.length) 
        {
            //force hearts recreate if max health is higher than default
            UI_Helper.CreatePlayerHealthBar(maxHealth, true);
            UI_Helper.UpdatePlayerHealthBar(currentHealth, maxHealth);
            return;
        }

        heart_elements.forEach(e => 
        {
            var currentHealthRatio = currentHealth / heartValue;
                if(currentHealthRatio > 1) currentHealthRatio = 1;
                if(currentHealthRatio < 0) currentHealthRatio = 0;

            e.style.setProperty('--health-ratio', currentHealthRatio);
            e.style.opacity = (i >= visible_hearts) ? 0 : 1;
            e.style.setProperty('--animation-speedup', '');
            e.dataset.critical = 'false';

            if(currentHealth <= heartValue && i == 0 && currentHealth > 0)
            {
                //only first heart can apply critical animations
                e.dataset.critical = 'true';
                if(currentHealth <= heartValue / 2) e.style.setProperty('--animation-speedup', '.75');

                InGame.setHeartAnimationDelay();        //avoid stoping animation cycles
            }

            i++;
            currentHealth -= heartValue;
        });

    }

    static setDifficultyInfo()
    {
        var icon = 'difficulty_easy';
		if(Difficulty() == 1) icon = 'difficulty_normal';
		if(Difficulty() == 2) icon = 'difficulty_hard';
		
		set('#difficulty_icon', 'dataset.icon', icon, true);
    }

    static updateCooltimeIcons()
    {
        var cooltimes = World.Player.Cooltimes;
        var container = document.getElementById('player_cooltime_container');
        container.querySelectorAll('.item').forEach(e => {e.dataset.hidden = 'true'});

        for(var id in cooltimes)
        {
            var el = container.querySelector('.item.'+id);
            if(!el) el = UI_Helper.createCooltimeIcon(container, id, cooltimes[id].icon);

            el.style.setProperty('--progress', cooltimes[id].progress);
            if(!cooltimes[id].isEffect) el.dataset.hidden = cooltimes[id].progress >= 100 ? 'true' : 'false';
            else el.dataset.hidden = cooltimes[id].progress <= 0 ? 'true' : 'false';
        }

        container.querySelectorAll('.item[data-hidden="true"]').forEach(e => {e.remove()});
    }

    static createCooltimeIcon(container, id, icon)
    {
        var el = document.createElement('div');
            el.className = 'item icon '+id;
            el.dataset.icon = icon.toLowerCase();
            el.dataset.id = id;
            el.addEventListener('mousemove', function()
            {
                var params = {};
                var effect = World.Player.Effects.GetActiveEffectById(this.dataset.id);
                if(!effect) return;

                var id = this.dataset.id.replace('EFFECT_', '');
                params.STRENGTH = effect.Strength;

                var text = Lang.Get('EFFECT.'+id+'.NAME');
                var desc = Lang.Get('EFFECT.'+id+'.DESCRIPTION', params);

                UI_Helper.ShowTooltip(text, desc);
            });
            el.addEventListener('mouseout', function()
            {
                ItemInfo.Hide();
            });

        
        container.appendChild(el);

        return el;
    }




    static InitPause()
    {
        document.getElementById('pause_continue').addEventListener('click', function()
        {
            InGame.Resume();
        });

        document.getElementById('pause_settings').addEventListener('click', function()
		{
            document.getElementById('pause_buttons').style.display = 'none';
            var onRemove = function()
            {
                document.getElementById('pause_buttons').style.display = '';
                Settings.Save();
            };

            var settings_window = document.getElementById('settings_window');
                settings_window.style.top = '';

			UI_Helper.Open('settings', false, null, onRemove);
		});


        document.getElementById('pause_quit').addEventListener('click', function()
		{
            UI_Helper.removeHistoryElement('pause');
            InGame.Quit();
            Main.inTestMode = false;
		});
    }




    static InitSettings()
    {
        var els = document.querySelectorAll('[data-opensection]');
        els.forEach(e => 
        {
            e.addEventListener('click', function()
            {
                var id = this.dataset.opensection;
                var sectionClass = this.dataset.sectionclass;

                UI_Helper.addHistory = false;
                UI_Helper.Open(id, true, sectionClass);

                var els = document.querySelectorAll('[data-opensection]');
                els.forEach(e => e.dataset.locked = false);
                this.dataset.locked = true;
            });
            var target = document.getElementById(e.dataset.opensection);
            if(target) 
                if(!target.dataset.open) target.dataset.open = 'false';
        });

        document.getElementById('settings_apply').addEventListener('click', function()
        {
            UI_Helper.removeHistoryElement('settings');
        });


        document.getElementById('settings_reset').addEventListener('click', function()
        {
            var locked_setting_button = document.querySelector('[data-opensection][data-locked="true"][data-sectionclass="settings_scene"]');
            var setting_type = locked_setting_button.dataset.setting;
            Settings.RestoreDefault(setting_type);
            UI_Helper.ReloadSettingsUI();
        });




        var inputs = document.querySelectorAll('[data-setting]');
        inputs.forEach(e => 
        {
            e.addEventListener('input', function()
            {
                var path = this.dataset.setting;
                var value = this.value;
                if(this.type == 'checkbox') value = this.checked;
                if(this.type == 'range' || this.type == 'number') value = parseFloat(value);
                if(this.type == 'text' && value == 'SPACE') value = ' ';

                set(Settings, path, value);
            });
        });






        var els = document.querySelectorAll('[data-type="key"]');
        els.forEach(e => 
        {
            e.addEventListener('keydown', function(e)
            {
                this.value = e.key.toUpperCase();
                if(this.value == ' ') this.value = 'SPACE';
                e.preventDefault();     //prevent from adding key to value

                var event = new Event('input');
                this.dispatchEvent(event);
            });
        });






        UI_Helper.ReloadSettingsUI();
    }

    static ReloadSettingsUI()
    {
        var change = function()
        {
            var resolutions = Settings.Video.getResolutions();
            if(resolutions[this.value]) Settings.Video.Resolution = resolutions[this.value];
        };

        var resolutions = Settings.Video.getResolutions();
        var res_options = [];
        var current = null;
        for(var i in resolutions)
        {
            var res = resolutions[i];
            var opt = {value: i, name: res[0] + ' x ' + res[1], disabled: false, icon: null};
            res_options.push(opt);


            if(res[0] == Settings.Video.Resolution[0] && res[1] == Settings.Video.Resolution[1]) current = i;
        }

        var select = CustomSelect.Create('settings_video_resolution', res_options, current, change);

        var select_container = document.getElementById('settings_video_resolution_container');
            select_container.innerHTML = '';
            select_container.appendChild(select);
        


        var inputs = document.querySelectorAll('[data-setting]');
        inputs.forEach(e => 
        {
            if(e.type == 'checkbox') e.checked = get(Settings, e.dataset.setting);
            else e.value = get(Settings, e.dataset.setting);

            if(e.type == 'text' && e.value == ' ') e.value = 'SPACE';
        });
        UI_Helper.UpdateSliders();
    }
}class WorldMap
{
    static Init()
    {
        this.MAP_TILES_X = 40;
        this.MAP_TILES_Y = 20;
        this.HEX_ANGLE = 2 * Math.PI / 6;

        this.DIMENSION = null;
        this.MAP = this.createEmptyMap();
        this.POINTS = [];
        this.LIGHT_MAP = [];
    }

    static getTileSize()
    {
        var map_content= document.getElementById('world_map').querySelector('.content');
        var s = window.getComputedStyle(map_content);
        var height = s.height.replace('px', '');

        return height / this.MAP_TILES_Y;
    }

    static getTileR()
    {
        return Math.ceil(this.getTileSize() / (2 * Math.sin(this.HEX_ANGLE)));
    }

    static createEmptyMap()
    {
        var m = [];
        for(var i = 0; i < this.MAP_TILES_Y; i++)
        {
            m[i] = [];
            for(var j = 0; j < this.MAP_TILES_X; j++)
            {
                m[i][j] = false;
            }
        }

        return m;
    }

    static drawPoint(x, y, data, isActiveMapTile = false)
    {
        var container = document.getElementById('world_map_points');
        var rank = data.rank ?? '';
        var abs_rank = rank.replace('+', '').replace('-', '').toLowerCase();

        var p = document.createElement('div');
            p.className = 'point text-stroke';
            p.style.top = y + 'px';
            p.style.left = x + 'px';
            p.innerText = rank;
            p.dataset.location_id = data.id;
            p.dataset.name = data.name;
            p.dataset.inactivehex = isActiveMapTile;
            if(data.specialIcon)
            {
                p.dataset.icon = data.specialIcon;
                p.className += ' icon';
            }

            p.style.setProperty('color', 'var(--color-rank-' + abs_rank + ')');
            if(data.isCurrent) p.dataset.current = 'true';

            p.dataset.village = data.isVillage;
            p.dataset.cleared = data.isCleared;
            p.dataset.locationfamily = data.id.toLowerCase().replace(/[0-9]/, '').replace(' ', '');
            if(!data.canInteract) p.style.pointerEvents = 'none';
            else
            {
                p.addEventListener('click', function()
                {
                    var result = Commands.GoToLocation(this.dataset.location_id);
                    if(result == true)
                    {
                        UI_Helper.Hide('#world_map');
                    }
                    else
                    {
                        console.error(result);
                    }
                });
            }

        container.appendChild(p);

        this.LOCATION_POINTS_HISTORY[data.id] = {x, y, cleared: data.isCleared};
    }


    static drawHexagon(ctx, x, y, r = this.getTileR(), hexagon_info)
    {
        var a = this.HEX_ANGLE;

        var color = null;
        var stroke = '#00157A';
        var strokeSize = 2;
        var alpha = 1;

        if(hexagon_info)
        {
            if(hexagon_info.isMapTile) 
            {
                color = '#00157A';
                alpha = .95;

                if(hexagon_info.isActiveMapTile)
                {
                    color = '#083BB6';
                    alpha = .95;
                    stroke = '#083BB6';
                    //0055FF - stroke
                }
            }
        }

        // if(drawingActiveHex)
        // {
        //     color = '#f0cb16';
        //     alpha = .5;
        // }

        ctx.save();
        ctx.fillStyle = color;
        ctx.lineWidth = strokeSize;
        ctx.strokeStyle  = stroke;
        ctx.globalAlpha = alpha;

        ctx.beginPath();
        for (var i = 0; i < 6; i++) 
        {
            ctx.lineTo(x + r * Math.cos(a * i), y + r * Math.sin(a * i));
        }
        ctx.closePath();
        if(color) ctx.fill();
        if(stroke) ctx.stroke();

        ctx.restore();
    }

    static drawHexeGrid(ctx, map, hexR, isBackgroundLayer = false) 
    {
        var tileSize = this.getTileSize();
        var a = this.HEX_ANGLE;
        var startX = -hexR;
        var x;
        var y = -hexR;

        var tmp_canvas = document.createElement('canvas');
            tmp_canvas.width = tileSize * this.MAP_TILES_X * Math.sin(this.HEX_ANGLE);
            tmp_canvas.height = tileSize * this.MAP_TILES_Y;
        var tmp_ctx = tmp_canvas.getContext('2d');

        var width = this.MAP_TILES_X;
        var height = this.MAP_TILES_Y;
        var tilesMargin = 1;

        for(var i = -tilesMargin; i < height + tilesMargin; i++)
        {
            y += hexR * 2 * Math.sin(a);
            x = startX;

            for(var j = -tilesMargin; j < width + tilesMargin; j++)
            {
                x += hexR * (1 + Math.cos(a));
                y += (-1) ** (j) * hexR * Math.sin(a);

                if(isBackgroundLayer)
                {
                    this.drawHexagon(ctx, x, y, hexR, hexagon_info);
                    continue;
                }

                var hexagon_info = null;
                if(map?.[i]?.[j] != null)
                {
                    hexagon_info = Dimension.getHexData(j, i, map, this.POINTS, this.LIGHT_MAP);
                }
                

                if(hexagon_info?.locationPoint) 
                {
                    this.drawPoint(x, y, hexagon_info.locationPoint.locationData, hexagon_info.isActiveMapTile);
                }

                if(!hexagon_info?.isMapTile) continue;

                if(hexagon_info?.isActiveMapTile) this.drawHexagon(tmp_ctx, x, y, hexR, hexagon_info);
                else this.drawHexagon(ctx, x, y, hexR, hexagon_info);
            }
        }

        ctx.save();
        ctx.shadowColor = "#0055FF";
        ctx.shadowBlur = 0;
        for(var x = -2; x <= 2; x++){
            // Y offset loop
            for(var y = -2; y <= 2; y++){
                // Set shadow offset
                ctx.shadowOffsetX = x;
                ctx.shadowOffsetY = y;

                // Draw image with shadow
                ctx.drawImage(tmp_canvas, 0, 0, tmp_canvas.width, tmp_canvas.height);
            }
        }
        ctx.restore();
    }


    static drawPaths(ctx)
    {
        var locations = this.DIMENSION.getLocations();

        for(var locationName in locations)
		{
			var loc = locations[locationName];
            var loc_pos = this.LOCATION_POINTS_HISTORY[locationName];
            if(!loc_pos) continue;

			var x = loc_pos.x;
			var y = loc_pos.y;

            var prev_locs = World.LocationList[loc.id].reqPrevLocation;
			if(prev_locs)
			{
                for(var i = 0; i < prev_locs.length; i++)
                {
                    var prev_id = prev_locs[i];
                    var prev_pos = this.LOCATION_POINTS_HISTORY[prev_id];

                    if(!prev_pos) continue;     //should not ever happen
                    if(!prev_pos.cleared) continue;     //will not draw line if prev location was not cleared

                    var x2 = prev_pos.x;
                    var y2 = prev_pos.y;

                    ctx.save();
                    ctx.strokeStyle = "white";
                    ctx.lineWidth = 5;
                    ctx.beginPath();
                    ctx.setLineDash([5, 10]);
                    ctx.moveTo(x, y);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();
                    ctx.closePath();
                    ctx.restore();
                }
			}
        }
    }


    static Render()
    {
        this.LOCATION_POINTS_HISTORY = [];
        this.loadDimensionMap();

        var tileSize = this.getTileSize();
        this.LIGHT_MAP = Dimension.getLightMap(this.MAP, this.POINTS);

        var canvas_width = tileSize * this.MAP_TILES_X * Math.sin(this.HEX_ANGLE);
        var canvas_height = tileSize * this.MAP_TILES_Y;

        var bg_canvas = document.getElementById('map_background');
            bg_canvas.width = canvas_width;
            bg_canvas.height = canvas_height;

        var canvas = document.getElementById('map');
            canvas.width = canvas_width;
            canvas.height = canvas_height;

        var paths_canvas = document.getElementById('point_paths');
            paths_canvas.width = canvas_width;
            paths_canvas.height = canvas_height;

        var bg_ctx = bg_canvas.getContext('2d');
        var ctx = canvas.getContext('2d');
        var paths_ctx = paths_canvas.getContext('2d');

        bg_ctx.clearRect(0, 0, bg_canvas.width, bg_canvas.height);
        ctx.clearRect(0, 0, bg_canvas.width, bg_canvas.height);
        paths_ctx.clearRect(0, 0, bg_canvas.width, bg_canvas.height);

        document.getElementById('world_map_points').innerHTML = '';

        this.drawHexeGrid(bg_ctx, this.createEmptyMap(), this.getTileR(), true);
        this.drawHexeGrid(ctx, this.MAP, this.getTileR());
        this.drawPaths(paths_ctx);

        // drawingActiveHex = true;
        // this.drawHexeGrid(ctx, ACTIVE_HEX, getTileR());
        // drawingActiveHex = false;
    }



    static loadDimensionMap(dimName = 'OVERWORLD')
    {
        var dimension = World.DimensionsList[dimName];
        if(!dimension) return;

        this.DIMENSION = dimension;
        this.MAP = JSON.parse(JSON.stringify(dimension.HexMap));
        this.POINTS = dimension.getLocationPoints();
    }
}var rootPath = "./assets/sounds/";
SoundManager.src =
[
	["interface.MenuBackground", rootPath + "/music/MenuBackground.wav"],
	["effect.BubblePop", rootPath + "/effects/BubblePop.mp3"],
	["effect.ButtonClick", rootPath + "/effects/ButtonClick.ogg"],
	["interface.InGameCalm", rootPath + "/music/InGameCalm.mp3"],
	["interface.BossFight2", rootPath + "/music/Club Diver.mp3"],
	["interface.SecretRoom", rootPath + "/music/lightless_dawn.mp3"],
	["interface.Village", rootPath + "/music/Wallpaper.mp3"],
	['world.boss_arena', rootPath+'/music/Oppressive Gloom.mp3']
];var rootPath = "./assets/textures";
TextureManager.src =
[
	["none", rootPath + "/none.png"],
	["empty", rootPath + "/empty.png"],

	['location.beehive.room', rootPath+'/beehive_location_room.png'],
	

	["cursor.InGame",rootPath + "/gui/cursor_ingame.png"],
	["heart",rootPath + "/gui/heart_full.png"],
	["heart_empty",rootPath + "/gui/heart_empty1.png"],
	["heart_half",rootPath + "/gui/heart_half1.png"],
	["drive_empty", rootPath + "/gui/drive_empty.png"],
	["core_empty",rootPath + "/gui/core_empty.png"],
	["cannon_empty", rootPath + "/gui/cannon_empty.png"],


	["bullet.bubble.enemy", rootPath + "/bullet_enemy.png"],
	["bullet.bubble.base", rootPath + "/bullet_base.png"],
	["spike_ball", rootPath + "/spike_ball.png"],
	["projectile_spike", rootPath + "/projectile_spike.png"],
	
	["bubble_turret_head", rootPath + "/bubble_turret_head.png"],
	["bubble_turret_base", rootPath + "/bubble_turret_base.png"],
	["projectile.soundwave", rootPath + "/bullet_sound_wave.png"],
	["projectile.echo", rootPath + "/bullet_echo.png"],
	
	["frost_turret_head", rootPath + "/frost_turret_head.png"],



	["projectile.laser.base.start", rootPath + "/laser_base_start.png"],
	["projectile.laser.base.mid", rootPath + "/laser_base_mid.png"],
	["projectile.laser.base.end", rootPath + "/laser_base_end.png"],

	["projectile.laser.virtuoso.start", rootPath + "/laser_virtuoso_start.png"],
	["projectile.laser.virtuoso.mid", rootPath + "/laser_virtuoso_mid.png"],
	["projectile.laser.virtuoso.end", rootPath + "/laser_virtuoso_end.png"],

	["projectile.laser.destroyer.start", rootPath + "/laser_destroyer_start.png"],
	["projectile.laser.destroyer.mid", rootPath + "/laser_destroyer_mid.png"],
	["projectile.laser.destroyer.end", rootPath + "/laser_destroyer_end.png"],

	["projectile.bamboo_stick", rootPath + "/bullet_bamboo_stick.png"],
	["projectile.water_twister", rootPath + "/bullet_water_twister.png"],
	["projectile.water_twister.2", rootPath + "/bullet_water_twister_2.png"],


	["projectile.frog.tongue", rootPath + "/frog_tongue.png"],
	["projectile.frog.tongue.end", rootPath + "/frog_tongue_end.png"],

	["projectile.bubble.rocket", rootPath + "/bubble_rocket.png"],
	["projectile.bubble.bullet", rootPath + "/bubble_bullet.png"],

	["projectile.frost_ball", rootPath + "/bullet_frost_orb.png"],
	["projectile.icicle", rootPath + "/bullet_icicle.png"],
	["projectile.flame_star", rootPath + "/flame_star.png"],

	["projectile.sting", rootPath + "/bullet_sting.png"],
	["projectile.saw", rootPath + "/bullet_saw.png"],


	["explosion.smoke", rootPath + "/explosion_smoke.png"],

	["laser_turret_head", rootPath + "/laser_turret_head.png"],
	["bullet_snowflake", rootPath + "/bullet_snowflake.png"],
	["shield", rootPath + "/shield.png"],
	["bubble_large", rootPath + "/bubble_large.png"],
	["golden_bubble", rootPath + "/golden_bubble.png"],
	["bubble_pop", rootPath + "/particles/bubble_pop.png"],
	["bulletParticle", rootPath + "/particles/bullet_particle.png"],
	["particleShine", rootPath + "/particles/particle_shine.png"],
	["spark_circle", rootPath + "/particles/spark_circle.png"],
	["ExplosionBase", rootPath + "/particles/explosion.png"],
	

	["effect.honey_bubble", rootPath + "/honey_bubble.png"],

	["effect.sonic_boom.indicator", rootPath + "/particles/sonic_boom_indicator.png"],
	

	["effect.quest.indicator", rootPath + "/particles/quest_indicator.png"],
	["effect.quest.particle", rootPath + "/particles/quest_particle.png"],

	["effect.invincible.base", rootPath + "/particles/vfx_hex_shield.png"],
	["effect.invincible.sprite", rootPath + "/particles/vfx_hex_shield_sprite.png"],
	["effect.invincible.0", rootPath + "/particles/vfx_hex_shield_0.png"],
	["effect.invincible.idle", rootPath + "/particles/vfx_hex_shield_idle.png"],

	["effect.stun", rootPath + "/particles/spiralka_antykoncepcyjna.png"],
	["effect.poison", rootPath + "/particles/poison.png"],
	["effect.slow", rootPath + "/particles/slow.png"],

	["effect.fire", rootPath + "/particles/fire_sprite.png"],
	["effect.fire.blue", rootPath + "/particles/blue_fire_sprite.png"],
	["effect.lightning.strike.indicator", rootPath + "/particles/vfx_lightning_strike_indicator.png"],
	["effect.lightning.strike", rootPath + "/particles/vfx_lightning_strike.png"],

	["effect.flash.1", rootPath + "/particles/vfx_flash_1.png"],
	["effect.flash.2", rootPath + "/particles/vfx_flash_2.png"],
	["effect.flash.3", rootPath + "/particles/vfx_flash_3.png"],
	["effect.flash.4", rootPath + "/particles/vfx_flash_4.png"],
	["effect.flash.5", rootPath + "/particles/vfx_flash_5.png"],



	["inventory_slot", rootPath + "/gui/inventory_slot.png"],
	["special_empty", rootPath + "/empty.png"],
	["inventory_slot_hover",rootPath + "/gui/inventory_slot_hover.png"],
	["inventory_slot_locked",rootPath + "/gui/inventory_slot_locked.png"],
	["inventory_slot_negative",rootPath + "/gui/inventory_slot_negative.png"],
	["inventory_slot_changed",rootPath + "/gui/inventory_slot_changed.png"],
	
	["item.liquid_oxygen",rootPath + "/items/liquid_oxygen.png"],
	["item.oxygen",rootPath + "/items/oxygen.png"],

	["item.bamboo_stick",rootPath + "/items/bamboo_stick.png"],
	["item.essence_extractor",rootPath + "/items/essence_extractor.png"],
	
	["item.essence.common",rootPath + "/items/essence_common.png"],
	["item.essence.rare",rootPath + "/items/essence_rare.png"],
	["item.essence.mythical",rootPath + "/items/essence_mythical.png"],
	["item.essence.legendary",rootPath + "/items/essence_legendary.png"],

	["item.aura.boss",rootPath + "/items/concentrated_boss_aura.png"],
	["item.aura.common",rootPath + "/items/concentrated_aura_common.png"],
	["item.aura.rare",rootPath + "/items/concentrated_aura_rare.png"],
	["item.aura.mythical",rootPath + "/items/concentrated_aura_mythical.png"],
	["item.aura.legendary",rootPath + "/items/concentrated_aura_legendary.png"],
	
	["item.blessing_stone",rootPath + "/items/blessing_stone.png"],
	["item.blessing_stone.common",rootPath + "/items/blessing_stone_common.png"],
	["item.blessing_stone.rare",rootPath + "/items/blessing_stone_rare.png"],
	["item.blessing_stone.mythical",rootPath + "/items/blessing_stone_mythical.png"],
	["item.blessing_stone.legendary",rootPath + "/items/blessing_stone_legendary.png"],
	
	["item.blessing_stone.angelic",rootPath + "/items/blessing_stone_angelic.png"],
	["item.blessing_stone.demonic",rootPath + "/items/blessing_stone_demonic.png"],
	["item.blessing_stone.divine",rootPath + "/items/blessing_stone_divine.png"],

	["item.riffle.the_virtuoso",rootPath + "/items/the_virtuoso.png"],

	["item.holy_stone.bullet",rootPath + "/items/holy_stone_bullet.png"],
	["item.holy_stone.attack_range",rootPath + "/items/holy_stone_attack_range.png"],
	["item.holy_stone.attack_speed",rootPath + "/items/holy_stone_attack_speed.png"],


	["item.water_twister",rootPath + "/items/water_twister.png"],

	["item.enchant.crystal.blue",rootPath + "/items/crystal_blue.png"],
	["item.enchant.crystal.white",rootPath + "/items/crystal_white.png"],
	["item.enchant.crystal.black",rootPath + "/items/crystal_black.png"],
	["item.enchant.crystal.purple",rootPath + "/items/crystal_purple.png"],

	["item.infinity_stone.space",rootPath + "/items/infinity_stone_space.png"],

	["item.sapphire",rootPath + "/items/sapphire.png"],
	["item.topaz",rootPath + "/items/topaz.png"],
	["item.emerald",rootPath + "/items/emerald.png"],


	
	["bubble",rootPath + "/bubble.png"],
	["bubbleTank",rootPath + "/bubble_tank1.png"],
	["bubble_no_shine",rootPath + "/bubble_no_shine.png"],
	["cannonBase",rootPath + "/cannon_base.png"],
	["machineGun1",rootPath + "/machine_gun1.png"],
	["driveBase",rootPath + "/drive_base.png"],
	["valentineBubble",rootPath + "/valentines_day_menu.png"],



	["powerUpScroll1",rootPath + "/items/power_up_scroll_1.png"],
	["powerUpStone0",rootPath + "/items/power_up_stone_0.png"],
	["powerUpStone1",rootPath + "/items/power_up_stone_1.png"],
	["powerUpStone2",rootPath + "/items/power_up_stone_2.png"],
	["powerUpStone3",rootPath + "/items/power_up_stone_3.png"],
	["treasureBag",rootPath + "/items/treasure_bag.png"],



	["item.treasure_orb.lake",rootPath + "/items/treasure_orb_lake.png"],
	["item.treasure_orb.cave",rootPath + "/items/treasure_orb_cave.png"],

	["enchantGemLock",rootPath + "/items/enchant_gem_lock.png"],
	["item.enchant.gem.blue",rootPath + "/items/enchant_gem_blue.png"],
	["item.enchant.gem.green",rootPath + "/items/enchant_gem_green.png"],
	["item.enchant.gem.violet",rootPath + "/items/enchant_gem_violet.png"],
	["item.enchant.gem.white",rootPath + "/items/enchant_gem_white.png"],
	["item.enchant.gem.yellow",rootPath + "/items/enchant_gem_yellow.png"],
	["item.enchant.gem.red",rootPath + "/items/enchant_gem_red.png"],

	["item.quest.golden_scissors",rootPath + "/items/golden_scissors.png"],

	["item.drive1",rootPath + "/items/drive1.png"],
	["item.cannonBase",rootPath + "/items/cannon_base.png"],
	["item.rifle.1",rootPath + "/items/bubble_rifle_1.png"],
	["item.bubbleCannon1",rootPath + "/items/bubble_cannon1.png"],
	["item.machine_gun.1",rootPath + "/items/bubble_machine_gun1.png"],
	
	["item.core.base",rootPath + "/items/core_base.png"],

	["item.appearance_box.unknown",rootPath + "/items/appearance_box_unknown.png"],
	["item.appearance_box.kitsune",rootPath + "/items/appearance_box_kitsune.png"],

	["item.summon_scroll",rootPath + "/items/summon_scroll.png"],

	["item.ring.golden",rootPath + "/items/golden_ring.png"],

	["item.necklace.golden",rootPath + "/items/golden_necklace.png"],

	["item.bottle.flow",rootPath + "/items/flow_in_bottle.png"],

	["item.pet.frogo",rootPath + "/items/pet_frogo.png"],

	["item.honey.piece",rootPath + "/items/honey_piece.png"],
	["item.honey.comb",rootPath + "/items/honeycomb.png"],












	["location.bubbleTunnel0",rootPath + "/gui/progress_bar_layer_0.png"],
	["location.bubbleTunnel1",rootPath + "/gui/progress_bar_layer_1.png"],
	["location.bubbleTunnel2",rootPath + "/gui/progress_bar_layer_2.png"],

	["location.boss_arena.room",rootPath + "/background/boss_arena_room.png"],
	["location.boss_arena.summon_circle",rootPath + "/background/boss_arena_summon_circle.png"],

	["location.castle.room",rootPath + "/background/the_castle_room.png"],
	["location.castle.pillar",rootPath + "/background/the_castle_pillar.png"],
	["location.castle.door",rootPath + "/background/the_castle_door.png"],
	["location.castle.light.back",rootPath + "/background/the_castle_light_source_back.png"],
	["location.castle.light",rootPath + "/background/the_castle_light_source.png"],









	["entity.bubble",rootPath + "/enemies/bubble_base_noshine.png"],
	["entity.bubble.base.shine",rootPath + "/enemies/bubble_base_shine.png"],

	["entity.the_fat_one.base",rootPath + "/enemies/the_fat_one_base.png"],
	["entity.the_fat_one.mouth",rootPath + "/enemies/the_fat_one_mouth.png"],

	["entity.rubberDuck",rootPath + "/enemies/rubber_duck.png"],
	["entity.bat.base",rootPath + "/enemies/bat_base.png"],
	["entity.bat.fat.base",rootPath + "/enemies/bat_base_fat.png"],
	["entity.bat.blind.base",rootPath + "/enemies/bat_base_blind.png"],
	["entity.bat.eyes",rootPath + "/enemies/bat_eyes.png"],
	["entity.bat.wing.left",rootPath + "/enemies/bat_wing_left.png"],
	["entity.bat.wing.right",rootPath + "/enemies/bat_wing_right.png"],

	["entity.cove.fish.fin.right",rootPath + "/enemies/cove_fish_fin_right.png"],
	["entity.cove.fish.fin.left",rootPath + "/enemies/cove_fish_fin_left.png"],
	["entity.cove.fish.poison.base",rootPath + "/enemies/cove_fish_poison_sprite.png"],
	["entity.cove.fish.fire.base",rootPath + "/enemies/cove_fish_fire_sprite.png"],
	["entity.cove.fish.ice.base",rootPath + "/enemies/cove_fish_ice_sprite.png"],
	["entity.cove.fish.thunder.base",rootPath + "/enemies/cove_fish_thunder_sprite.png"],

	["entity.spider.base",rootPath + "/enemies/spider_base.png"],
	["entity.spider.base.2",rootPath + "/enemies/spider_abdomen.png"],
	["entity.spider.base.2.medium",rootPath + "/enemies/spider_abdomen_medium.png"],
	["entity.spider.leg.left",rootPath + "/enemies/spider_leg_left.png"],
	["entity.spider.leg.right",rootPath + "/enemies/spider_leg_right.png"],
	["entity.spider.fang.left",rootPath + "/enemies/spider_fang_left.png"],
	["entity.spider.fang.right",rootPath + "/enemies/spider_fang_right.png"],

	["entity.spider.base.dash",rootPath + "/enemies/spider_base_dash.png"],
	["entity.spider.base.2.dash",rootPath + "/enemies/spider_abdomen_dash.png"],
	["entity.spider.leg.left.dash",rootPath + "/enemies/spider_leg_left_dash.png"],
	["entity.spider.leg.right.dash",rootPath + "/enemies/spider_leg_right_dash.png"],

	["entity.spider.egg.lay",rootPath + "/enemies/spider_egg_sprite.png"],
	["entity.spider.web",rootPath + "/enemies/spider_web.png"],

	["entity.spider.queen.base",rootPath + "/enemies/spider_queen_base.png"],
	["entity.spider.queen.abdomen",rootPath + "/enemies/spider_queen_abdomen.png"],
	["entity.spider.queen.leg",rootPath + "/enemies/spider_queen_leg.png"],

	["entity.waterfly.base",rootPath + "/enemies/waterfly_base.png"],
	["entity.waterfly.tail",rootPath + "/enemies/waterfly_tail.png"],
	["entity.waterfly.tail.end",rootPath + "/enemies/waterfly_tail_end.png"],
	["entity.waterfly.wing",rootPath + "/enemies/waterfly_wing.png"],

	["entity.bubblebee.base",rootPath + "/enemies/bubblebee_base.png"],
	["entity.bubblebee.abdomen",rootPath + "/enemies/bubblebee_abdomen.png"],
	["entity.bubblebee.antennae",rootPath + "/enemies/bubblebee_antennae.png"],
	["entity.bubblebee.leg",rootPath + "/enemies/bubblebee_leg.png"],
	["entity.bubblebee.leg.end",rootPath + "/enemies/bubblebee_leg_end.png"],
	["entity.bubblebee.wing",rootPath + "/enemies/bubblebee_wing.png"],

	["entity.bubblebee.small.base",rootPath + "/enemies/bubblebee_base_small.png"],
	["entity.bubblebee.small.abdomen",rootPath + "/enemies/bubblebee_abdomen_small.png"],
	["entity.bubblebee.small.antennae",rootPath + "/enemies/bubblebee_antennae_small.png"],
	["entity.bubblebee.small.leg",rootPath + "/enemies/bubblebee_leg_small.png"],
	["entity.bubblebee.small.leg.end",rootPath + "/enemies/bubblebee_leg_end_small.png"],
	["entity.bubblebee.small.wing",rootPath + "/enemies/bubblebee_wing_small.png"],

	["entity.bubblebee.base.queen",rootPath + "/enemies/bubblebee_base_queen.png"],
	["entity.bubblebee.abdomen.queen",rootPath + "/enemies/bubblebee_abdomen_queen.png"],

	["entity.honey.drop",rootPath + "/particles/honey_drop.png"],
	["entity.honey.chunk.1",rootPath + "/particles/honey_chunk_1.png"],

	["entity.honey.comb.5",rootPath + "/enemies/honeycomb_5.png"],
	["entity.honey.comb.4",rootPath + "/enemies/honeycomb_4.png"],
	["entity.honey.comb.3",rootPath + "/enemies/honeycomb_3.png"],
	["entity.honey.comb.2",rootPath + "/enemies/honeycomb_2.png"],
	["entity.honey.comb.1",rootPath + "/enemies/honeycomb_1.png"],

	["entity.frog.base",rootPath + "/enemies/frog_base.png"],
	["entity.frog.hand.1",rootPath + "/enemies/frog_hand_1.png"],
	["entity.frog.hand.2",rootPath + "/enemies/frog_hand_2.png"],
	["entity.frog.hand.3",rootPath + "/enemies/frog_hand_3.png"],

	["entity.frog.leg.1",rootPath + "/enemies/frog_leg_1.png"],
	["entity.frog.leg.2",rootPath + "/enemies/frog_leg_2.png"],
	["entity.frog.leg.3",rootPath + "/enemies/frog_leg_3.png"],


	["entity.frogo.base",rootPath + "/enemies/frogo_base.png"],
	["entity.frogo.hand.1",rootPath + "/enemies/frogo_hand_1.png"],
	["entity.frogo.hand.2",rootPath + "/enemies/frogo_hand_2.png"],
	["entity.frogo.hand.3",rootPath + "/enemies/frogo_hand_3.png"],

	["entity.frogo.leg.1",rootPath + "/enemies/frogo_leg_1.png"],
	["entity.frogo.leg.2",rootPath + "/enemies/frogo_leg_2.png"],
	["entity.frogo.leg.3",rootPath + "/enemies/frogo_leg_3.png"],


	["entity.frogo.enraged.base",rootPath + "/enemies/frogo_base_armor.png"],
	["entity.frogo.enraged.hand.1",rootPath + "/enemies/frogo_hand_1_armor.png"],
	["entity.frogo.enraged.hand.2",rootPath + "/enemies/frogo_hand_2_armor.png"],
	["entity.frogo.enraged.hand.3",rootPath + "/enemies/frogo_hand_3_armor.png"],

	["entity.frogo.enraged.leg.1",rootPath + "/enemies/frogo_leg_1_armor.png"],
	["entity.frogo.enraged.leg.2",rootPath + "/enemies/frogo_leg_2_armor.png"],
	["entity.frogo.enraged.leg.3",rootPath + "/enemies/frogo_leg_3_armor.png"],

	["entity.tadpole.base",rootPath + "/enemies/tadpole_base.png"],
	["entity.tadpole.tail",rootPath + "/enemies/tadpole_tail.png"],

	["entity.tadpole.blue.base",rootPath + "/enemies/tadpole_blue_base.png"],
	["entity.tadpole.blue.tail",rootPath + "/enemies/tadpole_blue_tail.png"],

	
	["entity.bubble.formation.0",rootPath + "/enemies/bubble_formation_0.png"],
	["entity.bubble.formation.2.shield",rootPath + "/enemies/bubble_formation_2_shield.png"],
	["entity.bubble.formation.3",rootPath + "/enemies/bubble_formation_3.png"],
	["entity.bubble.formation.4",rootPath + "/enemies/bubble_formation_4.png"],
	["entity.bubble.formation.5",rootPath + "/enemies/bubble_formation_5.png"],
	
	["entity.trim",rootPath + "/enemies/trim.png"],
	["entity.trim.fat",rootPath + "/enemies/trim_fat.png"],
	["entity.trim.formation.0.3",rootPath + "/enemies/trim_formation_0_3.png"],
	["entity.trim.formation.0.2",rootPath + "/enemies/trim_formation_0_2.png"],
	["entity.trim.formation.0.1",rootPath + "/enemies/trim.png"],



	["entity.celltipede.head",rootPath + "/enemies/celltipede_head.png"],
	["entity.celltipede.head.left",rootPath + "/enemies/celltipede_head_left.png"],
	["entity.celltipede.head.right",rootPath + "/enemies/celltipede_head_right.png"],
	["entity.celltipede.fang.left",rootPath + "/enemies/celltipede_fang_left.png"],
	["entity.celltipede.fang.right",rootPath + "/enemies/celltipede_fang_right.png"],

	["entity.celltipede.leg.left",rootPath + "/enemies/celltipede_leg_left.png"],
	["entity.celltipede.leg.right",rootPath + "/enemies/celltipede_leg_right.png"],
	["entity.celltipede.tail.left",rootPath + "/enemies/celltipede_tail_left.png"],
	["entity.celltipede.tail.right",rootPath + "/enemies/celltipede_tail_right.png"],


	["entity.destroyer.back",rootPath + "/enemies/section_boss_1_back.png"],
	["entity.destroyer.back.sprite",rootPath + "/enemies/section_boss_1_back_sprite.png"],
	["entity.destroyer.eyes",rootPath + "/enemies/section_boss_1_eyes.png"],
	["entity.destroyer.helmet",rootPath + "/enemies/section_boss_1_helmet.png"],
	["entity.destroyer.shield",rootPath + "/enemies/section_boss_1_shield.png"],

	["entity.trap.spikes",rootPath + "/enemies/trap_spikes.png"],
	["entity.trap.spikes.open",rootPath + "/enemies/trap_spikes_open.png"],

	["entity.shadow",rootPath + "/enemies/entity_shadow.png"],









	["entity.npc.hand.left",rootPath + "/npc/npc_hand_left.png"],
	["entity.npc.hand.right",rootPath + "/npc/npc_hand_right.png"],
	["entity.npc.miner",rootPath + "/npc/npc_miner.png"],
	["entity.npc.sensei",rootPath + "/npc/npc_sensei.png"],

	["entity.npc.stylist.base",rootPath + "/npc/npc_stylist.png"],
	["entity.npc.stylist.hair",rootPath + "/npc/npc_stylist_hair.png"],

	["entity.npc.mage.base",rootPath + "/npc/npc_mage.png"],
	["entity.npc.mage.hat",rootPath + "/npc/npc_mage_hat.png"],

	["entity.npc.chief.base",rootPath + "/npc/npc_chief.png"],
	["entity.npc.chief.hat",rootPath + "/npc/npc_chief_hat.png"],

	["entity.npc.statue",rootPath + "/npc/npc_statue.png"],





	["vfx.tp",rootPath + "/particles/tp_vfx.png"],
	["vfx.tp2",rootPath + "/particles/tp_vfx2.png"],
	
	["player.skin.base",rootPath + "/player/skin_base.png"],
	["player.skin.base.f",rootPath + "/player/skin_base_f.png"],
	
	["player.skin.kitsune.base",rootPath + "/player/skin_kitsune_base.png"],
	["player.skin.kitsune.tail",rootPath + "/player/skin_kitsune_tail.png"],
	
	["player.skin.kitsune.angelic.base",rootPath + "/player/skin_kitsune_base_angelic.png"],
	["player.skin.kitsune.angelic.tail",rootPath + "/player/skin_kitsune_tail_angelic.png"],
	
	["player.skin.kitsune.shadowflame.base",rootPath + "/player/skin_kitsune_base_shadowflame.png"],
	["player.skin.kitsune.shadowflame.tail",rootPath + "/player/skin_kitsune_tail_shadowflame.png"],
	
	["player.skin.reaper.base",rootPath + "/player/skin_reaper_base.png"],
	["player.skin.reaper.cape",rootPath + "/player/skin_reaper_cape.png"],
	["player.skin.reaper.hand.left",rootPath + "/player/skin_reaper_hand_left.png"],
	["player.skin.reaper.hand.right",rootPath + "/player/skin_reaper_hand_right.png"],
	
	["player.skin.catgirl.base",rootPath + "/player/skin_catgirl_base.png"],
	["player.skin.catgirl.tail",rootPath + "/player/skin_catgirl_tail.png"],
	




	["model.item.bubbleCannon1",rootPath + "/player/models/bubble_cannon1.png"],
	["model.item.cannonBase",rootPath + "/player/models/cannon_base.png"],

	["model.item.the_virtuoso",rootPath + "/player/models/the_virtuoso.png"],

	["model.item.machine.gun",rootPath + "/player/models/machine_gun_base.png"],
	["model.item.machine.gun.0",rootPath + "/player/models/machine_gun_0.png"],

	["model.item.rifle",rootPath + "/player/models/model_rifle_1.png"],
	["model.item.rifle.0",rootPath + "/player/models/model_rifle_2.png"]
	

];class EntityBat extends Entity
{
	constructor(x, y)
	{
		super(x, y);
		
		this.name = "ENTITY.BAT.NAME";

		this.Texture = "entity.bat.base";
        this.Eyes = 'entity.bat.eyes';
        this.wingTextureLeft = 'entity.bat.wing.left';
        this.wingTextureRight = 'entity.bat.wing.right';

		// this.TextureRotation = 180;
		// this.Rotation = 180;

		this.MAXHP = 150;
		this.HP = this.MAXHP;
		this.AD = 20;
		this.ATTACK_SPEED = 1.5;
        this.ATTACK_RANGE = 400;
		this.FOLLOW_RANGE = 350;
        this.BULLET_SPEED = 950;
		this.SPD = 330;
		
		var bulletStats = 
		{
			Type: "BulletSoundWave",
			Scale: 2
		};

		this.isAggressive = true;

		this.AI.Apply(new AI_AttackMelee(Player, this.AD));
        this.AI.Apply(new AI_Follow(World.Player, true));
		this.AI.Apply(new AI_Walk());
		this.AI.Apply(new AI_Wander(false, 1));
		this.AI.Apply(new AI_AttackRange(World.Player, bulletStats));
		// this.AI.Apply(new AI_ShotOnCircle({
		// 	shotCount: 16,
		// 	shotDelayMin: 8,
		// 	shotDelayMax: 10
		// },
		// {
		// 	Texture: "bullet_enemy",
		// 	Scale: 2
		// }));
		
		this.HitBox.Scale = .5;
		this.attack_frame = 0;

		this.LootTable = new LootTable([
			new LootTableItemData("Cannon2", 5, 1, 1)
		]);

        this.WingAnimation = new Transition(0, 4, .15, true, 0, 0, false);
		this.setScale(1.5);
	}

	Update()
	{
		super.Update();

		if(this.AI.AttackRange)
		{
			var charge = this.AI.AttackRange.attackCharge;
			this.attack_frame = Math.round((charge - 50) / 5);
			if(this.attack_frame < 0) this.attack_frame = 0;
		}
	}

    RenderTexture(context)
	{
		var wing_texture_left = TextureManager.Get(this.wingTextureLeft);
		var wing_texture_right = TextureManager.Get(this.wingTextureRight);
        var base_texture = TextureManager.Get(this.Texture);
        var eyes_texture = TextureManager.Get(this.Eyes);;

        var wing_dist_x = 12 * this.Scale;

        var frame = Math.round(this.WingAnimation.Update());


        var x = this.x - Camera.xView;
        var y = this.y - Camera.yView;
        var size = wing_texture_left.width;

        var tX = -this.width * this.Scale / 2;
        var tY = (-this.height * this.Scale / 2) - (5 * this.Scale);

        var left_wing_tX = (tX - this.width * this.Scale / 2) - wing_dist_x;
        var right_wing_tX = (tX + this.width * this.Scale / 2) + wing_dist_x;

        //left wing
        context.save();
		context.translate(x, y);
		context.globalAlpha = this.opacity;
		context.drawImage(wing_texture_left, 0, frame * size, size, size, left_wing_tX, tY, this.width * this.Scale, this.height * this.Scale);
		context.restore();


        // //right wing
        context.save();
		context.translate(x, y);
		context.globalAlpha = this.opacity;
		context.drawImage(wing_texture_right, 0, frame * size, size, size, right_wing_tX, tY, this.width * this.Scale, this.height * this.Scale);
		context.restore();


        //base
        context.save();
		context.translate(x, y);
		context.globalAlpha = this.opacity;
		context.drawImage(base_texture, 0, this.attack_frame * size, size, size, tX, tY, this.width * this.Scale, this.height * this.Scale);
		context.restore();


		if(!this.Eyes) return;
         //Eyes
		Graphic.addPostRenderFunction(Graphic.Layer.LightLevel, () => {
			ChangeLayer(Graphic.Layer.LightLevel);

				ctx.save();
				ctx.globalCompositeOperation = 'source-atop';
				ctx.translate(x, y);
				ctx.globalAlpha = this.opacity;
				ctx.drawImage(eyes_texture, 0,  0, size, size, tX, tY, this.width * this.Scale, this.height * this.Scale);
				ctx.restore();

			RestoreLayer();
		});
	}
}
World.RegisterEntity(EntityBat);























class EntityFatBat extends EntityBat
{
	constructor(x, y)
	{
		super(x, y);
		
		this.name = "ENTITY.BAT.FAT.NAME";

		this.Texture = "entity.bat.fat.base";

		this.Tier = 1;

		this.MAXHP = 200;
		this.HP = this.MAXHP;
		this.AD = 20;
		this.ATTACK_SPEED = 1.5;
        this.ATTACK_RANGE = 600;
		this.FOLLOW_RANGE = 500;
        this.BULLET_SPEED = 950;
		this.SPD = 300;

		this.isAggressive = true;

		this.AI.Delete('AttackRange');

		this.AI.Apply(new AI_AttackMelee(Player, this.AD));
        this.AI.Apply(new AI_Follow(World.Player, true));
		this.AI.Apply(new AI_Walk());
		this.AI.Apply(new AI_Wander(false, 1));


		this.LootTable = new LootTable([
			// new LootTableItemData("Cannon2", 5, 1, 1)
		]);

		this.setScale(2.5);

		this.attackAnimationDuration = 30;

		this.isUsingAttack = false;
		this.attackDuration = 5 * Main.FPS;
		this.attackCoolTime = 10 * Main.FPS;
		this.attackStart = MathHelper.randomInRange(3, 5) * Main.FPS;
	}

	Update()
	{
		super.Update();

		var t = this.attackStart - this.ageInTicks;
		if(t <= this.attackAnimationDuration)
		{
			var p = t / this.attackAnimationDuration;
			if(p > 1) p = 1;
			if(p < 0) p = 0;
			this.attack_frame = Math.floor(5 * (1-p));
		}

		if(this.ageInTicks == this.attackStart) this.isUsingAttack = true;

		if(this.isUsingAttack)
		{
			this.allowMove = false;
			var tick = this.ageInTicks-this.attackStart;

			if(MathHelper.GetDistance(this, World.Player) <= this.ATTACK_RANGE)
			{
				var strength = 400;
				var motion = Motion.Get([World.Player.x, World.Player.y], [this.x, this.y], strength);
					World.Player.ApplyMove(motion);
			}

			var angle = MathHelper.randomInRange(0, 360);
			Particle.SummonCirclePattern("bubble", this.x, this.y, 0.4, 1000, 1, 
				this.ATTACK_RANGE, angle, null, false);


			if(tick >= this.attackDuration) 
			{
				this.isUsingAttack = false;
				this.attackStart = this.ageInTicks + this.attackCoolTime;
				this.allowMove = true;
			}
		}


		var t = this.ageInTicks - (this.attackStart - this.attackCoolTime);
		if(t <= this.attackAnimationDuration)
		{
			var p = t / this.attackAnimationDuration;
			if(p > 1) p = 1;
			if(p < 0) p = 0;
			this.attack_frame = Math.floor(5 * (1-p));
		}
	}
}
World.RegisterEntity(EntityFatBat);



















class EntityBlindBat extends EntityBat
{
	constructor(x, y)
	{
		super(x, y);
		
		this.name = "ENTITY.BAT.BLIND.NAME";

		this.Texture = "entity.bat.blind.base";
        this.Eyes = null;

		this.Tier = 2;

		this.MAXHP = 130;
		this.HP = this.MAXHP;
		this.AD = 30;
		this.ATTACK_SPEED = 0.1;
        this.ATTACK_RANGE = 1000;
		this.FOLLOW_RANGE = 450;
        this.BULLET_SPEED = 2000;
		this.SPD = 290;
		
		var bulletStats = 
		{
			Type: "BulletEcho",
			Scale: 10,
			Bounce: 1,
			Pierce: 1,
			playerEffectChance: 100
		};

		this.AI.Delete('AttackRange');
		this.AI.Apply(new AI_AttackRange(World.Player, bulletStats));
	
		this.LootTable = new LootTable([
			// new LootTableItemData("Cannon2", 5, 1, 1)
		]);


		this.setScale(2);
	}

	Update()
	{
		super.Update();

		if(this.ageInTicks%45 == 0)
		{
			var scale = 20 * this.Scale;
			var x = this.x;
			var y = this.y;
			Particle.Summon('effect.sonic_boom.indicator', x, y, 0, 0, scale, 0, 1, 20, 
			{
				liveTime: 30, 
				owner: this,
				baseScale: scale,
				center: true,
				globalAlpha: 0.5,
				RENDER_LAYER: Graphic.Layer.LightLevel+1,
				onUpdate: function(){this.x = this.owner.x, this.y = this.owner.y;this.Scale = this.baseScale - (this.baseScale * (this.ageInTicks / this.liveTime))}
			});
		}
	}
}
World.RegisterEntity(EntityBlindBat);





class EntityBubble extends Entity
{
	constructor(x, y)
	{
		super(x, y);
		
		this.BULLET_SPEED = 800 + (this.level * 20);
		this.AD = 10;
		this.BULLET_SERIES = 1;
		this.ATTACK_SPEED = 1;
		this.ATTACK_RANGE = 1000;
		this.FOLLOW_RANGE = 1000;
		this.MAXHP = 20;
		this.HP = this.MAXHP;
		this.Texture = "bubble";
		this.name = 'ENTITY.BUBBLE.NAME';
		
		var bulletStats = 
		{
			Scale: 1
		};

		this.AI.Apply(new AI_Follow(World.Player, true));
		this.AI.Apply(new AI_Walk());
		this.AI.Apply(new AI_Wander());
		this.AI.Apply(new AI_AttackRange(World.Player, bulletStats));
		
		this.isAggressiveOnHurt = true;
		
		// this.Color = new Color(255, 64, 64);
		this.HitBox.Scale = 1;

		this.RenderTransitions =
		{
			Scale: new Transition(1, 0.95, 0.25, true, 0.02, 0.02)
		};

		this.LootTable = new LootTable([
			new LootTableItemData("Cannon1", 10, 1, 1),
			new LootTableItemData("EnchantGemAD", 5, 1, 1)
		]);

		this.setScale(1);
	}
	
	Update()
	{
		super.Update();
		if(!this.isBoss)
		{
			if(this.aggressive)
			{
				this.SPD = 240 + (this.level * 10);
				this.Color = new Color(255, 0, 0);
			}
			else
			{
				this.SPD = 90 + (this.level * 10);
			}
		}
	}
}
World.RegisterEntity(EntityBubble);class EntityBubbleFormation0 extends Entity
{
	constructor(x, y)
	{
		super(x, y);
		
		this.name = 'ENTITY.BUBBLE_FORMATION.1.NAME';
		this.Texture = "entity.bubble.formation.0";
		this.Textures = 
		{
			Base: "entity.bubble.formation.0",
			BaseFrames: 4,
			Shine: "entity.bubble.base.shine"
		};
		this.TextureRotation = 180;
		this.Rotation = 180;

		this.Tier = 1;

		this.MAXHP = 35;
		this.HP = this.MAXHP;
		this.AD = 10;
		this.ATTACK_SPEED = .5;
		this.SPD = 200;

		this.ATTACK_RANGE = 1000;
		this.FOLLOW_RANGE = 1000;
		this.BULLET_SPEED = 800;

        var rotationTime = 1;
        this.rotationSpeed = 360 / (rotationTime * Main.FPS);
        this.baseRotationSpeed = this.rotationSpeed;

		this.allowRotationChange = false;
		
		var bulletStats = 
		{
			Scale: 1
		};

		this.AI.Apply(new AI_Follow(World.Player, true));
		this.AI.Apply(new AI_Walk());
		this.AI.Apply(new AI_Wander());
		this.AI.Apply(new AI_AttackRange(World.Player, bulletStats));
		
		this.isAggressiveOnHurt = true;

		this.RenderTransitions =
		{
			Scale: new Transition(1, 0.95, 0.25, true, 0.02, 0.02)
		}

		this.LootTable = new LootTable([
			new LootTableItemData("EnchantGemHP", 5, 1)
		]);

		this.setScale(1);
	}

	Update()
	{
		if(this.AttackRangeCharge >= 40)
		{
			this.allowMove = false;
			this.allowFollow = false;

			this.rotationSpeed = this.baseRotationSpeed * 2;
			if(this.AttackRangeCharge >= 80) this.rotationSpeed = this.baseRotationSpeed * 3;
		}
		else
		{
			this.rotationSpeed = this.baseRotationSpeed;
		}
        
		super.Update();
	}

	RenderTexture(context)
	{
		this.Rotation = (this.Rotation + this.rotationSpeed)%360;

        var x = this.x - Camera.xView;
        var y = this.y - Camera.yView;
        var height = this.height;
        var width = this.width;

        var rotation = this.Rotation + this.TextureRotation;
        var scale = this.Scale;
        var alpha = this.Transparency;
		var f = Math.floor((1 - (this.HP / this.MAXHP)) * this.Textures.BaseFrames);

        var textureBase = TextureManager.Get(this.Textures.Base);
        var textureShine = TextureManager.Get(this.Textures.Shine);

        Graphic.DrawRotatedAnimatedImage(context, f, this.Textures.BaseFrames, 'Y', 
			textureBase, x, y, width, height, scale, rotation, alpha);

        Graphic.DrawRotatedImage(context, textureShine, x, y, width, height, scale, 0, alpha);
	}
}
World.RegisterEntity(EntityBubbleFormation0);















class EntityBubbleFormation2 extends Entity
{
	constructor(x, y)
	{
		super(x, y);
		
		this.name = 'ENTITY.BUBBLE_FORMATION.2.NAME';
		this.Textures = 
		{
			Base: "entity.bubble",
			Shine: "entity.bubble.base.shine",
			Shield: "entity.bubble.formation.2.shield"
		};
		this.TextureRotation = 180;
		this.Rotation = 180;

		this.Tier = 2;

		this.MAXHP = 30;
		this.HP = this.MAXHP;
		this.AD = 20;
		this.ATTACK_SPEED = .25;
		this.SPD = 150;

		this.FOLLOW_RANGE = 2000;

        var rotationTime = 1;
        this.rotationSpeed = 360 / (rotationTime * Main.FPS);
        this.baseRotationSpeed = this.rotationSpeed;

		this.allowRotationChange = false;
		

		this.AI.Apply(new AI_Follow(World.Player, true));
		this.AI.Apply(new AI_Walk());
		this.AI.Apply(new AI_Wander());
		this.AI.Apply(new AI_AttackMelee(Player, 0, 1));
		
		this.isAggressive = true;

		this.RenderTransitions =
		{
			Scale: new Transition(1, 0.95, 0.25, true, 0.02, 0.02)
		}

		this.Resistance[ELEMENT.PHYSICAL] = true;

		this.LootTable = new LootTable([
			new LootTableItemData("EnchantGemDEF", 5, 1)
		]);

		this.setScale(1);
	}

	RenderTexture(context)
	{
		this.Rotation = (this.Rotation + this.rotationSpeed)%360;

        var x = this.x - Camera.xView;
        var y = this.y - Camera.yView;
        var height = this.height;
        var width = this.width;

        var rotation = this.Rotation + this.TextureRotation;
        var scale = this.Scale;
        var alpha = this.Transparency;

        var textureBase = TextureManager.Get(this.Textures.Base);
        var textureShine = TextureManager.Get(this.Textures.Shine);
        var textureShield = TextureManager.Get(this.Textures.Shield);
		var tY = height;
		var shields = 4;
		var angle = 360 / shields;

        Graphic.DrawRotatedImage(context, textureBase, x, y, width, height, scale, this.TextureRotation, alpha);
        Graphic.DrawRotatedImage(context, textureShine, x, y, width, height, scale, 0, alpha);

		for(var i = 0; i < shields; i++)
		{
			Graphic.DrawRotatedImage(context, textureShield, x, y, width, height, scale, rotation + (i*angle), alpha, -tY);
		}
	}
}
World.RegisterEntity(EntityBubbleFormation2);







class EntityBubbleFormation3 extends Entity
{
	constructor(x, y)
	{
		super(x, y);
		this.name = 'ENTITY.BUBBLE_FORMATION.3.NAME';
		
		this.BULLET_SPEED = 900;
		this.AD = 10;
		this.BULLET_SERIES = 3;
		this.BULLET_SERY_DELAY = 10;
		this.ATTACK_SPEED = 2;
		this.ATTACK_RANGE = 850;
		this.FOLLOW_RANGE = 850;
		this.MAXHP = 60;
		this.SPD = 150;
		this.HP = this.MAXHP;
		this.Texture = "entity.bubble.formation.3";
		
		var bulletStats = 
		{
			Scale: 1
		};

		this.AI.Apply(new AI_Follow(World.Player, true));
		this.AI.Apply(new AI_Walk());
		this.AI.Apply(new AI_Wander());
		this.AI.Apply(new AI_AttackRange(World.Player, bulletStats));
		
		this.isAggressiveOnHurt = true;
		
		// this.Color = new Color(255, 64, 64);
		this.HitBox.Scale = 1;

		this.RenderTransitions =
		{
			Scale: new Transition(1, 0.95, 0.25, true, 0.02, 0.02)
		}

		this.LootTable = new LootTable([
			new LootTableItemData("RingPhysical", 5, 1, 1)
		]);

		this.setScale(2);
	}
}
World.RegisterEntity(EntityBubbleFormation3);








class EntityBubbleFormation4 extends Entity
{
	constructor(x, y)
	{
		super(x, y);
		this.name = 'ENTITY.BUBBLE_FORMATION.4.NAME';

		this.BULLET_SPEED = 900;
		this.AD = 5;
		this.ATTACK_SPEED = 1;
		this.FOLLOW_RANGE = 600;
		this.MAXHP = 90;
		this.SPD = 300;
		this.HP = this.MAXHP;
		this.Texture = "entity.bubble.formation.4";

		this.AI.Apply(new AI_AttackMelee(Player, 0, 2));
		this.AI.Apply(new AI_Follow(World.Player, true));
		this.AI.Apply(new AI_Walk());
		this.AI.Apply(new AI_Dash(this, Player, false, 3, 5, {dashMultiplier: 5, dashDuration: 15}));
		
		this.aggressive = true;
		
		this.HitBox.Scale = 1;

		this.RenderTransitions =
		{
			Scale: new Transition(1, 0.95, 0.25, true, 0.02, 0.02)
		}

		this.LootTable = new LootTable([
			// new LootTableItemData("RingPhysical", 5, 1, 1)
		]);

		this.setScale(2);
	}
}
World.RegisterEntity(EntityBubbleFormation4);










class EntityBubbleFormation5 extends Entity
{
	constructor(x, y)
	{
		super(x, y);
		this.name = 'ENTITY.BUBBLE_FORMATION.5.NAME';

		this.BULLET_SPEED = 900;
		this.AD = 10;
		this.BULLET_SERIES = 9;
		this.BULLET_SERY_DELAY = 5;
		this.BULLET_SPEED = 1100;

		this.ATTACK_SPEED = 1;
		this.ATTACK_RANGE = 850;
		this.FOLLOW_RANGE = 600;
		this.MAXHP = 100;
		this.SPD = 250;
		this.HP = this.MAXHP;
		this.Texture = "entity.bubble.formation.5";

		this.AI.Apply(new AI_AttackMelee(Player, 0, 2));
		this.AI.Apply(new AI_Follow(World.Player, true));
		this.AI.Apply(new AI_Walk());
		this.AI.Apply(new AI_Dash(this, Player, false, 5, 7, {dashMultiplier: 5, dashDuration: 15}));
		this.AI.Apply(new AI_AttackRange(World.Player, {Scale: 1, knockBack: 2}, {shootTrigger: function(o){return !o.isDashing}}));
		
		this.aggressive = true;
		
		this.HitBox.Scale = 1;

		this.RenderTransitions =
		{
			Scale: new Transition(1, 0.95, 0.25, true, 0.02, 0.02)
		}

		this.LootTable = new LootTable([
			new LootTableItemData('MachineGunBase', 5, 1, 1)
		]);

		this.setScale(2);
	}
}
World.RegisterEntity(EntityBubbleFormation5);







class EntityBubbleTank extends Entity
{
	constructor(x, y)
	{
		super(x, y);
		
		this.BULLET_SPEED = 900;
		this.AD = 10;
		this.BULLET_SERIES = 3;
		this.BULLET_SERY_DELAY = 10;
		this.ATTACK_SPEED = 2;
		this.ATTACK_RANGE = 850;
		this.FOLLOW_RANGE = 850;
		this.MAXHP = 60;
		this.SPD = 150;
		this.HP = this.MAXHP;
		this.Texture = "bubbleTank";
		
		var bulletStats = 
		{
			Scale: 1
		};

		this.AI.Apply(new AI_Follow(World.Player, true));
		this.AI.Apply(new AI_Walk());
		this.AI.Apply(new AI_Wander());
		this.AI.Apply(new AI_AttackRange(World.Player, bulletStats));
		
		this.isAggressiveOnHurt = true;
		
		// this.Color = new Color(255, 64, 64);
		this.HitBox.Scale = 1;

		this.scaleTransition = new Transition(1, 0.95, 0.25, true, 0.02, 0.02);

		this.LootTable = new LootTable([
			new LootTableItemData("RingPhysical", 5, 1, 1)
		]);

		this.setScale(2);
	}
	
	Update()
	{
		var distance = MathHelper.GetDistance([this.x, this.y], [World.Player.x, World.Player.y]);
		if(distance < 250)
		{
			this.aggressive = true;
		}
		else if(this.lastHurtBy == World.Player)
		{
			this.aggressive = true;
		}
		
		super.Update();
	}

	Render(ctx)
	{
		this.Scale = this.baseScale * this.scaleTransition.Update();
		super.Render(ctx);
	}
}
World.RegisterEntity(EntityBubbleTank);class EntityTurret extends Entity
{
	constructor(x, y)
	{
		super(x, y);
		
		this.BULLET_SPEED = 300;
		this.AD = 10;
		this.BULLET_SERIES = 3;
		this.ATTACK_SPEED = 3;
		this.ATTACK_RANGE = 600;
		this.MAXHP = 150;
		this.HP = this.MAXHP;
		this.Texture = "bubble_turret_head";
		this.isAggressive = true;
		
		this.rangeFromCenter = 30;
		this.scaleRangeFromCenter = true;
		
		this.bulletStats = 
		{
			Texture: "bullet_enemy",
			Scale: 0.6
		};

		this.AI.Apply(new AI_AttackRange(World.Player, this.bulletStats));
		this.AI.Apply(new AI_Observe(World.Player));
		
		this.isAggressiveOnHurt = true;
		
		this.HitBox.Scale = 0.5;
		this.setScale(2);
	}
	
	Update()
	{
		super.Update();
	}
	
	Render()
	{
		var texture = TextureManager.Get("bubble_turret_base");
			
		ctx.save();
		ctx.translate(this.x - Camera.xView, this.y - Camera.yView);
		ctx.rotate(0);
		ctx.globalAlpha = this.Transparency;
		if(this.Color)
		{
			texture = Graphic.ApplyMask(texture, this.Color);
		}
		ctx.drawImage(
			texture, 0, 0, texture.width, texture.height,
			-(this.width / 2) * this.Scale, -(this.height / 2) * this.Scale,
			(this.width * this.Scale), (this.height * this.Scale)
		);
		ctx.restore();
			
			
			
		texture = TextureManager.Get(this.Texture);
		ctx.save();
		ctx.translate(this.x - Camera.xView, this.y - Camera.yView);
		ctx.rotate(this.Rotation * Math.PI/180);
		ctx.globalAlpha = this.Transparency;
		if(this.Color)
		{
			texture = Graphic.ApplyMask(texture, this.Color);
		}
		ctx.drawImage(
			texture, 0, 0, texture.width, texture.height,
			-(this.width / 2) * this.Scale, -(this.height / 2) * this.Scale,
			(this.width * this.Scale), (this.height * this.Scale)
		);
		ctx.restore();
		
		if(this.isHurtAble)
		{
			var text = "[" + this.HP + "/" + this.MAXHP + "]";
			
			Style.FillText(ctx, this, text, this.x - Camera.xView, this.y - Camera.yView);
		}
		
		this.HitBox.Render();
	}
}
World.RegisterEntity(EntityTurret);class EntityBulletShield extends Entity
{
	constructor(x, y)
	{
		super(x, y);

		this.MAXHP = 10000;
		this.HP = this.MAXHP;
		this.oxygen = 0;
		this.Texture = "bubble";
		
		this.Scale = 0.5;
		this.HitBox.Scale = 1;

		this.baseScale = this.Scale;
		this.scaleTransition = new Transition(1, 0.95, 0.25, true, 0.02, 0.02);
		this.isFromPlayer = true;

		this.ChangedTick = null;
		this.Immunity.ALL = true;
	}

	Hurt(){return}
	
	Update()
	{
		super.Update();

		var r = this.AI.OrbitAround.radius;
		var hide_time = Main.FPS * .5;
		var p = 0;

		if(World.isChangingLocation)
		{
			//hide orbs when changing location
			p = 1 - (World.currentChangeTime / hide_time);
			if(p < 0) p = 0;

			this.OrbitRadius = r * p;
			this.Transparency = p;
		}
		else
		{
			
			p = (World.timeSinceRoomChange / hide_time);
			if(p > 1) p = 1;

			this.OrbitRadius = r * p;
			this.Transparency = p;
		}
	}

	Render(ctx)
	{
		this.Scale = this.baseScale * this.scaleTransition.Update();
		super.Render(ctx);
	}
}
World.RegisterEntity(EntityBulletShield);class EntityCoveFishPoison extends Entity
{
	constructor(x, y)
	{
		super(x, y);
		
		this.name = "ENTITY.COVE.FISH.POISON.NAME";
		this.Title = "";

		this.Texture = "entity.cove.fish.poison.base";
        this.finTextureLeft = 'entity.cove.fish.fin.left';
        this.finTextureRight = 'entity.cove.fish.fin.right';

		// this.TextureRotation = 180;
		// this.Rotation = 180;

		this.MAXHP = 800;
		this.HP = this.MAXHP;
		this.AD = 20;
		this.ATTACK_SPEED = .5;
        this.ATTACK_RANGE = 1000;
		this.FOLLOW_RANGE = 500;
        this.BULLET_SPEED = 400;
		this.SPD = 400;

		this.isAggressive = true;

		this.AI.Apply(new AI_AttackMelee(Player, this.AD));
        this.AI.Apply(new AI_Follow(World.Player, true));
		this.AI.Apply(new AI_Walk());
		this.AI.Apply(new AI_Wander(false, 1));
		
		this.HitBox.Scale = .75;


		this.LootTable = new LootTable([
			new LootTableItemData("Emerald1", 25, 1, 1)
		]);

        this.Immunity[ELEMENT.POISON] = true;

        this.attackFrames = 6;
        this.attackFrame = 0;
        this.attackAnimationDuration = 18;

        this.specialAttackDelay = 8 * Main.FPS;
        this.specialAttackAnimationDelayIndicator = 1 * Main.FPS;       //how earlier animation should start
        this.lastSpecialAttack = MathHelper.randomInRange(0, this.specialAttackDelay/2);

        this.specialAttackDuration = 3 * Main.FPS;
        this.specialAttackTicks = 0;
        this.specialAttackTick = 0;
        this.specialAttackTimes = 0;

        this.Transparency = .8;
        this.finsAnimation = new Transition(-20, 20, .15, true, 0, 0, false);
		this.setScale(5);

        this.heartDropChance = 50;
		this.heartDropValue = 2;
        this.oxygenMultiplier = 10;
	}

    specialAttack()
    {
        this.allowMove = false;
        var delay = 45;
        if(this.specialAttackTick%delay == 0)
        {
            var bullets = 24;
            var angle = (this.specialAttackTick%(delay*2) == 0) ? 0 : (360/bullets)/2;
            var y = this.y;
            this.y += this.height * .25 * this.baseScale;

            var stats = {};
                stats.spd = this.BULLET_SPEED;
                stats[STAT.ATTACK_RANGE] = 9999;
                stats.Scale = 2;
                stats.damage = 0,
                stats.Texture = 'effect.poison',
                stats.onPlayerCollisionEffects = [['Poisoning', 1, 10, false]],
                stats.onEntityCollisionEffects = [['Poisoning', 1, 10, false]]

            AI_ShotOnCircle.StaticShoot(this, stats, bullets, {angle: angle});

            this.y = y;
        }
    }

    onSpecialAttackEnd()
    {
        this.allowMove = true;
        this.specialAttackTimes++;
    }

    specialAttackUpdate()
    {
        if(this.specialAttackTick >= this.specialAttackDuration)
        {
            this.specialAttackTick = 0;
            this.lastSpecialAttack = this.specialAttackTicks;
            this.onSpecialAttackEnd();
            return;
        }

        this.specialAttack();
        this.specialAttackTick++;
    }

    Update()
    {
        super.Update();
        if(this.NoAI || this.lockAI) return;

        this.specialAttackTicks++;

        var tickToAttack = this.lastSpecialAttack + this.specialAttackDelay;
        if(this.specialAttackTicks >= tickToAttack)
        {
            this.specialAttackUpdate();
        }


        if(this.specialAttackTicks >= tickToAttack - this.attackAnimationDuration-this.specialAttackAnimationDelayIndicator)
        {
            var p = (this.specialAttackTicks-(tickToAttack-this.attackAnimationDuration-this.specialAttackAnimationDelayIndicator)) / this.attackAnimationDuration;
            if(p > 1) p = 1;
            this.attackFrame = (this.attackFrames-1) * p;
        }

        if(this.specialAttackTimes && this.specialAttackTicks-this.lastSpecialAttack <= this.attackAnimationDuration)
        {
            var p = (this.specialAttackTicks-this.lastSpecialAttack) / this.attackAnimationDuration;
            this.attackFrame = (this.attackFrames-1) * (1-p);
        }
    }

    RenderTexture(context)
	{
		var fin_texture_left = TextureManager.Get(this.finTextureLeft);
		var fin_texture_right = TextureManager.Get(this.finTextureRight);
        var base_texture = TextureManager.Get(this.Texture);

        var x = this.x - Camera.xView;
        var y = this.y - Camera.yView;
        var s = this.width / 512;
        var width = 175 * s;
        var height = 100 * s;
        var rotation = this.finsAnimation.Update();

        var tX = (this.width / 2) * .67 * this.Scale;


        Graphic.DrawRotatedImage(context, fin_texture_left, x-tX, y, width, height, this.Scale, -rotation, this.Transparency, width/2, 0);
        Graphic.DrawRotatedImage(context, fin_texture_right, x+tX, y, width, height, this.Scale, rotation, this.Transparency, -width/2, 0);


        Graphic.DrawRotatedAnimatedImage(context, this.attackFrame, this.attackFrames, 'Y', 
            base_texture, x, y, this.width, this.height, this.Scale, 0, this.Transparency, 0, 0);
	}
}
World.RegisterEntity(EntityCoveFishPoison);







class EntityCoveFishFire extends EntityCoveFishPoison
{
	constructor(x, y)
	{
		super(x, y);
		
		this.name = "ENTITY.COVE.FISH.FIRE.NAME";
		this.Texture = "entity.cove.fish.fire.base";

		this.MAXHP = 700;
		this.HP = this.MAXHP;
		this.AD = 20;
        this.ATTACK_RANGE = 1000;
		this.FOLLOW_RANGE = 500;
        this.BULLET_SPEED = 1200;
		this.SPD = 450;


		this.LootTable = new LootTable([
			// new LootTableItemData("BubbleTerminator", 5, 1, 1)
		]);

        this.Immunity[ELEMENT.POISON] = false;
        this.Immunity[ELEMENT.FIRE] = true;


        this.specialAttackDelay = 8 * Main.FPS;
        this.specialAttackDuration = 3 * Main.FPS;

        this.FireAnimationFrameDelay = 5;
        this.fireTick = 0;
		this.setScale(5);
	}

    specialAttack()
    {
        // this.allowMove = false;
        // var delay = 1;
        // if(this.specialAttackTick%delay == 0)
        // {
            var bullets = 1;
            var angle = MathHelper.getAngle2(this, World.Player) + MathHelper.randomInRange(-15, 15);
            var y = this.y;
            this.y += this.height * .25 * this.baseScale;

            var stats = {};
                stats.spd = this.BULLET_SPEED;
                stats[STAT.ATTACK_RANGE] = 9999;
                stats.Scale = 1.5 * this.Scale;
                stats.damage = this.AD/10;
                stats.knockBack = 0;
                stats.Type = 'BulletFlameStar';
                stats.Transparency = .5;

            AI_ShotOnCircle.StaticShoot(this, stats, bullets, {angle: angle});

            this.y = y;
        // }
    }

    RenderTexture(context)
    {
        super.RenderTexture(context);
        this.fireTick++;

        var fire_sprite = TextureManager.Get('effect.fire');
        var frames = 8;
        var frame = Math.floor((this.fireTick%(frames*this.FireAnimationFrameDelay))/this.FireAnimationFrameDelay);

        var x = this.x - Camera.xView;
        var y = this.y - Camera.yView;

        var scale = .15 * this.Scale;
        var width = fire_sprite.width;
        var height = fire_sprite.height/frames;
        var rotation = 0;

        var tX = this.width * .2 * this.Scale;
        var tY = this.height * .35 * this.Scale;

        Graphic.DrawRotatedAnimatedImage(context, frame, frames, 'Y',
            fire_sprite, x-tX, y-tY, width, height, scale, -rotation, this.Transparency);

        Graphic.DrawRotatedAnimatedImage(context, frame, frames, 'Y',
            fire_sprite, x+tX, y-tY, width, height, scale, rotation, this.Transparency);
    }
}
World.RegisterEntity(EntityCoveFishFire);







class EntityCoveFishIce extends EntityCoveFishPoison
{
	constructor(x, y)
	{
		super(x, y);
		
		this.name = "ENTITY.COVE.FISH.ICE.NAME";
		this.Texture = "entity.cove.fish.ice.base";

		this.MAXHP = 1000;
		this.HP = this.MAXHP;
		this.AD = 20;
        this.ATTACK_RANGE = 1000;
		this.FOLLOW_RANGE = 500;
        this.BULLET_SPEED = 300;
		this.SPD = 250;


		this.LootTable = new LootTable([
			new LootTableItemData("Icicle1", 25, 1, 1),
			new LootTableItemData("Sapphire1", 25, 1, 1)
		]);


        this.specialAttackDelay = 8 * Main.FPS;
        this.specialAttackDuration = 4.5 * Main.FPS;

        this.Immunity[ELEMENT.POISON] = false;
        this.Immunity[ELEMENT.ICE] = true;

		this.setScale(5);
	}

    specialAttack()
    {
        this.allowMove = false;
        var delay = 90;
        if(this.specialAttackTick%delay == 0)
        {
            var bullets = 1;
            var angle = MathHelper.getAngle2(this, World.Player);
            var y = this.y;
            this.y += this.height * .25 * this.baseScale;

            var stats = {};
                stats.spd = this.BULLET_SPEED;
                stats[STAT.ATTACK_RANGE] = 9999;
                stats.Scale = 4;
                stats.Bounce = 1;
                stats.damage = this.AD;
                stats.Type = 'BulletFrostBall';
                stats.onPlayerCollisionEffects = [['Slow', 50, 10, false]];
                stats.onEntityCollisionEffects = [['Slow', 50, 10, false]];

            AI_ShotOnCircle.StaticShoot(this, stats, bullets, {angle: angle});

            this.y = y;
        }
    }
}
World.RegisterEntity(EntityCoveFishIce);





class EntityEgg extends Entity
{
	constructor(x, y, owner, stats = {})
	{
		super(x, y);
        this.layTexture = "entity.spider.egg.lay";
        this.hatchTexture = "entity.spider.egg.lay";

        this.layProgress = 0;
        this.timeToHatch = 30;
        this.isHatching = false;
        this.hatchTime = 0;
        this.hatchProgress = 0;
        this.isHurtAble = false;
        this.knockBackResistance = 1;

        this.TextureData = 
        {
            frame: 0,
            frames: 16
        };

        this.contains = [];

        this.Owner = owner;
        this.lastShakePhase = 0;

        this.dropLoot = false;
		this.dropOxygen = false;

        for(var id in stats)
        {
            this[id] = stats[id];
        }

        this.setScale(this.Scale);
	}
	
	Update()
	{
		super.Update();
		
        this.layProgress = this.Owner.layProgress;
        if(!this.Owner || !this.Owner.isAlive) 
        {
            if(!this.isHatching && !this.isHurtAble) this.HP = this.MAXHP * this.layProgress;
            this.isHurtAble = true;       
        }
        
        if(!this.Owner.isLayingEgg) 
        {
            this.isHatching = true;
            this.isHurtAble = true;
        }
        this.Texture = this.layTexture;

        this.TextureData.frame = Math.floor(this.layProgress * this.TextureData.frames);

        if(this.isHatching)
        {
            this.Texture = this.hatchTexture;
            this.TextureData.frame = this.TextureData.frames-1;
            this.hatchTime++;
            this.hatchProgress = this.hatchTime / (this.timeToHatch * Main.FPS);

            this.UpdateHatch();

            if(this.hatchProgress >= 1)
            {
                this.Hatch()
            }
        }
	}

    UpdateHatch()
    {
        var hatchPhase = 0;
        var rotDir = 1;
        var shakeDur = 16;

        if(this.hatchProgress > .60) hatchPhase++;
        if(this.hatchProgress > .70) hatchPhase++;
        if(this.hatchProgress > .85) hatchPhase++;
        if(this.hatchProgress > .95) hatchPhase++;

        if(this.lastShakePhase != hatchPhase) this.Rotation = 0;

        if(hatchPhase) shakeDur /= hatchPhase;
        if(this.ageInTicks%shakeDur >= shakeDur/2) rotDir *= -1;

        this.Rotation += rotDir * (hatchPhase * 2);
    }

    Hatch()
    {
        var level = getLocationLevel(World.Location);
        
        for(var i = 0; i < this.contains.length; i++)
        {
            var type = World.EntityList[this.contains[i]];
            if(!type) continue;

            var entity = new type();
                entity.x = this.x;
                entity.y = this.y;
                entity.setLevel(level);
            
            World.AddEntity(entity);
        }

		World.Kill(this);
    }
}
World.RegisterEntity(EntityEgg);class EntityFrog extends Entity
{
	constructor(x, y)
	{
		super(x, y);
		
		this.name = "ENTITY.FROG.NAME";
		this.Title = "";

		this.MAXHP = 200;
		this.HP = this.MAXHP;
		this.AD = 20;
		this.ATTACK_SPEED = 1.5;
        this.ATTACK_RANGE = 400;
		this.FOLLOW_RANGE = 350;
        this.BULLET_SPEED = 950;
		this.SPD = 130;

        this.isJumping = false;
        this.JumpDuration = .5;
        this.JumpDelay = 3;
        this.JumpDistance = this.SPD * 5;
        this.shakeOnJump = 0;
		

		this.isAggressiveOnHurt = true;
		
		this.HitBox.Scale = .9;

		this.LootTable = new LootTable([]);


		this.RenderTransitions =
		{
			Scale: new Transition(1, 0.95, 0.25, true, 0.02, 0.02)
		};

        this.Model = new EntityFrogModel(this);
		this.setScale(1);
	}

    setupAI()
    {
        this.AI.Apply(new AI_Jump(false, this.JumpDelay, this.JumpDelay, Player));
		this.AI.Apply(new AI_AttackMelee(Player, 0, 1));
        this.AI.Apply(new AI_Observe(Player, this.JumpDistance * 1.5, function(owner){return owner.aggressive && !owner.isJumping}))
		this.AI.Apply(new AI_Walk());
    }
}













class EntityLakeFrog extends EntityFrog
{
	constructor(x, y)
	{
		super(x, y);
		
		this.name = "ENTITY.FROG.LAKE.NAME";

		this.MAXHP = 50;
		this.HP = this.MAXHP;
		this.AD = 20;
		this.SPD = 100;

        this.JumpDuration = .5;
        this.JumpDelay = 3;
        this.JumpDistance = this.SPD * 5;
		

		this.LootTable = new LootTable([
			new LootTableItemData("FlowInBottle", 5, 1, 1)
		]);

        this.setupAI();
		this.setScale(1.5);
	}
}
World.RegisterEntity(EntityLakeFrog);



class EntityGreenLakeFrog extends EntityFrog
{
	constructor(x, y)
	{
		super(x, y);
		
		this.name = "ENTITY.FROG.LAKE.GREEN.NAME";

		this.MAXHP = 50;
		this.HP = this.MAXHP;
		this.AD = 10;
		this.SPD = 100;
		this.ATTACK_SPEED = 1;
		this.FOLLOW_RANGE = 700;
		this.ATTACK_RANGE = 500;
		this.BULLET_SPEED = 5000;

        this.JumpDuration = .5;
        this.JumpDelay = 2;
        this.JumpDistance = this.SPD * 5;
		

		this.LootTable = new LootTable([
			new LootTableItemData("Rifle1", 5, 1, 1)
		]);

		var bulletStats = 
		{
			Type: "BulletFrogTongue",
			Scale: .25,
            damage: this.AD,
			[STAT.ATTACK_RANGE]: this.ATTACK_RANGE-100
		};

		this.aggressive = true;

        this.setupAI();
		this.AI.Apply(new AI_AttackRange(World.Player, bulletStats, {shootTrigger: function(o){return o.isAttackingWithTongue}}));

        this.Model = new EntityFrogModel(this, 'entity.frogo.');

		this.setScale(1.5);
	}

	onJumpEnd()
    {
        this.isAttackingWithTongue = true;
    }

	onJumpStart()
	{
		this.isAttackingWithTongue = false;
	}
}
World.RegisterEntity(EntityGreenLakeFrog);



















class EntityFrogModel extends ModelBase
{
	constructor(owner, textureFamily = 'entity.frog.')
	{
		super(owner, textureFamily);

        this.Scale = 0.125;

		this.Width = 512;
		this.Height = 512;


		var body = new Part(512, 512, 100);
		body.SetTexture("base", 512, 512);
		body.SetTextureRender(0, 1);
		body.SetRotation(0, 256, 256);

		var hand_pivot_left = new Part(20, 115, 100);
		hand_pivot_left.SetTexture("hand", 20, 100);
		hand_pivot_left.SetTextureRender(-2, -2);
		hand_pivot_left.SetRotation(-240, 10, 0);
		hand_pivot_left.visible = false;

		var hand_left_1 = new Part(80, 166, 100);
		hand_left_1.SetTexture("hand.1", 80, 166);
		hand_left_1.SetTextureRender(3, 2);
		hand_left_1.SetRotation(305, 40, 31);

		var hand_left_2 = new Part(80, 166, 100);
		hand_left_2.SetTexture("hand.2", 80, 166);
		hand_left_2.SetTextureRender(2, 3);
		hand_left_2.SetRotation(-285, 40, 31);

		var hand_left_3 = new Part(180, 156, 100);
		hand_left_3.SetTexture("hand.3", 180, 156);
		hand_left_3.SetTextureRender(1, 4);
		hand_left_3.SetRotation(26, 90, 31);

		var hand_pivot_right = new Part(20, 115, 100);
		hand_pivot_right.SetTexture("hand", 20, 100);
		hand_pivot_right.SetTextureRender(-2, -2);
		hand_pivot_right.SetRotation(-120, 10, 0);
		hand_pivot_right.visible = false;

		var hand_right_1 = new Part(80, 166, 100);
		hand_right_1.SetTexture("hand.1", 80, 166);
		hand_right_1.SetTextureRender(6, 2);
		hand_right_1.SetRotation(55, 40, 31);

		var hand_right_2 = new Part(80, 166, 100);
		hand_right_2.SetTexture("hand.2", 80, 166);
		hand_right_2.SetTextureRender(5, 3);
		hand_right_2.SetRotation(-80, 40, 31);

		var hand_right_3 = new Part(180, 156, 100);
		hand_right_3.SetTexture("hand.3", 180, 156);
		hand_right_3.SetTextureRender(4, 4, 0, 0, 0, 0, -1, 1);
		hand_right_3.SetRotation(-16, 90, 31);

		var leg_pivot_left = new Part(20, 200, 100);
		leg_pivot_left.SetTexture("hand", 20, 100);
		leg_pivot_left.SetTextureRender(-2, -2);
		leg_pivot_left.SetRotation(25, 10, 10);
		leg_pivot_left.visible = false;

		var leg_left_1 = new Part(80, 180, 100);
		leg_left_1.SetTexture("leg.1", 80, 180);
		leg_left_1.SetTextureRender(10, 10);
		leg_left_1.SetRotation(-265, 40, 31);

		var leg_left_2 = new Part(80, 200, 100);
		leg_left_2.SetTexture("leg.2", 80, 200);
		leg_left_2.SetTextureRender(9, 11);
		leg_left_2.SetRotation(200, 40, 31);

		var leg_left_3 = new Part(80, 200, 100);
		leg_left_3.SetTexture("leg.3", 80, 200);
		leg_left_3.SetTextureRender(8, 12);
		leg_left_3.SetRotation(-220, 40, 31);

		var leg_left_4 = new Part(180, 156, 100);
		leg_left_4.SetTexture("hand.3", 180, 156);
		leg_left_4.SetTextureRender(7, 4);
		leg_left_4.SetRotation(20, 90, 31);

		var leg_pivot_right = new Part(20, 200, 100);
		leg_pivot_right.SetTexture("hand", 20, 100);
		leg_pivot_right.SetTextureRender(-2, -2);
		leg_pivot_right.SetRotation(-25, 10, 10);
		leg_pivot_right.visible = false;

		var leg_right_1 = new Part(80, 180, 100);
		leg_right_1.SetTexture("leg.1", 80, 180);
		leg_right_1.SetTextureRender(14, 10);
		leg_right_1.SetRotation(-95, 40, 31);

		var leg_right_2 = new Part(80, 200, 100);
		leg_right_2.SetTexture("leg.2", 80, 200);
		leg_right_2.SetTextureRender(13, 11);
		leg_right_2.SetRotation(146, 40, 31);

		var leg_right_3 = new Part(80, 200, 100);
		leg_right_3.SetTexture("leg.3", 80, 200);
		leg_right_3.SetTextureRender(12, 12);
		leg_right_3.SetRotation(-136, 40, 31);

		var leg_right_4 = new Part(180, 156, 100);
		leg_right_4.SetTexture("hand.3", 180, 156);
		leg_right_4.SetTextureRender(11, 4, 0, 0, 0, 0, -1, 1);
		leg_right_4.SetRotation(-20, 90, 31);

		hand_pivot_left.AddChild(hand_left_1);
		hand_left_1.AddChild(hand_left_2);
		hand_left_2.AddChild(hand_left_3);
		hand_pivot_right.AddChild(hand_right_1);
		hand_right_1.AddChild(hand_right_2);
		hand_right_2.AddChild(hand_right_3);
		leg_pivot_left.AddChild(leg_left_1);
		leg_left_1.AddChild(leg_left_2);
		leg_left_2.AddChild(leg_left_3);
		leg_left_3.AddChild(leg_left_4);
		leg_pivot_right.AddChild(leg_right_1);
		leg_right_1.AddChild(leg_right_2);
		leg_right_2.AddChild(leg_right_3);
		leg_right_3.AddChild(leg_right_4);

		this.Parts.body = body;
		this.Parts.hand_pivot_left = hand_pivot_left;
		this.Parts.hand_left_1 = hand_left_1;
		this.Parts.hand_left_2 = hand_left_2;
		this.Parts.hand_left_3 = hand_left_3;
		this.Parts.hand_pivot_right = hand_pivot_right;
		this.Parts.hand_right_1 = hand_right_1;
		this.Parts.hand_right_2 = hand_right_2;
		this.Parts.hand_right_3 = hand_right_3;
		this.Parts.leg_pivot_left = leg_pivot_left;
		this.Parts.leg_left_1 = leg_left_1;
		this.Parts.leg_left_2 = leg_left_2;
		this.Parts.leg_left_3 = leg_left_3;
		this.Parts.leg_left_4 = leg_left_4;
		this.Parts.leg_pivot_right = leg_pivot_right;
		this.Parts.leg_right_1 = leg_right_1;
		this.Parts.leg_right_2 = leg_right_2;
		this.Parts.leg_right_3 = leg_right_3;
		this.Parts.leg_right_4 = leg_right_4;

		this.ApplyArmorModel();
		this.ApplyModelAnimation(EntityFrogAnimationJump);
	}

	Update()
	{
		super.Update();
	}

	Render(context)
	{
		super.Render(context);
	}
}






class EntityFrogAnimationJump extends AnimationBase
{
    constructor(model)
    {
        super(model);

        this.Duration = this.Owner.JumpDuration * Main.FPS;

        this.setAnimationSpacing(.3, .8);

        this.triggerFunction = function(anim){return anim.Owner.isJumping;};

        this.Data = 
        [
            new AnimationData('leg_left_1', 'Rotation', 360-265, 25),
            new AnimationData('leg_left_2', 'Rotation', 200, 360-70),
            new AnimationData('leg_left_3', 'Rotation', 360-220, 45),
            new AnimationData('leg_left_4', 'Rotation', 20, 0),


            new AnimationData('leg_right_1', 'Rotation', 360-95, 360-25),
            new AnimationData('leg_right_2', 'Rotation', 160, 70),
            new AnimationData('leg_right_3', 'Rotation', 360-140, 360-45),
            new AnimationData('leg_right_4', 'Rotation', 360-20, 360),

            new AnimationData('hand_right_1', 'Rotation', 55, -20),
            new AnimationData('hand_right_2', 'Rotation', -80, -30),
            new AnimationData('hand_right_3', 'Rotation', -15, 20),

            new AnimationData('hand_left_1', 'Rotation', 305, 360+20),
            new AnimationData('hand_left_2', 'Rotation', 360-280, 30),
            new AnimationData('hand_left_3', 'Rotation', 25, -20)
        ];
    }
}class EntityFrostTurret extends EntityTurret
{
	constructor(x, y)
	{
		super(x, y);

		this.BULLET_SPEED = 50;
		this.AD = 0;
		this.BULLET_SERIES = 1;
		this.ATTACK_SPEED = 10;
		this.ATTACK_RANGE = 600;
		this.MAXHP = 200;
		this.HP = this.MAXHP;
		this.Texture = "frost_turret_head";
		this.isAggressive = true;
		
		this.slow = 80;
		
		this.bulletStats = 
		{
			Texture: "bullet_snowflake",
			Scale: 0.1,
			slow: this.slow,
			onPlayerCollision: function(player)
			{
				if( (player.isHurtAble) && (player !== this.source))
				{
					player.Hurt(this.damage, this.source);
					player.slow = this.slow;
					this.Kill();
				}
			}
		};

		this.AI.Apply(new AI_AttackRange(World.Player, this.bulletStats));
		this.AI.Apply(new AI_Observe(World.Player));
		
		this.isAggressiveOnHurt = true;

		this.setScale(2);
	}
}
World.RegisterEntity(EntityFrostTurret);class EntityInvincibleShield extends Entity
{
	constructor(x, y, owner)
	{
		super(x, y);
		this.Owner = owner;
		
		this.name = "ENTITY.INVINCIBLE.SHIELD";
		this.Textures = 
		{
			base: 'effect.invincible.base',
			sprite: 'effect.invincible.sprite',
			particle: 'effect.invincible.0',
			idle: 'effect.invincible.idle',
		};

		this.MAXHP = 1;
		this.HP = this.MAXHP;
		
		this.HitBox.Scale = .9;

		this.knockBackResistance = 1;

		this.spriteAnimationDuration = 24;
		this.spriteAnimationFrames = [4, 3];

		this.idleAnimationDuration = 15;
		this.idleAnimationFrames = 15;
		this.idleAnimationDelayMin = 1;
		this.idleAnimationDelayMax = 3;
		this.idleAnimationTime = this.idleAnimationDelayMin * Main.FPS;

		this.animationTicks = 0;
		this.invincibleScale = 1.25;

		this.OpacityTransition = new Transition(.8, 0.5, .5, true, 0.02, 0.02);
		this.OpacityTransitionEnd = new Transition(.8, 0.3, .25, true, 0.02, 0.02);

		this.Immunity.ALL = true;
		this.hideOnRadar = true;
	}


	Update()
	{
		this.x = this.Owner.x;
		this.y = this.Owner.y;
		super.Update();

		if(this.ageInTicks >= this.spriteAnimationDuration && this.isKilled) this.Kill();
		if(!this.Owner.isAlive) this.Kill();
	}


	Hurt()
	{
		if(Settings.General.ShowDamageDealt)
		{
			DamageIndicator.AddObject(this.x, this.y, Lang.Get('TEXT.INVINCIBLE'), "DEALT", null);
		}

	}

	Kill()
	{
		if(this.isKilled) return super.Kill();

		this.ageInTicks = 0;
		this.isKilled = true;
		this.isHurtAble = false;
	}

    RenderTexture(context)
	{
		this.Scale = this.Owner.Scale * this.Owner.invincibleScale * this.invincibleScale;

		var base_texture = TextureManager.Get(this.Textures.base);
		var sprite_texture = TextureManager.Get(this.Textures.sprite);
		var particle_texture = TextureManager.Get(this.Textures.particle);
        var idle_texture = TextureManager.Get(this.Textures.idle);
		var x = this.x - Camera.xView;
		var y = this.y - Camera.yView;
		var opacity = (this.isEnding) ? this.OpacityTransitionEnd.Update()  : this.OpacityTransition.Update();


		if(this.ageInTicks < this.spriteAnimationDuration)
		{
			var p = this.ageInTicks / this.spriteAnimationDuration;
			if(this.isKilled) p = 1 - p;
			var frames = this.spriteAnimationFrames[0] * this.spriteAnimationFrames[1];
			var frame = Math.floor(p*frames);

			Graphic.DrawRotatedAnimatedImage(context, frame, this.spriteAnimationFrames, 'XY', 
				sprite_texture, x, y, this.width, this.width, this.Scale, this.Rotation, opacity);

			return;
		}

		
		Graphic.DrawRotatedImage(context, base_texture, x, y, this.width, this.height, this.Scale, this.Rotation, opacity);
		
		this.animationTicks++;
		if(this.idleAnimationTime <= this.animationTicks)
		{
			var p = (this.animationTicks - this.idleAnimationTime) / this.idleAnimationDuration;
			var frame = Math.floor(p*this.idleAnimationFrames);

			Graphic.DrawRotatedAnimatedImage(context, frame, this.idleAnimationFrames, 'Y', 
				idle_texture, x, y, this.width, this.width, this.Scale, this.Rotation, opacity);

			if(p>=1) this.idleAnimationTime = this.ageInTicks + (MathHelper.randomInRange(this.idleAnimationDelayMin, this.idleAnimationDelayMax) * Main.FPS);
		}


		// Graphic.addPostRenderFunction(Graphic.Layer.LightLevel, () => {
		// 	ChangeLayer(Graphic.Layer.LightLevel);

		// 		ctx.save();
		// 		ctx.globalCompositeOperation = 'source-atop';
		// 		ctx.translate(x, y);
		// 		ctx.globalAlpha = this.opacity;
		// 		ctx.drawImage(eyes_texture, 0,  0, size, size, tX, tY, this.width * this.Scale, this.height * this.Scale);
		// 		ctx.restore();

		// 	RestoreLayer();
		// });
	}
}
World.RegisterEntity(EntityInvincibleShield);



class EntityLargeBee extends Entity
{
	constructor(x, y)
	{
		super(x, y);
		
		this.name = "ENTITY.SPIDER.LAKE.QUEEN.NAME";
		this.description = "ENTITY.SPIDER.LAKE.QUEEN.DESCRIPTION";

		this.MAXHP = 2500;
		this.HP = this.MAXHP;
		this.AD = 10;
		this.ATTACK_SPEED = 1.5;
        this.ATTACK_RANGE = 1500;
		this.FOLLOW_RANGE = 750;
        this.BULLET_SPEED = 1800;
		this.SPD = 150;
		
        var bullet_stats = 
        {
            Scale: 1,
			Type: 'BulletSting',
			bullets: 0
        };

        this.AI.Apply(new AI_Wander(true, 4, 8));
		this.AI.Apply(new AI_AttackMelee(Player, this.AD));
        this.AI.Apply(new AI_Follow(World.Player, false, function(o){return o.aggressive || o.interestedIn}));
		this.AI.Apply(new AI_Walk());
		this.AI.Apply(new AI_Observe(World.Player, this.ATTACK_RANGE, function(owner){return owner.isFlying && owner.aggressive;}));
        this.AI.Apply(new AI_AttackRange(World.Player, bullet_stats, {updateTrigger: function(owner){return owner.isFlying;}}));


        this.aggressive = false;
        this.isAggressive = false;
        this.isAggressiveOnHurt = true;

        this.RenderTransitions =
		{
			Scale: new Transition(1, 0.95, 0.25, true, 0.02, 0.02)
		};

		this.HitBox.Scale = .5;

		var bodyHitBox = new HitBox();
			bodyHitBox.Scale = this.HitBox.Scale * 1.2;
			bodyHitBox.translationY = 0.72;

		this.advancedHitBox.push(bodyHitBox);

        this.Model = new LargeBeeModel(this);
		this.setScale(3);

        this.enragedAnimationDuration = 4 * Main.FPS;

        this.FlyDuration = 7 * Main.FPS;
        this.FlyTick = 0;

        this.DropHoneyChance = 3;

		this.invincibleScale = 3;
		this.LootTable = new LootTable();

        this.honeyPiecesOnTake = 2;
        this.interestedIn = null;
        this.canFlyAway = true;
        this.gotChunk = false;

        this.LookForHoneyDelay = MathHelper.randomInRange(10, 20) * Main.FPS;
        this.LookForHoneyTime = this.LookForHoneyDelay;
        this.timeToFlyAway = MathHelper.randomInRange(5, 10) * Main.FPS;

		this.honeyStats = {};
    }

    onHoneyGrab(){}

    onHurt()
    {
        this.Fly();
    }

    Fly()
    {
        if(this.isFlying) return;

        this.isFlying = true;
        this.SPD *= 5;
        this.FlyTick = 0;
    }

    FlyEnd()
    {
        if(!this.isFlying) return;

        this.isFlying = false;
        this.SPD /= 5;
        this.aggressive = false;

        this.AI.Wander.changeDir();
    }

    LookForHoney()
    {
        var honey = [];
        for(var i in World.Entities)
        {
            var e = World.Entities[i];
            if(!(e instanceof EntityHoneyChunk)) continue;
            honey.push(e);
        }

        if(honey.length)
        {
            var index = MathHelper.randomInRange(0, honey.length-1);
            this.interestedIn = honey[index];
            this.interestedIn.timeToSummon = this.interestedIn.ageInTicks + this.interestedIn.summonDelay;          //resets summon time of chunk
        }
    }

	SummonHoney()
	{
		var pos = MathHelper.getRandomPointInRange(World.CenterPoint, World.Radius*.9);
		var e = new EntityHoneyDrop(pos.x, pos.y);
		e.honeyStats = this.honeyStats;

		World.AddEntity(e);
	}

    Update()
    {
        super.Update();

        if(this.ageInTicks%60 == 0 && MathHelper.GetChance(this.DropHoneyChance)) this.SummonHoney();

        if(this.isFlying)
        {
            this.FlyTick++;
            if(this.FlyTick >= this.FlyDuration)
            {
                this.FlyEnd();
            }
        }

        if(this.ageInTicks >= this.LookForHoneyTime)
        {
            this.LookForHoney();
            this.LookForHoneyTime = this.ageInTicks + this.LookForHoneyDelay;
        }

        if(this.interestedIn)
        {
            if(!this.gotChunk)
            {
                var dist = MathHelper.GetDistance(this.interestedIn, this);
                if(dist > 50)
                {
                    this.AI.Follow.toFollow = this.interestedIn;
                    if(dist > 500) this.Fly();
                    // console.log('InterestedIn');
                }
                else
                {
                    this.AI.Follow.toFollow = World.Player;
                    this.FlyEnd();
                }

                if(dist <= 50)
                {
                    this.interestedIn.HP -= this.honeyPiecesOnTake;
                    this.Heal(5, true);
                    this.gotChunk = true;
                    this.timeToFlyAway += this.ageInTicks;
                    this.interestedIn = null;
                    // console.log('Chunk');

                    this.onHoneyGrab();
                }
            }
 

            if(!this.interestedIn?.isAlive) this.interestedIn = null;
        }

        if(this.gotChunk && !this.isFlyingAway && this.canFlyAway)
        {
            this.allowMove = false;
            if(this.ageInTicks >= this.timeToFlyAway)
            {
                var destination = 
                {
                    x: World.CenterPoint.x - World.Radius * 2,
                    y: World.CenterPoint.y - World.Radius * 2
                };

                this.AI = new AI();
                this.AI.Apply(new AI_Walk());

                this.FlyDuration = 999999;
                this.isFlying = false;
                this.Fly();

                var motion = Motion.Get(this, destination, this.SPD);
                this.moveX = motion.x;
                this.moveY = motion.y;
                this.Rotation = motion.angle+90;
                this.allowMove = true;

                this.ignoreBorder = true;
                this.isFlyingAway = true;
            }
        }

        
    }

}
// World.RegisterEntity(EntityLargeBee);




class EntityLakeLargeBee extends EntityLargeBee
{
	constructor(x, y)
	{
		super(x, y);
		
		this.name = "ENTITY.BEE.LAKE.LARGE.NAME";
		this.description = "ENTITY.BEE.LAKE.LARGE.DESCRIPTION";

		this.MAXHP = 80;
		this.HP = this.MAXHP;
		this.AD = 10;
		this.ATTACK_SPEED = 1.5;
        this.ATTACK_RANGE = 1500;
		this.FOLLOW_RANGE = 750;
        this.BULLET_SPEED = 1800;
		this.SPD = 150;

        this.aggressive = false;
        this.isAggressive = false;
        this.isAggressiveOnHurt = true;


        this.Model = new LargeBeeModel(this);
		this.setScale(2);

        this.FlyDuration = 7 * Main.FPS;

        this.DropHoneyChance = .1;
		this.LootTable = new LootTable([
            new LootTableItemData('NecklaceRegeneration', 10, 1, 1)
        ]);
    }
}
World.RegisterEntity(EntityLakeLargeBee);





class EntityLakeLittleBee extends EntityLargeBee
{
	constructor(x, y)
	{
		super(x, y);
		
		this.name = "ENTITY.BEE.LAKE.LITTLE.NAME";
		this.description = "ENTITY.BEE.LAKE.LITTLE.DESCRIPTION";

		this.MAXHP = 40;
		this.HP = this.MAXHP;
		this.AD = 5;
		this.ATTACK_SPEED = 1.5;
        this.ATTACK_RANGE = 1500;
		this.FOLLOW_RANGE = 750;
        this.BULLET_SPEED = 1800;
		this.SPD = 150;

        this.aggressive = false;
        this.isAggressive = false;
        this.isAggressiveOnHurt = true;


        this.Model = new LargeBeeModel(this, 'entity.bubblebee.small.', true);
		this.setScale(1);

        this.FlyDuration = 5 * Main.FPS;

        this.DropHoneyChance = .1;
		this.LootTable = new LootTable([
            // new LootTableItemData('TreasureOrbAquamantula', 100, 1, 1)
        ]);
    }
}
World.RegisterEntity(EntityLakeLittleBee);










class EntityHoneyChunk extends Entity
{
	constructor(x, y)
	{
		super(x, y);
		
		this.name = "ENTITY.HONEY.CHUNK.NAME";
		this.description = "ENTITY.HONEY.CHUNK.DESCRIPTION";
        this.Texture = 'entity.honey.chunk.1';

		this.MAXHP = 10;
		this.HP = this.MAXHP;
		this.AD = 0;

		this.setScale(1);

		this.LootTable = new LootTable([
            new LootTableItemData('HoneyPiece', 10, 1, 2)
        ]);

        this.mustBeKilled = false;

        this.animationDuration = 30;

        this.EntitiesToSummon = [EntityLakeLittleBee];
        this.MaxEntities = 5;
        this.MinEntities = 3;

        this.summonDelay = MathHelper.randomInRange(30, 50) * Main.FPS;
        this.timeToSummon = this.summonDelay;
    }

    onPlayerCollision(p)
    {
        p.Heal(5, true);
        ApplyEffect(p, 'Slow', 90, .5);

        this.dropLoot = false;
        this.Kill();
    }

    Update()
    {
        super.Update();

        if(this.ageInTicks <= this.animationDuration)
        {
            var p = this.ageInTicks/this.animationDuration;
            this.Scale = this.baseScale * p;
        }

		if(!World.Location.isCleared)
		{
			if(this.ageInTicks == this.timeToSummon)
			{
				this.SummonEntities();
				this.timeToSummon = this.ageInTicks + this.summonDelay;
			}
		}
    }

    SummonEntities()
    {
        var entities = MathHelper.randomInRange(this.MinEntities, this.MaxEntities);
        for(var i = 0; i < entities; i++)
        {
            var pos = MathHelper.getRandomPointInRange(World.CenterPoint, World.Radius-50, World.Radius - 60);

            var eTypeNum = MathHelper.randomInRange(0, this.EntitiesToSummon.length-1);
            var entity = new this.EntitiesToSummon[eTypeNum](pos.x, pos.y);
                entity.interestedIn = this;

            World.AddEntity(entity);
        }
    }
}
World.RegisterEntity(EntityHoneyChunk);




class EntityHoneyDrop extends Entity
{
	constructor(x, y)
	{
		super(x, y);
		
		this.name = "ENTITY.HONEY.DROP.NAME";
		this.description = "ENTITY.HONEY.DROP.DESCRIPTION";
        this.Texture = 'entity.honey.drop';

		this.MAXHP = 10;
		this.HP = this.MAXHP;
		this.AD = 0;

        this.isHurtAble = false;

        this.mustBeKilled = false;
        this.animationDuration = .5 * Main.FPS;
        this.tY = -500;

		this.setScale(1);
    }

    onKill()
    {
		var e = new EntityHoneyChunk(this.x, this.y);
		for(var i in this.honeyStats)
		{
			e[i] = this.honeyStats[i];
		}
        World.AddEntity(e, false);
    }

    RenderTexture(context)
    {
        var p = this.ageInTicks/this.animationDuration;
        if(p > 1) return this.Kill();

        var texture = TextureManager.Get(this.Texture);
        var x = this.x - Camera.xView;
        var y = this.y - Camera.yView + (this.tY * (1-p));

        var width = this.width;
        var height = this.height;
        var scale = this.Scale;
        var alpha = this.Transparency * (p * 5);

        Graphic.DrawRotatedAnimatedImage(context, 0, 1, 'X', 
            texture, x, y, width, height, scale, 0, alpha);
    }
}
World.RegisterEntity(EntityHoneyDrop);











class EntityHoneycomb extends Entity
{
	constructor(x, y, type = 5)
	{
		super(x, y);
		
		this.type = type;
		this.name = "ENTITY.HONEYCOMB.NAME";
		this.Texture = "entity.honey.comb."+type;

		this.MAXHP = 2**(3+type);
		this.HP = this.MAXHP;
		this.AD = 20;
		this.SPD = 500;

		this.FOLLOW_RANGE = 1000;
		this.Tier = 0;
		

		this.AI = new AI();
		this.AI.Apply(new AI_Walk());
        this.AI.Apply(new AI_AttackMelee(Player, 0, 1, {onCollisionEffects: [['Slow', 90, .5, false]]}));
		this.AI.Apply(new AI_Bounce(this, MathHelper.randomInRange(0, 360)));


		var rotationTime = 2;
        this.rotationSpeed = 360 / (rotationTime * Main.FPS);
        this.baseRotationSpeed = this.rotationSpeed;

		this.allowRotationChange = false;

		this.dropOxygen = false;
		this.dropLoot = false;

		this.LootTable = new LootTable([
			new LootTableItemData('HoneyPiece', 25, 1, 1)
		]);
		this.setScale(4);

		if(this.type == 1) 
		{
			this.dropOxygen = true;
			this.dropLoot = true;
		}

		var hs = .9;
		switch(type)
		{
			case 3: hs = .5
				break;

			case 2: hs = .4
				break;

			case 1: hs = .25
				break;
		}

		this.HitBox.Scale = hs;
	}

	onKill()
	{

		if(this.type <= 1) return;

		var angle = MathHelper.getAngle2(this, World.Player)+90;

		var e = new EntityHoneycomb(this.x, this.y, this.type-1);
			e.AI.Apply(new AI_Bounce(e, angle));
			e.level = this.level;
		World.AddEntity(e);

		var e2 = new EntityHoneycomb(this.x, this.y, this.type-1);
			e2.AI.Apply(new AI_Bounce(e2, angle-180));
			e2.level = this.level;
		World.AddEntity(e2);
	}

	Update()
	{
		super.Update();

		if(this.ageInTicks%3 == 0)
		{
			var scale = .5 * MathHelper.randomInRange(75, 125) / 100 * this.Scale;
			var r = (this.Width / 2 * this.Scale);
			var x = this.x + MathHelper.randomInRange(-r, r);
			var y = this.y + MathHelper.randomInRange(-r, r);
			var spd = 50;

			Particle.Summon('effect.honey_bubble', x, y, x, y-500, scale, spd, 1, 20, 
			{
				liveTime: 50, 
				// owner: owner,
				baseScale: scale,
				center: true,
				globalAlpha: 0.25,
				// RENDER_LAYER: Graphic.Layer.Particle0,
				onUpdate: function(){this.Scale = (this.baseScale * (this.ageInTicks / this.liveTime))}
			});
		}
	}

	RenderTexture(context)
	{
		this.Rotation = (this.Rotation + this.rotationSpeed)%360;

        super.RenderTexture(context);
	}
}
World.RegisterEntity(EntityHoneycomb);





















class LargeBeeModel extends ModelBase
{
	constructor(owner, textureFamily = 'entity.bubblebee.', autoFitTexture = false)
	{
		super(owner, textureFamily, autoFitTexture);
		this.Scale = 0.125;
		
        this.Width = 1024;
		this.Height = 700;


		var base = new Part(256, 256, 100);
		base.SetTexture("base", 256, 256);
		base.SetTextureRender(35, 1);
		base.SetRotation(0, 128, 120);

		var tail_pivot = new Part(20, 100, 100);
		tail_pivot.SetTexture("hand", 20, 100);
		tail_pivot.SetTextureRender(0, 1);
		tail_pivot.SetRotation(0, 10, 10);
		tail_pivot.visible = false;

		var wing_pivot_left_1 = new Part(20, 65, 100);
		wing_pivot_left_1.SetTexture("hand", 20, 100);
		wing_pivot_left_1.SetTextureRender(14, 13);
		wing_pivot_left_1.SetRotation(60, 10, 10);
		wing_pivot_left_1.visible = false;

		var wing_pivot_right_1 = new Part(20, 65, 100);
		wing_pivot_right_1.SetTexture("hand", 20, 100);
		wing_pivot_right_1.SetTextureRender(15, 14);
		wing_pivot_right_1.SetRotation(-60, 10, 10);
		wing_pivot_right_1.visible = false;

		var wing_right_1 = new Part(380, 230, 100);
		wing_right_1.SetTexture("wing", 380, 230);
		wing_right_1.SetTextureRender(40, 17);
		wing_right_1.SetRotation(60, 10, 120);
		wing_right_1.Axis = "x";

		var wing_left_2 = new Part(380, 230, 100);
		wing_left_2.SetTexture("wing", 380, 230);
		wing_left_2.SetTextureRender(39, 20, 0, 0, 0, 0, -1, 1);
		wing_left_2.SetRotation(-60, 10, 120);
		wing_left_2.Axis = "x";

		var abdomen = new Part(256, 330, 100);
		abdomen.SetTexture("abdomen", 256, 330);
		abdomen.SetTextureRender(38, 10);
		abdomen.SetRotation(0, 128, 10);

		var antennae_pivot_right = new Part(20, 120, 100);
		antennae_pivot_right.SetTexture("hand", 20, 100);
		antennae_pivot_right.SetTextureRender(1, 7);
		antennae_pivot_right.SetRotation(-170, 10, 10);
		antennae_pivot_right.visible = false;

		var antennae_pivot_left = new Part(20, 120, 100);
		antennae_pivot_left.SetTexture("hand", 20, 100);
		antennae_pivot_left.SetTextureRender(2, 8);
		antennae_pivot_left.SetRotation(-190, 10, 10);
		antennae_pivot_left.visible = false;

		var antennae_right = new Part(30, 140, 100);
		antennae_right.SetTexture("antennae", 30, 140);
		antennae_right.SetTextureRender(36, 9, 0, 0, 0, 0, -1, -1);
		antennae_right.SetRotation(10, 8, 6);

		var antennae_left = new Part(30, 140, 100);
		antennae_left.SetTexture("antennae", 30, 140);
		antennae_left.SetTextureRender(37, 9, 0, 0, 0, 0, 1, -1);
		antennae_left.SetRotation(-10, 8, 6);

		var leg_pivot_1 = new Part(20, 64, 100);
		leg_pivot_1.SetTexture("hand", 20, 100);
		leg_pivot_1.SetTextureRender(3, 11);
		leg_pivot_1.SetRotation(-120, 10, 10);
		leg_pivot_1.visible = false;

		var leg_pivot_2 = new Part(20, 90, 100);
		leg_pivot_2.SetTexture("hand", 20, 100);
		leg_pivot_2.SetTextureRender(4, 12);
		leg_pivot_2.SetRotation(-70, 10, 10);
		leg_pivot_2.visible = false;

		var leg_pivot_3 = new Part(20, 110, 100);
		leg_pivot_3.SetTexture("hand", 20, 100);
		leg_pivot_3.SetTextureRender(5, 13);
		leg_pivot_3.SetRotation(-40, 10, 10);
		leg_pivot_3.visible = false;

		var leg_pivot_4 = new Part(20, 110, 100);
		leg_pivot_4.SetTexture("hand", 20, 100);
		leg_pivot_4.SetTextureRender(6, 14);
		leg_pivot_4.SetRotation(40, 10, 10);
		leg_pivot_4.visible = false;

		var leg_pivot_5 = new Part(20, 90, 100);
		leg_pivot_5.SetTexture("hand", 20, 100);
		leg_pivot_5.SetTextureRender(7, 15);
		leg_pivot_5.SetRotation(70, 10, 10);
		leg_pivot_5.visible = false;

		var leg_pivot_6 = new Part(20, 64, 100);
		leg_pivot_6.SetTexture("hand", 20, 100);
		leg_pivot_6.SetTextureRender(8, 16);
		leg_pivot_6.SetRotation(120, 10, 10);
		leg_pivot_6.visible = false;

		var leg_1 = new Part(30, 70, 100);
		leg_1.SetTexture("leg", 30, 70);
		leg_1.SetTextureRender(12, 17, 0, 0, 0, 0, 1, -1);
		leg_1.SetRotation(65, 15, 10);

		var leg_2 = new Part(30, 70, 100);
		leg_2.SetTexture("leg", 30, 70);
		leg_2.SetTextureRender(11, 18, 0, 0, 0, 0, 1, -1);
		leg_2.SetRotation(-96, 15, 10);

		var leg_3 = new Part(30, 70, 100);
		leg_3.SetTexture("leg", 30, 70);
		leg_3.SetTextureRender(10, 19, 0, 0, 0, 0, 1, -1);
		leg_3.SetRotation(-220, 15, 10);

		var leg_4 = new Part(30, 70, 100);
		leg_4.SetTexture("leg.end", 30, 70);
		leg_4.SetTextureRender(9, 20, 0, 0, 0, 0, -1, -1);
		leg_4.SetRotation(-30, 15, 10);

		var leg_5 = new Part(30, 70, 100);
		leg_5.SetTexture("leg", 30, 70);
		leg_5.SetTextureRender(16, 21, 0, 0, 0, 0, 1, -1);
		leg_5.SetRotation(33, 15, 10);

		var leg_6 = new Part(30, 70, 100);
		leg_6.SetTexture("leg", 30, 70);
		leg_6.SetTextureRender(15, 22, 0, 0, 0, 0, 1, -1);
		leg_6.SetRotation(-30, 15, 10);

		var leg_7 = new Part(30, 70, 100);
		leg_7.SetTexture("leg", 30, 70);
		leg_7.SetTextureRender(14, 23, 0, 0, 0, 0, 1, -1);
		leg_7.SetRotation(20, 15, 10);

		var leg_8 = new Part(30, 70, 100);
		leg_8.SetTexture("leg.end", 30, 70);
		leg_8.SetTextureRender(13, 24, 0, 0, 0, 0, -1, -1);
		leg_8.SetRotation(20, 15, 10);

		var leg_9 = new Part(40, 95, 100);
		leg_9.SetTexture("leg", 30, 70);
		leg_9.SetTextureRender(20, 25, 0, 0, 0, 0, 1, -1);
		leg_9.SetRotation(0, 20, 10);

		var leg_10 = new Part(40, 95, 100);
		leg_10.SetTexture("leg", 30, 70);
		leg_10.SetTextureRender(19, 26, 0, 0, 0, 0, 1, -1);
		leg_10.SetRotation(30, 20, 10);

		var leg_11 = new Part(40, 95, 100);
		leg_11.SetTexture("leg", 30, 70);
		leg_11.SetTextureRender(18, 27, 0, 0, 0, 0, 1, -1);
		leg_11.SetRotation(-20, 20, 10);

		var leg_12 = new Part(40, 95, 100);
		leg_12.SetTexture("leg.end", 30, 70);
		leg_12.SetTextureRender(17, 28, 0, 0, 0, 0, 1, -1);
		leg_12.SetRotation(20, 20, 10);

		var leg_13 = new Part(40, 95, 100);
		leg_13.SetTexture("leg", 30, 70);
		leg_13.SetTextureRender(24, 29, 0, 0, 0, 0, 1, -1);
		leg_13.SetRotation(4, 20, 10);

		var leg_14 = new Part(40, 95, 100);
		leg_14.SetTexture("leg", 30, 70);
		leg_14.SetTextureRender(23, 30, 0, 0, 0, 0, 1, -1);
		leg_14.SetRotation(-30, 20, 10);

		var leg_15 = new Part(40, 95, 100);
		leg_15.SetTexture("leg", 30, 70);
		leg_15.SetTextureRender(22, 31, 0, 0, 0, 0, 1, -1);
		leg_15.SetRotation(20, 20, 10);

		var leg_16 = new Part(40, 95, 100);
		leg_16.SetTexture("leg.end", 30, 70);
		leg_16.SetTextureRender(21, 32, 0, 0, 0, 0, -1, -1);
		leg_16.SetRotation(-20, 20, 10);

		var leg_17 = new Part(30, 70, 100);
		leg_17.SetTexture("leg", 30, 70);
		leg_17.SetTextureRender(28, 33, 0, 0, 0, 0, 1, -1);
		leg_17.SetRotation(-33, 15, 10);

		var leg_18 = new Part(30, 70, 100);
		leg_18.SetTexture("leg", 30, 70);
		leg_18.SetTextureRender(27, 34, 0, 0, 0, 0, 1, -1);
		leg_18.SetRotation(30, 15, 10);

		var leg_19 = new Part(30, 70, 100);
		leg_19.SetTexture("leg", 30, 70);
		leg_19.SetTextureRender(26, 35, 0, 0, 0, 0, 1, -1);
		leg_19.SetRotation(-20, 15, 10);

		var leg_20 = new Part(30, 70, 100);
		leg_20.SetTexture("leg.end", 30, 70);
		leg_20.SetTextureRender(25, 36, 0, 0, 0, 0, 1, -1);
		leg_20.SetRotation(-20, 15, 10);

		var leg_21 = new Part(30, 70, 100);
		leg_21.SetTexture("leg", 30, 70);
		leg_21.SetTextureRender(32, 37, 0, 0, 0, 0, 1, -1);
		leg_21.SetRotation(-64, 15, 10);

		var leg_22 = new Part(30, 70, 100);
		leg_22.SetTexture("leg", 30, 70);
		leg_22.SetTextureRender(31, 38, 0, 0, 0, 0, 1, -1);
		leg_22.SetRotation(-256, 15, 10);

		var leg_23 = new Part(30, 70, 100);
		leg_23.SetTexture("leg", 30, 70);
		leg_23.SetTextureRender(30, 39, 0, 0, 0, 0, 1, -1);
		leg_23.SetRotation(222, 15, 10);

		var leg_24 = new Part(30, 70, 100);
		leg_24.SetTexture("leg.end", 30, 70);
		leg_24.SetTextureRender(29, 40, 0, 0, 0, 0, 1, -1);
		leg_24.SetRotation(30, 15, 10);

        var honey_pivot = new Part(20, 100, 100);
		honey_pivot.SetTexture("hand", 20, 100);
		honey_pivot.SetTextureRender(33, -1);
		honey_pivot.SetRotation(-180, 10, 10);
		honey_pivot.visible = false;

		var honey = new Part(128, 128, 100);
		honey.SetTexture("item.honey.piece", 128, 128, false);
		honey.SetTextureRender(34, -1);
		honey.SetRotation(0, 64, 10);

		base.AddChild(tail_pivot);
		base.AddChild(wing_pivot_left_1);
		base.AddChild(wing_pivot_right_1);
		wing_pivot_right_1.AddChild(wing_right_1);
		wing_pivot_left_1.AddChild(wing_left_2);
		tail_pivot.AddChild(abdomen);
		base.AddChild(antennae_pivot_right);
		base.AddChild(antennae_pivot_left);
		antennae_pivot_right.AddChild(antennae_right);
		antennae_pivot_left.AddChild(antennae_left);
		base.AddChild(leg_pivot_1);
		base.AddChild(leg_pivot_2);
		base.AddChild(leg_pivot_3);
		base.AddChild(leg_pivot_4);
		base.AddChild(leg_pivot_5);
		base.AddChild(leg_pivot_6);
		leg_pivot_1.AddChild(leg_1);
		leg_1.AddChild(leg_2);
		leg_2.AddChild(leg_3);
		leg_3.AddChild(leg_4);
		leg_pivot_2.AddChild(leg_5);
		leg_5.AddChild(leg_6);
		leg_6.AddChild(leg_7);
		leg_7.AddChild(leg_8);
		leg_pivot_3.AddChild(leg_9);
		leg_9.AddChild(leg_10);
		leg_10.AddChild(leg_11);
		leg_11.AddChild(leg_12);
		leg_pivot_4.AddChild(leg_13);
		leg_13.AddChild(leg_14);
		leg_14.AddChild(leg_15);
		leg_15.AddChild(leg_16);
		leg_pivot_5.AddChild(leg_17);
		leg_17.AddChild(leg_18);
		leg_18.AddChild(leg_19);
		leg_19.AddChild(leg_20);
		leg_pivot_6.AddChild(leg_21);
		leg_21.AddChild(leg_22);
		leg_22.AddChild(leg_23);
		leg_23.AddChild(leg_24);
		base.AddChild(honey_pivot);
		honey_pivot.AddChild(honey);

		this.Parts.base = base;
		this.Parts.tail_pivot = tail_pivot;
		this.Parts.wing_pivot_left_1 = wing_pivot_left_1;
		this.Parts.wing_pivot_right_1 = wing_pivot_right_1;
		this.Parts.wing_right_1 = wing_right_1;
		this.Parts.wing_left_2 = wing_left_2;
		this.Parts.abdomen = abdomen;
		this.Parts.antennae_pivot_right = antennae_pivot_right;
		this.Parts.antennae_pivot_left = antennae_pivot_left;
		this.Parts.antennae_right = antennae_right;
		this.Parts.antennae_left = antennae_left;
		this.Parts.leg_pivot_1 = leg_pivot_1;
		this.Parts.leg_pivot_2 = leg_pivot_2;
		this.Parts.leg_pivot_3 = leg_pivot_3;
		this.Parts.leg_pivot_4 = leg_pivot_4;
		this.Parts.leg_pivot_5 = leg_pivot_5;
		this.Parts.leg_pivot_6 = leg_pivot_6;
		this.Parts.leg_1 = leg_1;
		this.Parts.leg_2 = leg_2;
		this.Parts.leg_3 = leg_3;
		this.Parts.leg_4 = leg_4;
		this.Parts.leg_5 = leg_5;
		this.Parts.leg_6 = leg_6;
		this.Parts.leg_7 = leg_7;
		this.Parts.leg_8 = leg_8;
		this.Parts.leg_9 = leg_9;
		this.Parts.leg_10 = leg_10;
		this.Parts.leg_11 = leg_11;
		this.Parts.leg_12 = leg_12;
		this.Parts.leg_13 = leg_13;
		this.Parts.leg_14 = leg_14;
		this.Parts.leg_15 = leg_15;
		this.Parts.leg_16 = leg_16;
		this.Parts.leg_17 = leg_17;
		this.Parts.leg_18 = leg_18;
		this.Parts.leg_19 = leg_19;
		this.Parts.leg_20 = leg_20;
		this.Parts.leg_21 = leg_21;
		this.Parts.leg_22 = leg_22;
		this.Parts.leg_23 = leg_23;
		this.Parts.leg_24 = leg_24;
		this.Parts.honey_pivot = honey_pivot;
		this.Parts.honey = honey;

		this.ApplyModelAnimation(LargeBeeFlyAnimation);
		this.ApplyModelAnimation(LargeBeeWalkAnimation);
		this.ApplyModelAnimation(LargeBeeWalkPosAnimation);
		this.ApplyModelAnimation(LargeBeeAbdomenAnimation);
		this.ApplyModelAnimation(LargeBeeAntennaeAnimation);
	}

	Update()
	{
		super.Update();

        this.Parts.honey.visible = this.Owner.gotChunk ?? false;
	}

	Render(context)
	{
		super.Render(context);
	}
}

class LargeBeeAbdomenAnimation extends AnimationBase
{
    constructor(model)
    {
        super(model);

        this.setAnimationDuration(.25 * Main.FPS);
        this.iterations = 'INFINITE';

        this.setAnimationSpacing(.45, .55);

        this.Data = 
        [
            new AnimationData('abdomen', 'Rotation', 3, -3)
        ];
    }
}

class LargeBeeAntennaeAnimation extends AnimationBase
{
    constructor(model)
    {
        super(model);

        this.setAnimationDuration(.75 * Main.FPS);
        this.iterations = 'INFINITE';

        this.setAnimationSpacing(.45, .55);

        this.Data = 
        [
            new AnimationData('antennae_right', 'Rotation', 5, 15),
            new AnimationData('antennae_left', 'Rotation', -5, -15, -1)
        ];
    }
}




class LargeBeeFlyAnimation extends AnimationBase
{
    constructor(model)
    {
        super(model);

        this.setAnimationDuration(5);
        this.iterations = 'INFINITE';

        this.setAnimationSpacing(.5, .5);

        this.triggerFunction = function(anim){return anim.Owner.isFlying;};

        this.Data = 
        [
            new AnimationData('wing_left_2', 'Rotation', -60, -60),
            new AnimationData('wing_right_1', 'Rotation', 60, 60),

            new AnimationData('wing_right_1', 'Transform.x', 100, 30, 1),
            new AnimationData('wing_left_2', 'Transform.x', 100, 30, 1),
        ];
    }
}



class LargeBeeWalkPosAnimation extends AnimationBase
{
    constructor(model)
    {
        super(model);

        this.setAnimationDuration((150 / this.Owner.SPD) * Main.FPS * 1.5);
        this.iterations = 'INFINITE';

        this.setAnimationSpacing(.5, .5);

        this.triggerFunction = function(anim){return !anim.Owner.isFlying;};

        this.Data = 
        [
            new AnimationData('wing_left_2', 'Rotation', -140, -140),
            new AnimationData('wing_right_1', 'Rotation', 140, 140),

            new AnimationData('leg_1', 'Rotation', 4, 4),
            new AnimationData('leg_2', 'Rotation', -30, -30),
            new AnimationData('leg_3', 'Rotation', 20, 20),
            new AnimationData('leg_4', 'Rotation', -30, -30),

            new AnimationData('leg_5', 'Rotation', -25, -25),
            new AnimationData('leg_6', 'Rotation', -30, -30),
            new AnimationData('leg_7', 'Rotation', -20, -20),
            new AnimationData('leg_8', 'Rotation', -20, -20),

            new AnimationData('leg_9', 'Rotation', 0, 0),
            new AnimationData('leg_10', 'Rotation', 20, 20),
            new AnimationData('leg_11', 'Rotation', -20, -20),
            new AnimationData('leg_12', 'Rotation', 20, 20),

            new AnimationData('leg_13', 'Rotation', 0, 0),
            new AnimationData('leg_14', 'Rotation', -20, -20),
            new AnimationData('leg_15', 'Rotation', 20, 20),
            new AnimationData('leg_16', 'Rotation', -20, -20),

            new AnimationData('leg_17', 'Rotation', 25, 25),
            new AnimationData('leg_18', 'Rotation', 30, 30),
            new AnimationData('leg_19', 'Rotation', 20, 20),
            new AnimationData('leg_20', 'Rotation', 20, 20),

            new AnimationData('leg_21', 'Rotation', 4, 4),
            new AnimationData('leg_22', 'Rotation', 30, 30),
            new AnimationData('leg_23', 'Rotation', -20, -20),
            new AnimationData('leg_24', 'Rotation', 30, 30)
        ];
    }
}


class LargeBeeWalkAnimation extends AnimationBase
{
    constructor(model)
    {
        super(model);

        this.setAnimationDuration((150 / this.Owner.SPD) * Main.FPS * 1.5);
        this.iterations = 'INFINITE';

        this.setAnimationSpacing(.5, .5);

        this.triggerFunction = function(anim){return anim.Owner.isMoving() && !anim.Owner.isFlying;};

        this.Data = 
        [
            new AnimationData('leg_1', 'Transform.y', 100, 75, 1),
            new AnimationData('leg_2', 'Transform.y', 100, 75, 1),
            new AnimationData('leg_3', 'Transform.y', 100, 75, 1),
            new AnimationData('leg_4', 'Transform.y', 100, 75, 1),

            new AnimationData('leg_5', 'Transform.y', 100, 75, -1),
            new AnimationData('leg_6', 'Transform.y', 100, 75, -1),
            new AnimationData('leg_7', 'Transform.y', 100, 75, -1),
            new AnimationData('leg_8', 'Transform.y', 100, 75, -1),

            new AnimationData('leg_9', 'Transform.y', 100, 75, 1),
            new AnimationData('leg_10', 'Transform.y', 100, 75, 1),
            new AnimationData('leg_11', 'Transform.y', 100, 75, 1),
            new AnimationData('leg_12', 'Transform.y', 100, 75, 1),

            new AnimationData('leg_13', 'Transform.y', 100, 75, -1),
            new AnimationData('leg_14', 'Transform.y', 100, 75, -1),
            new AnimationData('leg_15', 'Transform.y', 100, 75, -1),
            new AnimationData('leg_16', 'Transform.y', 100, 75, -1),

            new AnimationData('leg_17', 'Transform.y', 100, 75, 1),
            new AnimationData('leg_18', 'Transform.y', 100, 75, 1),
            new AnimationData('leg_19', 'Transform.y', 100, 75, 1),
            new AnimationData('leg_20', 'Transform.y', 100, 75, 1),

            new AnimationData('leg_21', 'Transform.y', 100, 75, -1),
            new AnimationData('leg_22', 'Transform.y', 100, 75, -1),
            new AnimationData('leg_23', 'Transform.y', 100, 75, -1),
            new AnimationData('leg_24', 'Transform.y', 100, 75, -1)
        ];
    }
}





class EntityLaserTurret extends EntityTurret
{
	constructor(x, y)
	{
		super(x, y);

		this.BULLET_SPEED = 1000;
		this.AD = 2;
		this.BULLET_SERIES = 500;
		this.ATTACK_SPEED = 0.1;
		this.ATTACK_RANGE = 1000;
		this.MAXHP = 200;
		this.HP = this.MAXHP;
		this.Texture = "laser_turret_head";
		this.isAggressive = true;
		
		this.slow = 70 + (this.level * 5);
		if(this.slow > 90)
		{
			this.slow = 90;
		}
		
		var stats = 
		{
			spd: this.BULLET_SPEED,
			Texture: "laser_part",
			Scale: 2.4,
			onPlayerCollision: function(player)
			{
				if( (player.isHurtAble) && (player !== this.source))
				{
					player.Hurt(this.damage, this.source);
					this.damage = 0;
				}
			}
		};

		this.AI.Apply(new AI_AttackRange(World.Player, stats));
		this.AI.Apply(new AI_Observe(World.Player));
		
		this.isAggressiveOnHurt = true;
		this.setScale(2);
	}
}
World.RegisterEntity(EntityLaserTurret);class EntityShadow extends Entity
{
	constructor(x, y, owner, data = {})
	{
		super(x, y);
		this.Owner = owner;
		this.Texture = 'entity.shadow';

		this.MAXHP = 1;
		this.HP = this.MAXHP;
        this.isHurtAble = false;

		this.knockBackResistance = 1;
		this.Immunity.ALL = true;
		this.hideOnRadar = true;
        this.Transparency = .5;

        this.AI.Apply(new AI_Walk());

        for(var i in data) this[i] = data[i];
	}

	Update()
	{
		super.Update();

		if(!this.Owner.isAlive) this.Kill();
	}
}
World.RegisterEntity(EntityShadow);
class EntitySpider extends Entity
{
	constructor(x, y)
	{
		super(x, y);
		
		this.name = "Spider";
		this.Title = "";

		this.Texture = "entity.spider.base";
        this.TextureLegLeft = 'entity.spider.leg.left';
        this.TextureLegRight = 'entity.spider.leg.right';
        this.TextureFangLeft = 'entity.spider.fang.left';
        this.TextureFangRight = 'entity.spider.fang.right';
        this.TextureBase2 = 'entity.spider.base.2';
        this.defaultRotation = 180;

		this.MAXHP = 50;
		this.HP = this.MAXHP;
		this.AD = 10;
		this.ATTACK_SPEED = 1.5;
        this.ATTACK_RANGE = 10000;
		this.FOLLOW_RANGE = 350;
		this.ATTACK_RANGE_MIN = this.FOLLOW_RANGE;
        this.BULLET_SPEED = 950;
		this.SPD = 800;
		
		var bulletStats = 
		{
			// Type: "BulletSoundWave",
			Scale: 1
		};

		

		this.AI.Apply(new AI_AttackMelee(Player, this.AD));
        this.AI.Apply(new AI_Follow(World.Player, true));
		this.AI.Apply(new AI_Walk());
		this.AI.Apply(new AI_Wander(true, .5, 2));
		this.AI.Apply(new AI_Observe(World.Player, this.ATTACK_RANGE, function(owner){return owner.aggressive;}));
		this.AI.Apply(new AI_AttackRange(World.Player, bulletStats));
		

		this.isAggressiveOnHurt = true;
		this.HitBox.Scale = .75;

        this.RenderTransitions =
		{
			Scale: new Transition(1, 0.95, 0.25, true, 0.02, 0.02)
		};

		this.legsAnimDuration = (150 / this.SPD) * .5;

        this.legsAnimation = new Transition(-10, 10, this.legsAnimDuration, true, 0, 0, false);
        this.tailAnim = new Transition(1, .9, .5, true, 0, 0, false);

		var bodyHitBox = new HitBox();
			bodyHitBox.Scale = this.HitBox.Scale;
			bodyHitBox.translationY = -.95;

		this.advancedHitBox.push(bodyHitBox);

		// this.setScale(1);
	}

    RenderTexture(context)
	{
        var base = TextureManager.Get(this.Texture);
        var base2 = TextureManager.Get(this.TextureBase2);
		var legLeft = TextureManager.Get(this.TextureLegLeft);
		var legRight = TextureManager.Get(this.TextureLegRight);
        var fangLeft = TextureManager.Get(this.TextureFangLeft);
        var fangRight = TextureManager.Get(this.TextureFangRight);


        var ratio = this.width / 512;

        var legs = {width: 100, height: 300, length: 190 * ratio, tY: 60 * ratio / 2, textureSpaceY: 15 * ratio, angles: 
        [
            -50, -75, -105, -130
        ], 
        baseRotation:
        [
            160, 140, 35, 15,
            -15, -35, -140, -160
        ]};
        var fangs = {width: 50, height: 100, angles: [-165, -195], tY: 10 * ratio, textureSpaceY: 3 * ratio};


        var x = this.x - Camera.xView;
        var y = this.y - Camera.yView;
        var width = this.width;
        var height = this.height;
        var rotation = this.Rotation;
        var alpha = this.Transparency;
        var scale = this.Scale;

        var legAnim = this.legsAnimation.Update();
        var tailHeight = this.tailAnim.Update();

        //render base
        Graphic.DrawRotatedImage(context, base, x, y, width, height, scale, rotation, alpha);
        Graphic.DrawRotatedImage(context, base2, x, y, width, height * tailHeight, scale, rotation, alpha, 0, (height * .43 + (height * tailHeight)) / 2);


        //render legs
        for(var i = 0; i < 8; i++)
		{
            var texture = legRight;
            if(i == 2 || i == 3 || i == 6 || i == 7) texture = legLeft;

            var rotAnimDir = (i%2 == 0) ? 1 : -1;

            var angle = (i < 4) ? 180 : 0;
            angle += (i < 4) ? legs.angles[i] : legs.angles[i-4];

            var endPoints = [
                x,
                y + legs.length * scale
            ];
            var pos = MathHelper.RotatePoint([x, y], rotation + angle, endPoints);

			// var rotation = weaponHandPose.rotation ?? hand[5] ?? 0;

            var l_width = legs.width * ratio;
            var l_height = legs.height * ratio;

			context.save();
			context.translate(pos.x, pos.y);
			context.rotate((rotation + legs.baseRotation[i] + legAnim * rotAnimDir) * Math.PI/180);
			context.globalAlpha = alpha;
			context.drawImage(
				texture, 0, 0, texture.width, texture.height,
				-((l_width / 2)) * scale, -(legs.tY + legs.textureSpaceY) * scale,
				(l_width * scale), (l_height * scale)
			);
			context.restore();
		}



        //render fangs
        for(var i = 0; i < 2; i++)
		{
            var texture = fangLeft;
            var rotAnimDir = -1;
            if(i == 1) 
            {
                texture = fangRight;
                rotAnimDir = 1;
            }

            var angle = 180 + fangs.angles[i];

            var endPoints = [
                x,
                y + legs.length * scale * .9
            ];
            var pos = MathHelper.RotatePoint([x, y], rotation + angle, endPoints);

			// var rotation = weaponHandPose.rotation ?? hand[5] ?? 0;

            var f_width = fangs.width * ratio;
            var f_height = fangs.height * ratio;

			context.save();
			context.translate(pos.x, pos.y);
			context.rotate((rotation + legAnim * rotAnimDir) * Math.PI/180);
			context.globalAlpha = alpha;
			context.drawImage(
				texture, 0, 0, texture.width, texture.height,
				-((f_width / 2)) * scale, -(fangs.tY + fangs.textureSpaceY) * scale,
				(f_width * scale), (f_height * scale)
			);
			context.restore();
		}

        return;
	}
}
World.RegisterEntity(EntitySpider);











class EntityLittleLakeSpider extends EntitySpider
{
	constructor(x, y)
	{
		super(x, y);
		
		this.name = "ENTITY.SPIDER.LITTLE.LAKE.NAME";
		this.description = "ENTITY.SPIDER.LITTLE.LAKE.DESCRIPTION";
		this.Title = "";

		this.MAXHP = 30;
		this.HP = this.MAXHP;
		this.AD = 10;
		this.ATTACK_SPEED = 1.5;
        this.ATTACK_RANGE = 10000;
		this.FOLLOW_RANGE = 350;
		this.ATTACK_RANGE_MIN = this.FOLLOW_RANGE;
        this.BULLET_SPEED = 950;
		this.SPD = 800;
		
		var bulletStats = 
		{
			// Type: "BulletSoundWave",
			Scale: 1
		};

		this.AI = new AI();

		this.AI.Apply(new AI_AttackMelee(Player, this.AD));
        this.AI.Apply(new AI_Follow(World.Player, true));
		this.AI.Apply(new AI_Walk());
		this.AI.Apply(new AI_Wander(true, .5, 2));
		this.AI.Apply(new AI_Observe(World.Player, this.ATTACK_RANGE, function(owner){return owner.aggressive;}));
		this.AI.Apply(new AI_AttackRange(World.Player, bulletStats));
		

		this.LootTable = new LootTable([
			new LootTableItemData("EnchantCrystalAD", 5, 1, 1)
		]);


		this.timeToGrow = MathHelper.randomInRange(60, 120) * Main.FPS;
		this.minScale = .75;
		this.maxScale = 1.4;

		this.setScale(.75);
	}

	Update()
	{
		super.Update();

		var growProgress = this.ageInTicks / this.timeToGrow;
		var scaleStep = this.maxScale - this.minScale;
		var new_scale = Math.round((this.minScale + (scaleStep * growProgress)) * 10) / 10;

		if(this.baseScale < new_scale) this.setScale(new_scale);

		if(growProgress >= 1) this.Grow();
	}

	Grow()
	{
		console.log('grow');
		var largeVersion = new EntityLakeSpider();
			largeVersion.x = this.x;
			largeVersion.y = this.y;
			largeVersion.Rotation = this.Rotation;

		World.AddEntity(largeVersion);
		World.Kill(this);
	}
}
World.RegisterEntity(EntityLittleLakeSpider);






class EntityLakeSpider extends EntitySpider
{
	constructor(x, y)
	{
		super(x, y);

		this.TextureBase2 = 'entity.spider.base.2.medium';
		
		this.name = "ENTITY.SPIDER.LAKE.NAME";
		this.description = "ENTITY.SPIDER.LAKE.DESCRIPTION";
		this.Title = "";


		this.Tier = 1;

		this.MAXHP = 75;
		this.HP = this.MAXHP;
		this.AD = 15;
		this.ATTACK_SPEED = 1.5;
        this.ATTACK_RANGE = 10000;
		this.FOLLOW_RANGE = 350;
		this.ATTACK_RANGE_MIN = this.FOLLOW_RANGE;
        this.BULLET_SPEED = 950;
		this.SPD = 700;
		
		var bulletStats = 
		{
			// Type: "BulletSoundWave",
			Scale: 1
		};

		this.AI = new AI();

		this.AI.Apply(new AI_AttackMelee(Player, this.AD));
        this.AI.Apply(new AI_Follow(World.Player, true));
		this.AI.Apply(new AI_Walk());
		this.AI.Apply(new AI_Wander(true, 2, 4));
		this.AI.Apply(new AI_Observe(World.Player, this.ATTACK_RANGE, function(owner){return owner.aggressive;}));
		this.AI.Apply(new AI_AttackRange(World.Player, bulletStats));

		this.AI.Apply(new AI_LayEgg(10, 30, 5, 'EntityLakeEgg'));
		

		this.LootTable = new LootTable([
			new LootTableItemData("EnchantCrystalDEF", 5, 1, 1)
		]);

		this.setScale(1.5);

		this.isLayingEgg = false;
	}

	Update()
	{
		super.Update();

		if(this.isLayingEgg)
		{
			this.allowMove = false;
			this.allowRotationChange = false;
			this.Rotation = 0;
			this.aggressive = false;
		}
		else
		{
			this.allowMove = true;
			this.allowRotationChange = true;
		}
	}
}
World.RegisterEntity(EntityLakeSpider);


class EntityLakeEgg extends EntityEgg
{
	constructor(x, y, owner, stats = {})
	{
		super(x, y, owner, stats);
		
		this.name = "Lake Egg";
		this.Title = "";

		this.webTexture = 'entity.spider.web';

		this.MAXHP = 150;
		this.HP = this.MAXHP;


		var entityType = stats.entityType ?? 'EntityLittleLakeSpider';
		var entityCount = stats.entityCount ?? MathHelper.randomInRange(1, 4);

		var entities = entityCount
		for(var i = 0; i < entities; i++)
		{
			this.contains[i] = entityType;
		}
	}

	RenderTexture(context)
	{
		var webTexture = TextureManager.Get(this.webTexture);

		var x = this.x - Camera.xView;
        var y = this.y - Camera.yView;
        var width = this.width;
        var height = this.height;
        var rotation = 0;
        var alpha = this.Transparency;
        var scale = this.Scale * 2;

        Graphic.DrawRotatedImage(context, webTexture, x, y, width, height, scale, rotation, alpha);

		super.RenderTexture(context);
	}
}
World.RegisterEntity(EntityLakeEgg);















class EntityDashingLakeSpider extends EntitySpider
{
	constructor(x, y)
	{
		super(x, y);

		this.TextureBase2 = 'entity.spider.base.2.dash';
		this.Texture = 'entity.spider.base.dash';
		this.TextureLegLeft = 'entity.spider.leg.left.dash';
        this.TextureLegRight = 'entity.spider.leg.right.dash';
		
		this.name = "ENTITY.SPIDER.DASHING.LAKE.NAME";
		this.description = "ENTITY.SPIDER.DASHING.LAKE.DESCRIPTION";

		this.Tier = 2;

		this.MAXHP = 80;
		this.HP = this.MAXHP;
		this.AD = 15;
		this.ATTACK_SPEED = 1;
		this.FOLLOW_RANGE = 750;
		this.SPD = 650;
		
		this.AI = new AI();
		this.AI.Apply(new AI_AttackMelee(Player, this.AD, 1, {onCollisionEffects: [['Stun', 1, 1, false]], collisionEffectTrigger: function(owner){return owner.isDashing;}}));
        this.AI.Apply(new AI_Follow(World.Player, true));
		this.AI.Apply(new AI_Walk());
		this.AI.Apply(new AI_Wander(true, 2, 4));
		this.AI.Apply(new AI_Observe(World.Player, this.FOLLOW_RANGE, function(owner){return owner.isPreparingDash;}));
		this.AI.Apply(new AI_Dash(this, Player, true, 3, 6, {timeToDash: 30, targetRange: this.FOLLOW_RANGE, dashMultiplier: 4, dashDuration: 10, dashesInRow: 2, dashesInRowDelay: 30}));

		this.LootTable = new LootTable([
			new LootTableItemData("EnchantCrystalBlock", 5, 1, 1)
		]);

		this.isPreparingDash = false;

		this.setScale(1.5);
	}

	Update()
	{
		super.Update();

		if(this.isDashing) this.allowRotationChange = false;
		else this.allowRotationChange = true;

		if(this.toDashProgress >= 80)
		{
			this.allowMove = false;
			this.isPreparingDash = true;
		}
		else
		{
			this.allowMove = true;
			this.isPreparingDash = false;
		}
	}
}
World.RegisterEntity(EntityDashingLakeSpider);





class EntitySpikeBall extends Entity
{
	constructor(x, y)
	{
		super(x, y);
		
		this.AD = 20;
		this.SPD = 250;
		this.BULLET_SPEED = 450;
		this.ATTACK_SPEED = 1;
		this.MAXHP = 100;
		this.HP = this.MAXHP;
		this.FOLLOW_RANGE = 350;
		this.Texture = "spike_ball";
		

		this.AI.Apply(new AI_Follow(World.Player, true));
		this.AI.Apply(new AI_Walk());
		this.AI.Apply(new AI_Wander());
		this.AI.Apply(new AI_AttackMelee(Player, this.AD * 1.5));
		this.AI.Apply(new AI_ShotOnCircle({shotCount: 8}, null, null, function(){return false;}));
		
		this.isAggressive = true;
		
		this.onPlayerCollision = function(player)
		{
			//nie daje expa jesli wybuchnie uderzajac w gracza
			this.oxygen = 0;
			this.Kill();
		};
		
		this.onKill = function()
		{
			var stats = 
			{
				Type: "BulletSpike",
				damage: this.AD,
				Scale: 1.5,
				spd: this.BULLET_SPEED,
				hurtEntities: true
			};
			this.AI.ShotOnCircle.Shoot(this, stats);
		};

		this.setScale(1);
	}
	
	Update()
	{
		super.Update();
	}
}
World.RegisterEntity(EntitySpikeBall);class EntityTadpole extends Entity
{
	constructor(x, y)
	{
		super(x, y);
		
		this.name = "ENTITY.TADPOLE.NAME";
		this.Title = "";

        this.Texture = 'entity.tadpole.base';
        this.TextureTail = 'entity.tadpole.tail';
        this.TailFrames = 12;
        this.TailAnimation = new Transition(0, this.TailFrames -1, .25, false, 0, 0, true);

		this.MAXHP = 100;
		this.HP = this.MAXHP;
		this.AD = 10;
		this.ATTACK_SPEED = 1.5;
        this.ATTACK_RANGE = 400;
		this.FOLLOW_RANGE = 1000;
        this.BULLET_SPEED = 950;
		this.SPD = 500;

		this.isAggressiveOnHurt = true;
	

		this.AI.Apply(new AI_Follow(World.Player, true));
		this.AI.Apply(new AI_Walk());
		this.AI.Apply(new AI_Wander(true, 1, 2));
		this.AI.Apply(new AI_AttackMelee(Player, 0, 1));


        this.HitBox.Scale = .9;

		this.LootTable = new LootTable([]);

		this.RenderTransitions =
		{
			Scale: new Transition(1, 0.95, 0.25, true, 0.02, 0.02)
		};

		this.setScale(1);
	}

    RenderTexture(context)
    {
        var x = this.x - Camera.xView;
        var y = this.y - Camera.yView;
        var height = this.height;
        var width = this.width;

        var rotation = this.Rotation;
        var scale = this.Scale;
        var alpha = this.Transparency;

        var textureBase = TextureManager.Get(this.Texture);
        var baseRotation = rotation + this.TextureRotation;

        var TextureTail = TextureManager.Get(this.TextureTail);
        var frame = this.TailAnimation.Update();

        Graphic.DrawRotatedAnimatedImage(context, frame, this.TailFrames, 'X', 
            TextureTail, x, y, width, height * 2, scale, baseRotation, alpha, 0, -height * 1.37);

        Graphic.DrawRotatedImage(context, textureBase, x, y, width, height, scale, baseRotation, alpha);
    }
}



class EntityLakeTadpole extends EntityTadpole
{
    constructor(x, y)
    {
        super(x, y);

        this.name = "ENTITY.TADPOLE.LAKE.NAME";
        this.Texture = 'entity.tadpole.blue.base';
        this.TextureTail = 'entity.tadpole.blue.tail';

		this.MAXHP = 25;
		this.HP = this.MAXHP;
		this.AD = 10;
		this.ATTACK_SPEED = 1.5;
		this.FOLLOW_RANGE = 700;
		this.SPD = 500;


		this.LootTable = new LootTable([]);

        this.timeToGrow = MathHelper.randomInRange(60, 120) * Main.FPS;
		this.minScale = .5;
		this.maxScale = 1;

        this.setScale(this.minScale);
    }

    Update()
	{
		super.Update();

		var growProgress = this.ageInTicks / this.timeToGrow;
		var scaleStep = this.maxScale - this.minScale;
		var new_scale = Math.round((this.minScale + (scaleStep * growProgress)) * 10) / 10;

		if(this.baseScale < new_scale) this.setScale(new_scale);

		if(growProgress >= 1) this.Grow();
	}

	Grow()
	{
		var largeVersion = new EntityLakeFrog();
			largeVersion.x = this.x;
			largeVersion.y = this.y;
			largeVersion.Rotation = this.Rotation;

		World.AddEntity(largeVersion);
		World.Kill(this);
	}
}
World.RegisterEntity(EntityLakeTadpole);



class EntityTrim extends Entity
{
	constructor(x, y)
	{
		super(x, y);
		
		this.name = "ENTITY.TRIM.NAME";
		this.Texture = "entity.trim";

		this.TextureRotation = 180;
		this.Rotation = 180;

		this.Tier = 0;

		this.MAXHP = 50;
		this.HP = this.MAXHP;
		this.AD = 10;
		this.ATTACK_SPEED = .25;
		this.SPD = 350;

		this.ATTACK_RANGE = 1000;
		this.FOLLOW_RANGE = 1000;
		this.BULLET_SPEED = 900;

        var rotationTime = 1;
        this.rotationSpeed = 360 / (rotationTime * Main.FPS);
        this.baseRotationSpeed = this.rotationSpeed;

		this.allowRotationChange = false;
		
		var stats = 
		{
            shotCount: 3,
            shotDelayMin: 2,
            shotDelayMax: 5,
            getStartAngleFromOwnerRotation: true
		};

		this.AI.Apply(new AI_Follow(World.Player, true));
		this.AI.Apply(new AI_Walk());
		this.AI.Apply(new AI_Wander());
		this.AI.Apply(new AI_ShotOnCircle(stats,
		{
			Scale: 1
		}));
        this.AI.Apply(new AI_AttackMelee(Player, 0, 1));
		
		this.isAggressiveOnHurt = true;

		this.RenderTransitions =
		{
			Scale: new Transition(1, 0.95, 0.25, true, 0.02, 0.02)
		}

		this.LootTable = new LootTable([
			new LootTableItemData("EnchantGemMP", 5, 1)
		]);
		this.canMoveWhileShooting = false;

		this.setScale(2);
	}

	Update()
	{
		if(this.shotOnCircleCharge >= 40)
		{
			this.allowMove = this.canMoveWhileShooting;
			this.allowFollow = this.canMoveWhileShooting;

			this.rotationSpeed = this.baseRotationSpeed * 2;
			if(this.shotOnCircleCharge >= 80) this.rotationSpeed = this.baseRotationSpeed * 3;
		}
		else
		{
			this.rotationSpeed = this.baseRotationSpeed;
		}
        
		super.Update();
	}

	RenderTexture(context)
	{
		if(!this.isBoss)this.Rotation = (this.Rotation + this.rotationSpeed)%360;
        this.Transparency = .2 + ((this.HP / this.MAXHP) * .8);

        super.RenderTexture(context);
	}
}
World.RegisterEntity(EntityTrim);














class EntityFatTrim extends EntityTrim
{
	constructor(x, y)
	{
		super(x, y);
		
		this.name = "ENTITY.TRIM.FAT.NAME";
		this.Texture = "entity.trim.fat";

		this.MAXHP = 80;
		this.HP = this.MAXHP;
		this.AD = 20;
		this.ATTACK_SPEED = 1;
		this.SPD = 300;

		this.FOLLOW_RANGE = 1000;

		this.Tier = 1;


		this.AI.Delete('ShotOnCircle');


		this.LootTable = new LootTable([
			new LootTableItemData("EnchantGemAS", 5, 1),
			new LootTableItemData("RocketLauncher1", 5, 1)
		]);
		this.setScale(2);
	}
}
World.RegisterEntity(EntityFatTrim);











class EntityTrimFormation0 extends EntityTrim
{
	constructor(x, y, type = 3)
	{
		super(x, y);
		
		this.type = type;
		this.name = "ENTITY.TRIM.FORMATION.0.NAME";
		this.Texture = "entity.trim.formation.0."+type;

		this.MAXHP = 2**(3+type);
		this.HP = this.MAXHP;
		this.AD = 10;
		this.SPD = 400;

		this.FOLLOW_RANGE = 1000;
		this.Tier = 2;
		

		var stats = 
		{
            shotCount: 6,
            shotDelayMin: 4,
            shotDelayMax: 6,
            getStartAngleFromOwnerRotation: true
		};

		this.AI = new AI();
		this.AI.Apply(new AI_Walk());
		this.AI.Apply(new AI_ShotOnCircle(stats,
		{
			Scale: 1
		}));
        this.AI.Apply(new AI_AttackMelee(Player, 0, 1));
		this.AI.Apply(new AI_Bounce(this, MathHelper.randomInRange(0, 360)));


		this.rotationSpeed /= 2;

		this.dropOxygen = false;
		this.dropLoot = false;

		this.LootTable = new LootTable([
			new LootTableItemData("EnchantGemADp", 5, 1)
		]);
		this.setScale(4);

		if(this.type == 1) 
		{
			this.dropOxygen = true;
			this.dropLoot = true;

			this.setScale(2);
		}
	}

	onKill()
	{

		if(this.type <= 1) return;

		var angle = MathHelper.getAngle2(this, World.Player)+90;

		var e = new EntityTrimFormation0(this.x, this.y, this.type-1);
			e.AI.Apply(new AI_Bounce(e, angle));
			e.level = this.level;
		World.AddEntity(e);

		var e2 = new EntityTrimFormation0(this.x, this.y, this.type-1);
			e2.AI.Apply(new AI_Bounce(e2, angle-180));
			e2.level = this.level;
		World.AddEntity(e2);
	}
}
World.RegisterEntity(EntityTrimFormation0);class EntityUpgrade extends Entity
{
	constructor(x, y, upgrade)
	{
		super();
		this.x = x;
		this.y = y;
		this.isHurtAble = false;
		this.Texture = "golden_bubble";
		
		this.width = 45;
		this.height = 45;
		
		this.upgrade = upgrade;
		this.SPD = 350;
		this.FOLLOW_RANGE = 150;
		
		this.AI.Apply(new AI_Follow(World.Player));
		this.AI.Apply(new AI_Walk());
		
		this.onPlayerCollision = function(player){this.Collect(player)};
	}
	
	Collect(player)
	{
		if(this.upgrade >= 0)
		{
			player.Upgrades[this.upgrade].Active(player);
		}		
		this.Kill();
	}
}
World.RegisterEntity(EntityUpgrade);class Oxygen extends Entity
{
	constructor(x, y, value = 0, level, isHeart = false, isFromBoss = false, motion)
	{
		super(x, y);
		this.isHurtAble = false;
		this.Texture = "bubble";
		this.level = level;
		this.isHeart = isHeart;
		this.isFromBoss = isFromBoss;
		this.moveParticle = "";

		this.width = 45;
		this.height = 45;
		
		this.value = value;
		this.SPD = 350;
		this.FOLLOW_RANGE = 150;
		this.oxygen = 0;

		if(motion)
		{
			this.moveX = motion.x;
			this.moveY = motion.y;
		}
		else
		{
			this.AI.Apply(new AI_Follow(World.Player));
		}
		
		this.DeathSound = "effect.BubblePop";

		this.AI.Apply(new AI_Walk());
		
		this.onPlayerCollision = function(player){this.Collect(player)};
		
		if((this.value > 50 && !this.isHeart) || (this.value > 2 && this.isHeart))
		{
			this.Split();
		}

		this.Scale = 0.45 + ((this.value / 5) * 0.01);
		
		
		if(this.value == 0)
		{
			this.Scale = 0;
			this.DeathSound = "";
		}

		if(this.isHeart)
		{
			this.Scale = 1;
			this.maxHeartScale = 1.2;
			this.minHeartScale = 0.8;
			this.heartScaleTransition = new Transition(this.minHeartScale, this.maxHeartScale, 0.1, true, 0.05, 10.05);
			this.heartScaleTransition.RandomizeDelay(true, 50);

			this.beatTimes = 2;
			this.beatTime = 0;

			if(this.value == 2)
			{
				this.Texture = "heart";
			}
			else
			{
				this.Texture = "heart_half";
			}
		}

		this.baseScale = this.Scale;
	}
	
	Split()
	{
		var value = (this.isHeart) ? this.value * 10 : this.value;
		while(value > 20)
		{
			value = Math.ceil(value * 0.5);
			this.value = Math.ceil(this.value * 0.5);
			var pos = MathHelper.getRandomPointInRange([this.x, this.y], 150);
		
			World.AddEntity(new Oxygen(pos.x, pos.y, this.value, this.level, this.isHeart));
		}
	}
	
	Update()
	{
		super.Update();
		if(World.Location.isCleared && !this.isHeart)
		{
			this.FOLLOW_RANGE = (World.Radius * 2);
			this.SPD = 900;
		}
		if(this.isHeart)
		{
			this.Scale = this.heartScaleTransition.Update();
			this.AI.Follow.disabled = false;

			
			if(this.heartScaleTransition.isUnreverseTick)
			{
				if(this.beatTime >= this.beatTimes - 1)
				{
					this.beatTime = 0;
				}
				else
				{
					this.beatTime++;
					this.heartScaleTransition.reverseTicks = this.heartScaleTransition.unreverseDelay;
				}			
			}

			//zapobiega odwracaniu sie serca podczas podazania do gracza
			this.Rotation = 0;

			//serce nie podaza za graczem jesli ma pelne zdrowie
			if(World.Player.stats.HP == World.Player.stats.MAXHP)
			{
				this.AI.Follow.disabled = true;


				var delay = 0.9;
				this.moveX *= delay;
				this.moveX = (this.moveX > 0) ? Math.floor(this.moveX) : Math.ceil(this.moveX);

				this.moveY *= delay;
				this.moveY = (this.moveY > 0) ? Math.floor(this.moveY) : Math.ceil(this.moveY);
			}

		}
	}

	static GetOxygenValue(value, playerLevel, oxygenLevel, isBoss)
	{
		var exp = value;
		var maxLevelDiff = 5;
		var lostPerLevel = (isBoss) ? 10 : 20;		//%

		var levelDifference = Math.abs(oxygenLevel - playerLevel);
		if(levelDifference > maxLevelDiff)
		{
			var times = levelDifference - maxLevelDiff;
			exp -= Math.floor(exp * (times * lostPerLevel) / 100);
		}
		exp = (exp < 1) ? 1 : exp;

		return exp;
	}
	
	Collect(player)
	{
		if(this.isHeart)
		{
			//gracz nie moze zebrac serca jesli ma pelne zdrowie
			if(player.stats.HP == player.stats.MAXHP) return;

			var value = (this.value * Player.GetHeartValue());
			player.stats.HP += value;
			player.stats.HP = (player.stats.HP > player.stats.MAXHP) ? player.stats.MAXHP : player.stats.HP;
			DamageIndicator.AddObject(this.x, this.y, value, "HEAL");
		}
		else
		{
			var exp = Oxygen.GetOxygenValue(this.value, player.stats.Level, this.level, this.isFromBoss);

			var coins = this.value * 2;

			player.oxygen += exp;
			player.oxygenGainedInRoom += exp;
			player.coins += coins;

			player.RunStats.totalExperienceEarned += exp;
			player.RunStats.totalGoldEarned += coins;
		}
		
		this.Kill();
		World.Spawn(new Particle("bubble_pop", this.HitBox.x, this.HitBox.y, 20, this.width, this.height, this.Scale, true));
	}
}
World.RegisterEntity(Oxygen);class ParticleFlash extends Particle
{
    constructor(x, y, data = {})
    {
        super();

        this.x = x;
        this.y = y;

        this.Transparency = 1;
        this.Duration = 30;
        this.Size = 64;

        this.Stars = 10;
        this.currentStars = 0;
        this.StarsSpeed = 50;

        this.DustSpeed = 15;

        this.Type = 0;
        this.Scale = 1;
        this.timeToShow = 0;

        this.Textures = 
        {
            1: 'effect.flash.1',
            2: 'effect.flash.2'
        };


        for(var i in data)
        {
            this[i] = data[i];
        }
    }


    Render(context)
	{
		if(isFunction(this.onRender)) this.onRender(this);

        if(this.Type == 1 && this.ageInTicks == 0)
        {
            var s = new ParticleFlashCircle(this.x, this.y);
                s.Scale = this.Scale;
                s.Transparency = this.Transparency;
                s.RENDER_LAYER = Graphic.Layer.Particle0;

            World.AddParticle(s);

            s = new ParticleFlashCircle(this.x, this.y);
                s.Scale = this.Scale * 2;
                s.Transparency = this.Transparency;
                s.RENDER_LAYER = Graphic.Layer.Particle0;
                s.Texture = 'effect.flash.5';

            World.AddParticle(s);

            this.timeToShow = s.Duration / 2;
        }

        this.ageInTicks++;
        if(this.ageInTicks <= this.timeToShow) return;

		
        if(this.currentStars < this.Stars)
        {
            var size = this.Size * 2 * this.Scale;
            var sX = this.x + (MathHelper.randomInRange(-50, 50) * size / 100);
            var sY = this.y + (MathHelper.randomInRange(-50, 50) * size / 100);
            var s = new ParticleFlashStar(sX, sY);
                s.Scale = this.Scale;
                s.Transparency = this.Transparency;
                s.speed = this.StarsSpeed * MathHelper.randomInRange(70, 100) / 100;
                s.Duration = this.Duration * 1.5;
                s.RENDER_LAYER = this.RENDER_LAYER;

            World.AddParticle(s);
            this.currentStars++;
        }

        if(this.ageInTicks%5 == 0)
        {
            var sX = this.x;
            var sY = this.y;
            var s = new ParticleFlashDust(sX, sY);
                s.Scale = this.Scale * 2;
                s.speed = this.DustSpeed;
                s.Duration = this.Duration;
                s.RENDER_LAYER = this.RENDER_LAYER;

            World.AddParticle(s);
        }

        if(this.ageInTicks > this.Duration+this.timeToShow) this.Kill();
	}
}

class ParticleFlashCircle extends Particle
{
    constructor(x, y, data = {})
    {
        super();

        this.x = x;
        this.y = y;

        this.Transparency = 1;
        this.Duration = 10;

        this.Scale = 1;

        this.Texture = 'effect.flash.1';

        for(var i in data)
        {
            this[i] = data[i];
        }
    }

    Render(context)
	{
		this.ageInTicks++;
		
		var x = this.x - Camera.xView;
		var y = this.y - Camera.yView;
        var size = 64;
        var scale = this.Scale * 5;
        var s = 1 - (this.ageInTicks / this.Duration);

		if(this.RENDER_LAYER!=null) 
		{
			ChangeLayer(this.RENDER_LAYER);
			context = ctx;
		}

        Graphic.DrawRotatedImage(context, TextureManager.Get(this.Texture), x, y, size, size, scale * s, 0, this.Transparency);

		if(this.RENDER_LAYER!=null) RestoreLayer();

        if(this.ageInTicks >= this.Duration) this.Kill();
	}
}



class ParticleFlashStar extends Particle
{
    constructor(x, y, data = {})
    {
        super();

        this.x = x;
        this.y = y;

        this.Transparency = 1;
        this.Duration = 15;

        this.speed = 10;
        this.Scale = 1;
        this.silkTime = 5;
        this.moveTick = MathHelper.randomInRange(0, 100);

        this.Texture = 'effect.flash.4';

        for(var i in data)
        {
            this[i] = data[i];
        }
    }

    Move()
    {
        var d = Main.DELTA;
        this.y -= this.speed * d;
        this.x += (Math.cos((this.moveTick+this.ageInTicks)/5) * this.speed * 3) * d;
    }


    Render(context)
	{
		this.ageInTicks++;
        this.Move();
		
		var x = this.x - Camera.xView;
		var y = this.y - Camera.yView;
        var size = 64;
        var s = 1;
        var scale = this.Scale * .3;
        var alpha = 1;
        if(this.ageInTicks < this.silkTime) s = this.ageInTicks / this.silkTime;
        if(this.ageInTicks > this.Duration-this.silkTime) s = (this.Duration-this.ageInTicks) / this.silkTime;

		if(this.RENDER_LAYER!=null) 
		{
			ChangeLayer(this.RENDER_LAYER);
			context = ctx;
		}

        Graphic.DrawRotatedImage(context, TextureManager.Get(this.Texture), x, y, size, size, scale * s, 0, alpha * this.Transparency);

		if(this.RENDER_LAYER!=null) RestoreLayer();

        if(this.ageInTicks > this.Duration) this.Kill();
	}
}


class ParticleFlashDust extends ParticleFlashStar
{
    constructor(x, y, data = {})
    {
        super(x, y);

        this.Texture = 'effect.flash.3';

        for(var i in data)
        {
            this[i] = data[i];
        }
    }

    Move()
    {
        var d = Main.DELTA;
        this.y -= this.speed * d;
        // this.x += (Math.sin(this.y) * this.speed) * d;
    }

    Render(context)
	{
		this.ageInTicks++;
        this.Move();
		
		var x = this.x - Camera.xView;
		var y = this.y - Camera.yView;
        var size = 64;
        var scale = this.Scale;
        var alpha = 1 - (this.ageInTicks / this.Duration);

		if(this.RENDER_LAYER!=null) 
		{
			ChangeLayer(this.RENDER_LAYER);
			context = ctx;
		}

        Graphic.DrawRotatedImage(context, TextureManager.Get(this.Texture), x, y, size, size, scale, 0, alpha * this.Transparency);

		if(this.RENDER_LAYER!=null) RestoreLayer();

        if(this.ageInTicks >= this.Duration) this.Kill();
	}
}class ParticleLightning extends Particle
{
    constructor(from, to, data = {})
    {
        super();

        this.From = from;
        this.To = to;

        this.segments = 40;
        this.maxVariation = 2;
        this.positions = [];

        this.Transparency = 1;

        this.Color = 'white';
        this.Width = 3;
        this.Blur = 5;
        this.BlurColor = 'white';

        this.GlowColor = '#FBFF57';
        this.GlowWidth = 15;
        this.GlowBlur = 25;

        this.fromTy = 0;
        this.fromTx = 0;

        this.toTy = 0;
        this.toTx = 0;

        for(var i in data)
        {
            this[i] = data[i];
        }
    }


    Render(context)
	{
        if(!this.From || !this.From.isAlive || this.From.killLightning) return this.Kill();
        if(!this.To || !this.To.isAlive || this.To.killLightning) return this.Kill();

		this.ageInTicks++;
		if(isFunction(this.onRender)) this.onRender(this);
		
		var x = this.From.x - Camera.xView + this.fromTx;
		var y = this.From.y - Camera.yView + this.fromTy;

        var x2 = this.To.x - Camera.xView + this.toTx;
		var y2 = this.To.y - Camera.yView + this.toTy;

        var positions = [];
        var totalLength = MathHelper.GetDistance(this.From, this.To);
        var segmentLength = totalLength / this.segments;
        var angle = MathHelper.getAngle2([this.From.x+this.fromTx, this.From.y+this.fromTy], [this.To.x+this.toTx, this.To.y+this.toTy]);
        var maxVariationLength = totalLength * this.maxVariation / 100;

        for(var i = 0; i < this.segments-1; i++)
        {
            var pos = MathHelper.lineToAngle([this.From.x+this.fromTx, this.From.y+this.fromTy], segmentLength * (i+1), angle);
            var _angle = MathHelper.randomInRange(0, 360);
            var r = MathHelper.randomInRange(0, maxVariationLength);

            var end = MathHelper.lineToAngle(pos, r, _angle);

            positions.push([end.x-Camera.xView, end.y-Camera.yView]);
        }

        positions.push([x2, y2]);

		if(this.RENDER_LAYER!=null) 
		{
			ChangeLayer(this.RENDER_LAYER);
			context = ctx;
		}

        var glow = 
        {
            color: this.GlowColor,
            Width: this.GlowWidth,
            blur: this.GlowBlur,
            blurColor: this.GlowColor,
            alpha: this.Transparency * .5
        };

        var base = 
        {
            color: this.Color,
            Width: this.Width,
            blur: this.Blur,
            blurColor: this.BlurColor,
            alpha: this.Transparency
        };

        this.DrawLine(context, x, y, positions, glow);
        this.DrawLine(context, x, y, positions, base);


        var r = this.Width * 2;
        var tX = MathHelper.randomInRange(-r/2, r/2);
        var tY = MathHelper.randomInRange(-r/2, r/2);
        this.DrawCircle(context, x+tX, y+tY, r, base);
        this.DrawCircle(context, x2+tX, y2+tY, r, base);


		if(this.RENDER_LAYER!=null) RestoreLayer();
	}

    DrawCircle(context, x, y, r, colors) 
    {
        context.save();
        context.globalCompositeOperation = 'source-over';
        context.beginPath();
        context.arc(x, y, r, 0, 2 * Math.PI, false);
        context.fillStyle = colors.color;
        context.shadowBlur = colors.blur;
        context.shadowColor = colors.blurColor;
        context.fill();
        context.restore();
    }


    DrawLine(context, x, y, positions, colors)
    {
        context.save();
        context.globalCompositeOperation = 'source-over';
        context.lineJoin = 'round';
        context.beginPath();
        context.strokeStyle = colors.color;
        context.lineWidth = colors.Width;

        context.moveTo(x, y);

        for(var i in positions) 
            context.lineTo(positions[i][0], positions[i][1]);
       
        context.globalAlpha = colors.alpha;
        context.shadowBlur = colors.blur;
        context.shadowColor = colors.blurColor;
        context.stroke();
        context.restore();
    }
}class TutorialBubble extends Entity
{
	constructor(x, y)
	{
		super(x, y);
		
		this.level = 1;
		this.BULLET_SPEED = 700;
		this.AD = 5;
		this.BULLET_SERIES = 1;
		this.ATTACK_SPEED = 0.5;
		this.ATTACK_RANGE = 1000;
		this.FOLLOW_RANGE = 1000;
		this.MAXHP = 15;
		this.HP = this.MAXHP;
		this.oxygen = (World.Player?.stats.Level == 1) ? 6 : 1;
		this.Texture = "bubble";
		this.name = 'ENTITY.BUBBLE.NAME';
		
		var bulletStats = 
		{
			Color: new Color(255, 0, 0),
			Scale: 1
		};

		this.AI.Apply(new AI_Follow(World.Player, true));
		this.AI.Apply(new AI_Walk());
		this.AI.Apply(new AI_Wander());
		this.AI.Apply(new AI_AttackRange(World.Player, bulletStats));
		
		this.isAggressiveOnHurt = true;
		
		this.Color = new Color(255, 64, 64);
		this.HitBox.Scale = 1;

		this.RenderTransitions =
		{
			Scale: new Transition(1, 0.95, 0.25, true, 0.02, 0.02)
		};

		this.LootTable = new LootTable([]);

		this.setScale(1);
	}
	
	Update()
	{
		super.Update();

		if(this.aggressive)
		{
			this.SPD = 250;
			this.Color = new Color(255, 0, 0);
		}
		else
		{
			this.SPD = 100;
		}
	}
}
World.RegisterEntity(TutorialBubble);class Bubblebee extends EntityLargeBee
{
	constructor(x, y)
	{
		super(x, y);
		
		this.name = "ENTITY.BUBBLEBEE.NAME";
		this.description = "ENTITY.BUBBLEBEE.DESCRIPTION";

		this.MAXHP = 2200;
		this.HP = this.MAXHP;
		this.AD = 10;
		this.ATTACK_SPEED = 1;
        this.ATTACK_RANGE = 1500;
		this.FOLLOW_RANGE = 9999;
        this.BULLET_SPEED = 1800;
		this.SPD = 100;
		
        var bullet_stats = 
        {
            Scale: 3,
			Type: 'BulletSting',
			bullets: 10
        };

        this.AI = new AI();
        if(World.Player?.haveItemInInventory('Honeycomb') != -1)
        {
            this.AI.Apply(new AI_Talk(this));

            this.startDialog = 'BubblebeeDialog';
            this.firstMetDialog = 'BubblebeeDialog';

            this.dialogLine = this.firstMetDialog;
        }


        this.AI.Apply(new AI_Wander(true, 4, 8));
		this.AI.Apply(new AI_AttackMelee(Player, this.AD, 2, {onlyOnAggressive: true}));
        this.AI.Apply(new AI_Follow(World.Player, false, function(o){return o.aggressive || o.interestedIn}));
		this.AI.Apply(new AI_Walk());
		this.AI.Apply(new AI_Observe(World.Player, this.ATTACK_RANGE, function(owner){return !owner.interestedIn && owner.aggressive;}));
        this.AI.Apply(new AI_AttackRange(World.Player, bullet_stats, {updateTrigger: function(owner){return owner.aggressive && !owner.interestedIn && !owner.gotChunk;}}));

		this.AI.Apply(new AI_Boss(this));
		this.AI.Apply(new AI_Enrage(this, 50));

        this.aggressive = false;
        this.isAggressive = false;
        this.isAggressiveOnHurt = true;

        this.BossTheme = "interface.BossFight2";

        this.Model = new LargeBeeModel(this);
		this.setScale(5);

        this.enragedAnimationDuration = 4 * Main.FPS;

        this.FlyDuration = 10 * Main.FPS;

        this.DropHoneyChance = 10;

		this.invincibleScale = 1.5;
		this.LootTable = new LootTable([new LootTableItemData('TreasureOrbAquamantula', 100, 1, 1)]);

        this.canFlyAway = false;
        this.LookForHoneyDelay = MathHelper.randomInRange(10, 15) * Main.FPS;
        this.LookForHoneyTime = this.LookForHoneyDelay;
        this.timeToFlyAway = MathHelper.randomInRange(5, 10) * Main.FPS;

        this.honeyPiecesOnTake = 10;
        this.dinnerTimes = 0;

        this.honeyStats = 
        {
            summonDelay: 99999,
            MinEntities: 1,
            MaxEntities: 3
        };


        this.flyAwayTy = 100;
        this.isFlyingHome = false;
    }

    TakeHoney()
    {
        var s = World.Player.haveItemInInventory('Honeycomb');
        World.Player.inventory[s].count--;
        if(World.Player.inventory[s].count <= 0) World.Player.inventory[s] = null;

        Commands.GoToLocation('Lake9', 3, false);
        this.isFlyingHome = true;
        this.gotChunk = true;
        this.interestedIn = null;
        this.LookForHoneyTime = 9999999;
        this.killOnBorderOut = false;

        this.flyHome = this.ageInTicks + 60;
        this.timeToFlyAway = this.ageInTicks + 60;
        this.Fly();

        this.AI.Follow.observationTrigger = function(){return true;};
        this.AI.Delete('Wander');
    }

    onHurt()
    {
        this.AI.Delete('Talk');
        this.quote = null;
        this.AI.AttackMelee.onlyOnAggressive = false;

        super.onHurt();
    }

    Enrage()
    {
        this.BULLET_SPEED += 200;
        this.ATTACK_SPEED += .5;
    }

    onEnrageAnimationProgress()
    {
        if(this.ageInTicks%3 == 0)
        {
            this.honeyStats.summonDelay = MathHelper.randomInRange(60, 180) * Main.FPS
            this.SummonHoney();
        }
    }

    onWanderDestination()
    {
        if(this.isFlying) this.AI.Wander?.changeDir();
    }

    onHoneyGrab()
    {
        this.dinnerTimes++;

        this.setScale(5 + this.dinnerTimes * .5);
        this.AD += 2;
    }

    Update()
    {
        super.Update();

        if(this.gotChunk && this.ageInTicks%(5*60) == 0) this.gotChunk = false;
        if(this.isEnraged) this.aggressive = true;

        if(this.isFlyingAway)
        {
            this.Rotation = 180;

            World.Player.allowControl = false;
            World.Player.x = this.x;
            World.Player.y = this.y + this.flyAwayTy;
        }

        if(this.isFlyingHome)
        {
            this.gotChunk = true;

            if(this.ageInTicks == this.flyHome) 
            {
                this.canFlyAway = true;
            }
        }
    }
}
World.RegisterEntity(Bubblebee);class BubblebeeQueen extends EntityLargeBee
{
	constructor(x, y)
	{
		super(x, y);
		
		this.name = "ENTITY.BUBBLEBEE.QUEEN.NAME";
		this.description = "ENTITY.BUBBLEBEE.QUEEN.DESCRIPTION";

		this.MAXHP = 5000;
		this.HP = this.MAXHP;
		this.AD = 5;
		this.ATTACK_SPEED = 1;
        this.ATTACK_RANGE = 1500;
		this.FOLLOW_RANGE = 9999;
        this.BULLET_SPEED = 2500;
		this.SPD = 70;
		
        var bullet_stats = 
        {
            Scale: 5,
			Type: 'BulletSting',
			bullets: 15
        };

        this.AI = new AI();
        // if(World.Player?.haveItemInInventory('Honeycomb') != -1)
        // {
        //     this.AI.Apply(new AI_Talk(this));

        //     this.startDialog = 'BubblebeeDialog';
        //     this.firstMetDialog = 'BubblebeeDialog';

        //     this.dialogLine = this.firstMetDialog;
        // }


        this.AI.Apply(new AI_Wander(true, 4, 8));
		this.AI.Apply(new AI_AttackMelee(Player, this.AD, 1, {onlyOnAggressive: true}));
        this.AI.Apply(new AI_Follow(World.Player, false, function(o){return o.aggressive || o.interestedIn}));
		this.AI.Apply(new AI_Walk());
		this.AI.Apply(new AI_Observe(World.Player, this.ATTACK_RANGE, function(owner){return (!owner.interestedIn && owner.aggressive) || owner.isUsingSpecialAttack;}));
        this.AI.Apply(new AI_AttackRange(World.Player, bullet_stats, {updateTrigger: function(owner){return owner.aggressive && !owner.interestedIn && !owner.gotChunk && !owner.isUsingSpecialAttack}}));

		this.AI.Apply(new AI_Boss(this));
		this.AI.Apply(new AI_Enrage(this, 50));

        this.aggressive = false;
        this.isAggressive = false;
        this.isAggressiveOnHurt = true;


        this.BossTheme = "interface.BossFight2";

        this.Model = new LargeBeeModel(this);
        this.Model.Parts.base.Texture = 'base.queen';
        this.Model.Parts.abdomen.Texture = 'abdomen.queen';
		this.setScale(10);

        this.enragedAnimationDuration = 4 * Main.FPS;
        this.FlyDuration = 10 * Main.FPS;

        this.DropHoneyChance = 10;

		this.invincibleScale = 1.5;
		this.LootTable = new LootTable([new LootTableItemData('TreasureOrbAquamantula', 100, 1, 1)]);

        this.canFlyAway = false;
        this.LookForHoneyDelay = MathHelper.randomInRange(10, 15) * Main.FPS;
        this.LookForHoneyTime = this.LookForHoneyDelay;
        this.timeToFlyAway = MathHelper.randomInRange(5, 10) * Main.FPS;

        this.honeyPiecesOnTake = 10;
        this.dinnerTimes = 0;



        this.isUsingSpecialAttack = false;
       
        this.specialAttackDelay = 10 * Main.FPS;
        this.specialAttackAnimationDelayIndicator = 5 * Main.FPS;       //how earlier animation should start
        this.lastSpecialAttack = MathHelper.randomInRange(0, this.specialAttackDelay/2);

        this.specialAttackDuration = 5 * Main.FPS;
        this.specialAttackTicks = 0;
        this.specialAttackTick = 0;
        this.specialAttackTimes = 0;

        this.currentAttackType = null;
        this.battleStart = false;

        this.honeyStats = 
        {
            summonDelay: 99999,
            MinEntities: 1,
            MaxEntities: 2
        };
    }

    onHurt()
    {
        this.AI.Delete('Talk');
        this.quote = null;
        this.AI.AttackMelee.onlyOnAggressive = false;
        this.battleStart = true;

        super.onHurt();
    }

    Enrage()
    {
        this.BULLET_SPEED += 500;
        this.ATTACK_SPEED = 2.5;
    }

    onEnrageAnimationProgress()
    {
        if(this.ageInTicks%3 == 0)
        {
            this.honeyStats.summonDelay = MathHelper.randomInRange(60, 240) * Main.FPS
            this.SummonHoney();
        }
    }

    onWanderDestination()
    {
        if(this.isFlying) this.AI.Wander?.changeDir();
    }

    onHoneyGrab()
    {
        this.dinnerTimes++;

        this.setScale(10 + this.dinnerTimes/2);
        this.AD += 1;
    }

    Update()
    {
        super.Update();

        if(this.gotChunk && this.ageInTicks%(5*60) == 0) this.gotChunk = false;
        if(this.battleStart) this.aggressive = true;

        if(this.NoAI || this.lockAI || !this.battleStart) return;

        this.specialAttackTicks++;

        var tickToAttack = this.lastSpecialAttack + this.specialAttackDelay;
        if(this.specialAttackTicks >= tickToAttack+this.specialAttackAnimationDelayIndicator)
        {
            this.specialAttackUpdate();
        }

        if(this.specialAttackTicks >= tickToAttack && this.specialAttackTicks < tickToAttack +this.specialAttackAnimationDelayIndicator)
        {
            this.prepareSpecialAttack();
        }
    }












    prepareSpecialAttack()
    {
        this.allowMove = false;
        this.isUsingSpecialAttack = true;

        var tickToAttack = this.lastSpecialAttack + this.specialAttackDelay;
        var p = (this.specialAttackTicks-(tickToAttack-this.specialAttackAnimationDelayIndicator)) / this.specialAttackAnimationDelayIndicator;
        if(p > 1) p = 1;

        if(this.getSpecialAttackType() == 'STINGS')
        {
            if(this.ageInTicks%3 == 0)
            {
                var scale = .5 * MathHelper.randomInRange(75, 125) / 100 * this.Scale;
                var r = (this.Width / 2 * this.Scale);
                var x = this.x + MathHelper.randomInRange(-r, r);
                var y = this.y + MathHelper.randomInRange(-r, r);
                var spd = 50;

                Particle.Summon('effect.poison', x, y, x, y-500, scale, spd, 1, 20, 
                {
                    liveTime: 60, 
                    // owner: owner,
                    baseScale: scale,
                    center: true,
                    // globalAlpha: 0.5,
                    // RENDER_LAYER: Graphic.Layer.Particle0,
                    onUpdate: function(){this.Scale = (this.baseScale * (this.ageInTicks / this.liveTime))}
                });
            }
        }

        if(this.getSpecialAttackType() == 'HONEY')
        {
            if(this.ageInTicks%3 == 0)
            {
                var scale = .5 * MathHelper.randomInRange(75, 125) / 100 * this.Scale;
                var r = (this.Width / 2 * this.Scale);
                var x = this.x + MathHelper.randomInRange(-r, r);
                var y = this.y + MathHelper.randomInRange(-r, r);
                var spd = 50;

                Particle.Summon('effect.honey_bubble', x, y, x, y-500, scale, spd, 1, 20, 
                {
                    liveTime: 60, 
                    // owner: owner,
                    baseScale: scale,
                    center: true,
                    // globalAlpha: 0.5,
                    // RENDER_LAYER: Graphic.Layer.Particle0,
                    onUpdate: function(){this.Scale = (this.baseScale * (this.ageInTicks / this.liveTime))}
                });
            }
        }

        if(this.getSpecialAttackType() == 'BEES')
        {
            var freq = 60;
            if(this.specialAttackTicks%freq == 0)
            {
                var scale = 20 * this.Scale;
                var x = this.x;
                var y = this.y;
                Particle.Summon('effect.sonic_boom.indicator', x, y, 0, 0, scale, 0, 1, 20, 
                {
                    liveTime: 30, 
                    baseScale: scale,
                    center: true,
                    // globalAlpha: 0.5,
                    // RENDER_LAYER: Graphic.Layer.LightLevel+1,
                    onUpdate: function(){this.Scale = (this.baseScale * (this.ageInTicks / this.liveTime)); this.opacity = 1 - (this.ageInTicks / this.liveTime)}
                });
            }
        }
    }


    getSpecialAttackType()
    {
        if(this.specialAttackTimes%3 == 0) return 'STINGS';
        if(this.specialAttackTimes%3 == 1) return 'BEES';
        if(this.specialAttackTimes%3 == 2) return 'HONEY';
    }

    specialAttack()
    {
        this.allowMove = false;
        if(this.getSpecialAttackType() == 'STINGS') return this.specialAttackStings();
        if(this.getSpecialAttackType() == 'BEES') return this.specialAttackSummonBees();
        if(this.getSpecialAttackType() == 'HONEY') return this.specialAttackSummonHoney();
    }


    specialAttackStings()
    {
        var delay = 45;
        if(this.specialAttackTick%delay == 0)
        {
            var bullets = 24;
            var angle = (this.specialAttackTick%(delay*2) == 0) ? 0 : (360/bullets)/2;

            var stats = {};
                stats.Type = 'BulletSting';
                stats.spd = this.BULLET_SPEED * .75;
                stats.bullets = 0;
                stats[STAT.ATTACK_RANGE] = 9999;
                stats.Scale = 5;
                stats.damage = this.AD/2,
                stats.moveParticle = 'effect.poison',
                stats.onPlayerCollisionEffects = [['Poisoning', 1, 15, false]],
                stats.onEntityCollisionEffects = [['Poisoning', 1, 15, false]],

            AI_ShotOnCircle.StaticShoot(this, stats, bullets, {angle: angle});
        }
    }

    specialAttackSummonBees()
    {
        var delay = 30;
        if(this.specialAttackTick%delay == 0)
        {
            var pos = MathHelper.getRandomPointInRange(World.CenterPoint, World.Radius-50, World.Radius-150);
            var e = new EntityLakeLargeBee(pos.x, pos.y);
                e.dropOxygen = false;
                e.dropLoot = false;
                // e.isAggressive = true;
                e.FlyDuration = 9999999;
                e.LookForHoneyTime = 99999999;
                e.ATTACK_RANGE = 800;
                e.Fly();
            
            World.AddEntity(e, false);
        }
    }

    specialAttackSummonHoney()
    {
        var delay = 30;
        if(this.specialAttackTick%delay == 0)
        {
            var e = new EntityHoneycomb(this.x, this.y);
                e.level = 0;
                e.LootTable = new LootTable();
            
            World.AddEntity(e, false);
        }
    }

    onSpecialAttackEnd()
    {
        this.allowMove = true;
        this.isUsingSpecialAttack = false;
        this.specialAttackTimes++;
    }

    specialAttackUpdate()
    {
        if(this.specialAttackTick >= this.specialAttackDuration)
        {
            this.specialAttackTick = 0;
            this.lastSpecialAttack = this.specialAttackTicks;
            this.onSpecialAttackEnd();
            return;
        }

        this.specialAttack();
        this.specialAttackTick++;
    }
}
World.RegisterEntity(BubblebeeQueen);class Celltipede extends Entity
{
	constructor(x, y)
	{
		super(x, y);
		
		this.name = "ENTITY.CELLTIPEDE.NAME";
        this.BossTheme = "interface.BossFight2";

        this.Textures = 
        {
            base: 'entity.celltipede.head',
            fang_left: 'entity.celltipede.fang.left',
            fang_right: 'entity.celltipede.fang.right',

            head_add_left: 'entity.celltipede.head.left',
            head_add_right: 'entity.celltipede.head.right',
        };
        this.Rotation = 180;

		this.MAXHP = 3000;
		this.HP = this.MAXHP;
		this.AD = 20;
		this.ATTACK_SPEED = .25;
		this.SPD = 1500;

		this.ATTACK_RANGE = 1000;
		this.FOLLOW_RANGE = 1000;
		this.BULLET_SPEED = 900;

		this.AI.Apply(new AI_Walk(false));
        this.AI.Apply(new AI_AttackMelee(Player, 0, 3));
        this.AI.Apply(new AI_Boss(this));
        this.AI.Apply(new AI_Enrage(this, 50, {showAnimation: false, invincibleOnRage: false}));
        this.AI.Apply(new AI_Bounce(this, 0, function(owner){return MathHelper.getAngle2(owner, World.Player)}, World.Player));

		this.RenderTransitions =
		{
			Scale: new Transition(1, 0.95, 0.25, true, 0.02, 0.02)
		}
        this.enragedAnimationDuration = 0;

		this.LootTable = new LootTable([]);

		this.setScale(2.5);
        this.headScale = 1.2;
        this.headAddsScale = this.headScale * 1.1;

        this.Childs = [];

        this.segments = 40;
        this.segmentsDistance = this.width * .75;
        this.partBody = EntityCelltipedePart;
        this.partTail = EntityCelltipedeTail;

        this.movementChange = 0;
        this.Positions = [];
        this.Destination = {};

        this.Resistance[ELEMENT.PHYSICAL] = true;
        this.Immunity.SLOW = true;
        this.Immunity.STUN = true;
        
        this.LootTable = new LootTable([new LootTableItemData('TreasureOrbCelltipede', 100, 1, 1)]);
        
        this.setLegsAnimation();
	}

    onSummon()
    {
        this.CreateParts();
        this.setLegsAnimation();
    }

    setLegsAnimation()
    {
        this.legsAnimDuration = (150 / this.SPD) * .5;
        this.legsAnimation = new Transition(-10, 10, this.legsAnimDuration, true, 0, 0, false);

        for(var i in this.Childs)
        {
            var c = this.Childs[i];
            c.legsAnimation = new Transition(-30, 30, this.legsAnimDuration, true, 0, 0, false);
        }
    }

    Enrage()
    {
        this.SPD *= 1.5;

        ApplyEffect(this, 'Invincibility', 1, 4);
        for(var i in this.Childs)
        {
            var c = this.Childs[i];
            ApplyEffect(c, 'Invincibility', 1, 4);
        }

        //podczas animacji stopniowo zwiekszac spd, poprzez obliczanie nowego moveX/y za pomoca this.Destination
    }

    GetDelay()
    {
        var size = this.segmentsDistance * this.baseScale;
        var delay = Math.floor(size / (this.SPD*Main.DELTA));

        return delay;
    }

    CreateParts()
    {
        this.Childs = [];

        var delay = this.GetDelay();
        var lastPart = this;
        var e;
        for(var i = 0; i < this.segments; i++)
        {
            e = new this.partBody(this.x, this.y, lastPart, this);
            if(i==this.segments-1)e = new this.partTail(this.x, this.y, lastPart, this);

            e.MAXHP = this.MAXHP / this.segments;
            e.HP = e.MAXHP;
            e.AD = this.AD;
            e.isHurtAble = false;
            e.movementDelay = (i+1) * delay;
            e.NoAI = true;
            e.num = i;
            e.Immunity = this.Immunity;

            this.Childs.push(e);
            lastPart = e;
            World.AddEntity(e);
        }
    }

    onBounce()
    {
        if(this.isEnraged)
        {
            var stats = {};
                stats.spd = 1500;
                stats.damage = 0;
                stats[STAT.ATTACK_RANGE] = 9999;
                stats.Scale = 2;
                stats.knockBack = 10;
                stats.noKillParticle = true;
                stats.moveParticle = null;

            AI_ShotOnCircle.StaticShoot(this, stats, 32);
        }
    }

    onBossAnimationEnd()
    {
        var delay = this.GetDelay();
        for(var i = 0; i < this.Childs.length; i++)
        {
            var c = this.Childs[i];
            c.isHurtAble = true;
            c.NoAI = false;
            c.showTick = this.ageInTicks + c.movementDelay - delay;

            this.highestDelay = c.movementDelay;
        }
    }

    UpdateHP()
    {
        if(!this.isHurtAble || this.Childs.length == 0) return;
        this.HP = 0;
        for(var i in this.Childs)
        {
            var c = this.Childs[i];
            if(!c.isAlive) continue;
            this.HP += c.HP;
        }
    }

    UpdatePositionsArray()
    {
        this.Positions.unshift([this.x, this.y]);

        //slice array when its too big
        if(this.Positions.length / this.highestDelay >= 2)
        {
            this.Positions = this.Positions.slice(0, this.highestDelay);
        }
    }

	Update()
	{
        this.UpdateHP();

        this.UpdatePositionsArray();
		super.Update();
	}


    RenderTexture(context)
	{
        var base = TextureManager.Get(this.Textures.base);
        var fang_left = TextureManager.Get(this.Textures.fang_left);
        var fang_right = TextureManager.Get(this.Textures.fang_right);
        var head_add_left = TextureManager.Get(this.Textures.head_add_left);
        var head_add_right = TextureManager.Get(this.Textures.head_add_right);


        var ratio = this.width / 512;
        var fang_length = 210 * ratio;
        var fangs = {width: 80, height: 160, angles: [-143, -217], tY: 10 * ratio, textureSpaceY: 3 * ratio};
        var head = {width: 250, height: 512, angles: [-173, -187], tY: 10 * ratio, textureSpaceY: 3 * ratio, tX: 90 * ratio};


        var x = this.x - Camera.xView;
        var y = this.y - Camera.yView;
        var width = this.width;
        var height = this.height;
        var rotation = this.Rotation - 180;
        var alpha = this.Transparency;
        var scale = this.Scale * this.headScale;

        var legAnim = this.legsAnimation.Update();

        //render base
        Graphic.DrawRotatedImage(context, base, x, y, width, height, scale, rotation, alpha);


        //render fangs
        for(var i = 0; i < 2; i++)
		{
            var texture = fang_left;
            var rotAnimDir = -1;
            if(i == 1) 
            {
                texture = fang_right;
                rotAnimDir = 1;
            }

            var angle = 180 + fangs.angles[i];

            var endPoints = [
                x,
                y + fang_length * scale * .95
            ];
            var pos = MathHelper.RotatePoint([x, y], rotation + angle, endPoints);

            var f_width = fangs.width * ratio;
            var f_height = fangs.height * ratio;

			context.save();
			context.translate(pos.x, pos.y);
			context.rotate((rotation + legAnim * rotAnimDir) * Math.PI/180);
			context.globalAlpha = alpha;
			context.drawImage(
				texture, 0, 0, texture.width, texture.height,
				-((f_width / 2)) * scale, -(fangs.tY + fangs.textureSpaceY) * scale,
				(f_width * scale), (f_height * scale)
			);
			context.restore();
		}



        //render head adds
        for(var i = 0; i < 2; i++)
		{
            var texture = head_add_left;
            var rotAnimDir = -1;
            if(i == 1) 
            {
                texture = head_add_right;
                rotAnimDir = 1;
            }

            var angle = 180 + head.angles[i];
            var s = scale * this.headAddsScale;

            var endPoints = [
                x,
                y + fang_length * scale * .95
            ];
            var pos = MathHelper.RotatePoint([x, y], rotation + angle, endPoints);

            var f_width = head.width * ratio;
            var f_height = head.height * ratio;

			context.save();
			context.translate(pos.x, pos.y);
			context.rotate(rotation * Math.PI/180);
			context.globalAlpha = alpha;
			context.drawImage(
				texture, 0, 0, texture.width, texture.height,
				-((f_width / 2)-rotAnimDir * head.tX) * s, -(head.tY + head.textureSpaceY) * s,
				(f_width * s), (f_height * s)
			);
			context.restore();
		}
	}
}
World.RegisterEntity(Celltipede);





class EntityCelltipedePart extends Entity
{
	constructor(x, y, parent, owner)
	{
		super(x, y);
        this.Textures = 
        {
            base: 'bullet.bubble.base',
            leg_left: 'entity.celltipede.leg.left',
            leg_right: 'entity.celltipede.leg.right'
        };

		this.AI.Apply(new AI_Walk());
        this.AI.Apply(new AI_AttackMelee(Player, 0, 1));

		this.RenderTransitions =
		{
			Scale: new Transition(1, 0.95, 0.25, true, 0.02, 0.02)
		};

		this.LootTable = new LootTable([]);

		this.setScale(1);

        this.parent = parent;
        this.shareHP = true;
        // this.showHpBar = false;
        this.Owner = owner;

        this.SPD = this.Owner.SPD;
        this.isMainPart = false;

        this.movementChange = 0;
        this.movementDelay = 0;
        this.hideOnRadar = true;

        this.showDuration = .5;
        this.showTick = 999999;
	}

    onParentDeath()
    {
        this.isMainPart = true;
        this.moveX = 0;
        this.moveY = 0;

        this.getMovement = this.Owner.getMovement;
    }

    onCollision()
    {
        var time = this.ageInTicks-this.movementChange;
        if(time < 5) return;
        this.moveX = 0;
        this.moveY = 0;
    }

    getMovement()
    {
        var target = this.parent;

        var motion = Motion.Get([this.x, this.y], [target.x, target.y], this.SPD);
		this.Rotation = motion.angle + 90 + this.defaultRotation;

        this.moveX = motion.x;
        this.moveY = motion.y;

        this.movementChange = this.ageInTicks;
    }

    Update()
    {
        if(!this.Owner.isAlive) 
        {
            this.Kill();
            return;
        }

        if(!this.parent || !this.parent.isAlive)
        {
            this.onParentDeath();
        }

        // if(!this.moveX && !this.moveY && !this.NoAI && (this.ageInTicks >= this.movementDelay)) this.getMovement();
        var pos = this.Owner.Positions;
        if(pos.length > this.movementDelay)
        {
            var new_x = pos[this.movementDelay][0];
            var new_y = pos[this.movementDelay][1];

            this.Rotation = MathHelper.getAngle2(this, [new_x, new_y])-90;
            this.x = new_x;
            this.y = new_y;
        }


        if(this.ageInTicks >= this.showTick)
        {
            var p = (this.ageInTicks-this.showTick) / (this.showDuration*Main.FPS);
            if(p<=1)
            {
                this.setScale(this.Owner.baseScale * p);
                this.Transparency = p;
            }
        }
        else
        {
            this.setScale(0);
            this.Transparency = 0;
        }

        super.Update();
    }

    onKill()
    {
        this.Transparency = .25;
        this.AI.Delete('AttackMelee');
        this.isAlive = this.Owner.isAlive;
        this.showHpBar = false;
    }




    RenderTexture(context)
	{
        var base = TextureManager.Get(this.Textures.base);
        var leg_left = TextureManager.Get(this.Textures.leg_left);
        var leg_right = TextureManager.Get(this.Textures.leg_right);

        var self_dir = (this.num%2==0) ? 1 : -1;

        var ratio = this.width / 512;
        
        var legs = {width: 340, height: 145, angles: [-90, 90], tY: 80 * ratio, tX: 30 * ratio};

        var x = this.x - Camera.xView;
        var y = this.y - Camera.yView;
        var width = this.width;
        var height = this.height;
        var rotation = this.Rotation - 180;
        var alpha = this.Transparency;
        var scale = this.Scale;

        var legs_length = width/2;

        var legAnim = this.legsAnimation.Update();

        //render base
        Graphic.DrawRotatedImage(context, base, x, y, width, height, scale, 0, alpha);


        //render legs
        for(var i = 0; i < 2; i++)
		{
            var texture = leg_left;
            var rotAnimDir = -1;
            if(i == 1) 
            {
                texture = leg_right;
                rotAnimDir = 1;
            }

            var angle = 180 + legs.angles[i];

            var endPoints = [
                x,
                y + legs_length * scale * .95
            ];
            var pos = MathHelper.RotatePoint([x, y], rotation + angle, endPoints);

            var f_width = legs.width * ratio;
            var f_height = legs.height * ratio;
            var tX = -legs.tX * rotAnimDir * scale;
            if(i==0) tX = (f_width -legs.tX) * rotAnimDir * scale;


			context.save();
			context.translate(pos.x, pos.y);
			context.rotate((rotation + legAnim * self_dir) * Math.PI/180);
			context.globalAlpha = alpha;
			context.drawImage(
				texture, 0, 0, texture.width, texture.height,
				tX, -(f_height/2)-legs.tY * scale,
				(f_width * scale), (f_height * scale)
			);
			context.restore();
		}
	}
}












class EntityCelltipedeTail extends EntityCelltipedePart
{
	constructor(x, y, parent, owner)
	{
		super(x, y, parent, owner);
        this.Textures = 
        {
            base: 'bullet.bubble.base',
            tail_left: 'entity.celltipede.tail.left',
            tail_right: 'entity.celltipede.tail.right'
        };

        this.tailScale = 1.5;
        this.Weakness[ELEMENT.PHYSICAL] = true;
	}

    RenderTexture(context)
	{
        var base = TextureManager.Get(this.Textures.base);
        var tail_left = TextureManager.Get(this.Textures.tail_left);
        var tail_right = TextureManager.Get(this.Textures.tail_right);

        var ratio = this.width / 512;
        var tail = {width: 190, height: 512, angles: [-160, -200], tY: 10 * ratio, textureSpaceY: 3 * ratio, tX: 60 * ratio};

        var x = this.x - Camera.xView;
        var y = this.y - Camera.yView;
        var width = this.width;
        var height = this.height;
        var rotation = this.Rotation - 180;
        var alpha = this.Transparency;
        var scale = this.Scale;

        var tail_length = width/2;

        //render base
        Graphic.DrawRotatedImage(context, base, x, y, width, height, scale, 0, alpha);

        //render tail
        for(var i = 0; i < 2; i++)
		{
            var texture = tail_left;
            var rotAnimDir = -1;
            if(i == 1) 
            {
                texture = tail_right;
                rotAnimDir = 1;
            }

            var angle = 180 + tail.angles[i];
            var s = scale * this.tailScale;

            var endPoints = [
                x,
                y + tail_length * scale * .95
            ];
            var pos = MathHelper.RotatePoint([x, y], rotation + angle, endPoints);

            var f_width = tail.width * ratio;
            var f_height = tail.height * ratio;

			context.save();
			context.translate(pos.x, pos.y);
			context.rotate(rotation * Math.PI/180);
			context.globalAlpha = alpha;
			context.drawImage(
				texture, 0, 0, texture.width, texture.height,
				-((f_width / 2)-rotAnimDir * tail.tX) * s, -(tail.tY + tail.textureSpaceY) * s,
				(f_width * s), (f_height * s)
			);
			context.restore();
		}
	}
}class TheCoveGuardian extends EntityCoveFishPoison
{
	constructor(x, y)
	{
		super(x, y);
		
		this.name = "ENTITY.THE_COVE_GUARDIAN.NAME";
		this.Texture = "entity.cove.fish.thunder.base";

		this.MAXHP = 3500;
		this.HP = this.MAXHP;
		this.AD = 50;
        this.ATTACK_RANGE = 1900;
		this.FOLLOW_RANGE = 500;
        this.BULLET_SPEED = 2000;
		this.SPD = 200;

        this.AI.Apply(new AI_Boss(this));
        this.AI.Apply(new AI_Enrage(this, 50));

		this.LootTable = new LootTable([
			new LootTableItemData("Topaz1", 50, 1, 1)
		]);

        this.enragedAnimationDuration = 4 * Main.FPS;

        this.specialAttackDelay = 4 * Main.FPS;
        this.specialAttackDuration = 4 * Main.FPS;

        this.lastSpecialAttack = 30;
        this.summoned = null;

        this.Immunity[ELEMENT.POISON] = false;
        this.Immunity[ELEMENT.THUNDER] = true;

		this.setScale(8);
	}

    specialAttack()
    {
        this.allowMove = false;

        if(this.isEnraged)
        {
            if(this.specialAttackTimes%10==3) return this.specialAttackSummons();
            if(this.specialAttackTimes%2==1) return this.specialAttackStorm();
            this.specialAttackSpark();
        }
        else
        {
            if(this.specialAttackTimes%10==3) return this.specialAttackSummons();
            this.specialAttackSpark();
        }
    }

    specialAttackSummons()
    {
        if(!this.summoned)
        {
            this.killLightning = false;

            var angle = MathHelper.randomInRange(0, 360);
            var r = 70 * this.Scale;

            var pos1 = MathHelper.lineToAngle(this, r, angle);
            var pos2 = MathHelper.lineToAngle(this, r, angle+120);
            var pos3 = MathHelper.lineToAngle(this, r, angle+240);

            var entity1 = new EntityCoveFishPoison(pos1.x, pos1.y);
                entity1.NoAI = true;
                entity1.Transparency = 0;
                entity1.isHurtAble = false;
            var entity2 = new EntityCoveFishFire(pos2.x, pos2.y);
                entity2.NoAI = true;
                entity2.Transparency = 0;
                entity2.isHurtAble = false;
            var entity3 = new EntityCoveFishIce(pos3.x, pos3.y);
                entity3.NoAI = true;
                entity3.Transparency = 0;
                entity3.isHurtAble = false;

            World.AddEntity(entity1);
            World.AddEntity(entity2);
            World.AddEntity(entity3);

            this.summoned = [entity1, entity2, entity3];

            var data = {fromTy: this.height * .25 * this.baseScale};
            World.AddParticle(new ParticleLightning(this, entity1, data));
            World.AddParticle(new ParticleLightning(this, entity2, data));
            World.AddParticle(new ParticleLightning(this, entity3, data));
        }
        else
        {
            for(var i in this.summoned)
            {
                var e = this.summoned[i];
                e.Transparency = this.specialAttackTick/this.specialAttackDuration;
            }
        }
    }

    onSpecialAttackEnd()
    {
        super.onSpecialAttackEnd();
        if(this.summoned)
        {
            for(var i in this.summoned)
            {
                var e = this.summoned[i];
                e.NoAI = false;
                e.isHurtAble = true;
            }
            this.summoned = null;
            this.killLightning = true;
        }
    }

    onKill()
    {
        if(this.summoned)
        {
            for(var i in this.summoned)
            {
                var e = this.summoned[i];
                e.Kill();
            }
        }
    }

    specialAttackStorm()
    {
        var delay = 1;
        if(this.specialAttackTick%delay == 0)
        {
            var pos = MathHelper.getRandomPointInRange(World.CenterPoint, World.Radius-50);

            var stats = {};
                stats.spd = 0;
                stats.Scale = 10;
                stats.damage = this.AD*2;
                stats.damage = 1;
                stats.knockBack = 0;
                stats.x = pos.x;
                stats.y = pos.y;
                stats.Type = 'ExplosionLightningStrike';
                stats.onPlayerCollisionEffects = [['Stun', 1, 2, false]];
                stats.onEntityCollisionEffects = [['Stun', 1, 2, false]];

            AI_ShotOnCircle.StaticShoot(this, stats, 1);
        }
    }

    specialAttackSpark()
    {
        var delay = 5;
        if(this.specialAttackTick%delay == 0)
        {
            var bullets = 1;
            var s = MathHelper.randomInRange(50, 150)/100;
            var angle = MathHelper.getAngle2(this, World.Player) + MathHelper.randomInRange(-60, 60);
            var range = MathHelper.GetDistance(this, World.Player) * 1.5;
            var y = this.y;
            this.y += this.height * .25 * this.baseScale;

            var stats = {};
                stats.spd = this.BULLET_SPEED;
                stats[STAT.ATTACK_RANGE] = range * (s/2);
                stats.Scale = 2 * this.Scale * s;
                stats.damage = this.AD*s;
                stats.knockBack = 0;
                stats.Type = 'CoveGuardianSpark';

            AI_ShotOnCircle.StaticShoot(this, stats, bullets, {angle: angle});

            this.y = y;
        }
    }

    RenderTexture(context)
    {
        if(this.isEnraged)
        {
            var texture = TextureManager.Get('spark_circle');

            var x = this.x - Camera.xView;
            var y = this.y - Camera.yView;

            var scale = 1.3 * this.Scale;
            var rotation = MathHelper.randomInRange(0, 360);

            Graphic.DrawRotatedImage(context, texture, x, y, this.width, this.height, scale, rotation, this.Transparency*.5);
        }

        super.RenderTexture(context);
    }
}
World.RegisterEntity(TheCoveGuardian);class TheDestroyer extends Entity
{
	constructor(x, y)
	{
		super(x, y);
		
		this.name = "ENTITY.DESTROYER.NAME";
        this.BossTheme = "interface.BossFight2";

        this.Textures = 
        {
            back: 'entity.destroyer.back.sprite',
            eyes: 'entity.destroyer.eyes',
            helmet: 'entity.destroyer.helmet'
        };
        this.allowRotationChange = false;

		this.MAXHP = 5000;
		this.HP = this.MAXHP;
		this.AD = 20;
		this.ATTACK_SPEED = .25;
		this.SPD = 700;

		this.ATTACK_RANGE = 1000;
		this.FOLLOW_RANGE = 1000;
		this.BULLET_SPEED = 900;

        this.AI.Apply(new AI_Wander(false, 4, 8, {updateTrigger: function(o){return o.isEnraged}}));
        this.AI.Apply(new AI_AttackMelee(Player, 0, 2));
        this.AI.Apply(new AI_Boss(this));
        this.AI.Apply(new AI_Enrage(this, 50));
        // this.AI.Apply(new AI_HpBracketEvents(this, [new HpBracketEvent(95, ()=>this.OpenShields())]));

        var s = Main.FPS;
        this.AI.Apply(new AI_SpecialAttack(this, {CoolTime: 10*s, PreparationTime: 4*s, Duration: 5*s, Delay: 3*s, updateTrigger: function(o){return o.visible}}));
        this.AI.Apply(new AI_Walk(false));


        this.AI.Apply(new AI_Dash(this, Player, false, 3, 3, {dashMultiplier: 5, dashDuration: 15, updateTrigger: function(o){return !o.isPreparingJump}}));

		this.RenderTransitions =
		{
			Scale: new Transition(1, 0.95, 0.25, true, 0.02, 0.02)
		}
        this.enragedAnimationDuration = 4 * s;

		this.setScale(3);

        this.Childs = [];
        this.Shields = [];

        this.Positions = [];
        this.eyesAlpha = 1;

        this.knockBackResistance = 1;
        this.Resistance[ELEMENT.PHYSICAL] = true;
        this.Immunity.SLOW = true;
        this.Immunity.STUN = true;

        this.laserIndicatorTime = Main.FPS * .5;
        
        this.specialAttackTimes = 0;
        this.helmetFrames = [5, 3];
        this.helmetFrame = 0;
        this.backFrame = 0;
        this.helmetAnimDuration = (this.helmetFrames[0] * this.helmetFrames[1]) * 4;

        this.LightningData = {RENDER_LAYER: Graphic.Layer.Particle0, GlowColor: '#D80000'};

        this.LootTable = new LootTable([new LootTableItemData('TreasureOrbCelltipede', 100, 1, 1)]);

        this.dashes = 0;
        this.killOnBorderOut = false;

        this.jumpShadowData = 
        {
            baseScale: this.baseScale,
            SPD: this.SPD
        };
	}

    onDashEnd()
    {
        this.dashes++;

        if(this.dashes%4 == 0) 
        {
            this.timeToFall = this.ageInTicks + MathHelper.randomInRange(240, 300);
            this.jumpStart = this.ageInTicks;
            this.isPreparingJump = true;
            this.shadow = new EntityShadow(this.x, this.y, this, this.jumpShadowData);
            this.shadow.AI.Apply(new AI_Follow(World.Player, false));

            World.AddEntity(this.shadow, true);
        }
    }

    onSummon()
    {
        this.CreateParts();
    }

    OpenShields()
    {
        this.NoAI = true;
        this.visible = true;

        for(var i in this.Shields)
        {
            this.Shields[i].Open();

            World.AddParticle(new ParticleLightning(this, this.Shields[i], this.LightningData));
        }

        for(var i in this.Childs)
        {
            this.Childs[i].Open();

            if(i == 0) World.AddParticle(new ParticleLightning(this, this.Childs[i], this.LightningData));
            if(i == 1) World.AddParticle(new ParticleLightning(this.Childs[0], this.Childs[i], this.LightningData));
        }



       this.shootLightningSphere();
    }

    shootLightningSphere()
    {
        var bullets = 40;

        var stats = {};
            stats.spd = 1000;
            stats.damage = this.AD;
            stats.element = ELEMENT.THUNDER;
            stats[STAT.ATTACK_RANGE] = 9999;
            stats.Scale = 1;
            stats.knockBack = 5;
            stats.lightningChain = true;
            stats.isHidden = true;
            stats.Pierce = 999;
            stats.Bounce = 3;
            stats.moveParticle = null;
            stats.noKillParticle = true;

        AI_ShotOnCircle.StaticShoot(this, stats, bullets);

        var projectile_id = 0;
        var data = {...this.LightningData};
            data.segments = 5;
            data.maxVariation = 10;
        for(var i = 0; i < World.Projectiles.length; i++)
        {
            var p = World.Projectiles[i];
            if(p.lightningChain == true)
            {
                if(projectile_id == 0) World.AddParticle(new ParticleLightning(World.Projectiles[i+(bullets-1)], p, data));
                else World.AddParticle(new ParticleLightning(World.Projectiles[i-1], p, data));

                projectile_id++;
            }
        }
    }

    ShieldsReady()
    {
        this.NoAI = false;
    }

    Enrage()
    {
        this.AI.Delete('Dash');
    }

    onEnrageAnimationEnd()
    {
        this.OpenShields();

        this.specialAttackTimes = 0;
        this.AI.SpecialAttack.setCoolTime();

        for(var i in this.Shields)
        {
            this.Shields[i].usingSaws = false;
            this.Shields[i].SawsPreparationProgress = 0;
        }
    }

    CreateParts()
    {
        this.Childs = [];
        this.Shields = [];


        var e, i;
        for(i = 0; i < 2; i++)
        {
            e = new DestroyerShield(this.x, this.y, this);
            e.ID = i;

            this.Shields.push(e);
            World.AddEntity(e);
        }


        for(i = 0; i < 2; i++)
        {
            e = new DestroyerBodyPart(this.x, this.y, this, i);

            this.Childs.push(e);
            World.AddEntity(e, false);
        }
    }

    highJumpUpdate()
    {
        this.isHurtAble = false;
        var fallDuration = 15;

        var destination = World.CenterPoint.y - (World.Radius * 2)
        if(this.y > destination && this.ageInTicks < this.timeToFall)
        {
            this.y -= this.SPD * 4 * Main.DELTA;

            var m = ((this.ageInTicks-this.jumpStart) / 60);
            if(m > 1) m = 1;
            this.shadow.setScale(this.baseScale * (1+m));

            this.shadow.Transparency = .5 - (m * .2);
        }
        
        if(this.ageInTicks == this.timeToFall)
        {
            this.shadow.NoAI = true;
            this.x = this.shadow.x;
            this.fallStep = (this.shadow.y - this.y) / fallDuration;
        }

        if(this.ageInTicks > this.timeToFall)
        {
            this.y += this.fallStep;

            var m = (1-((this.ageInTicks-this.timeToFall) / fallDuration));
            this.shadow.setScale(this.baseScale * (1+m));

            this.shadow.Transparency = .5 - (m * .2);
        }

        if(this.ageInTicks == this.timeToFall+fallDuration)
        {
            this.isPreparingJump = false;
            this.isHurtAble = true;

            this.shadow.Kill();
            this.shadow = null;
            this.onHighJumpEnd();
        }
    }

    onHighJumpEnd()
    {
        // console.log('end');
    }

	Update()
	{
		super.Update();

        if(this.toDashProgress >= 80)
		{
			this.allowMove = false;
			this.isPreparingDash = true;
		}
		else
		{
			this.allowMove = true;
			this.isPreparingDash = false;
		}

        if(this.isPreparingJump) this.highJumpUpdate();

        if(this.lastAttackAnim == 'LASER')
        {
            var frames = this.helmetFrames[0] * this.helmetFrames[1];
            var eyes_alpha_duration = 60;
            var a = this.specialAttackCoolTimeTick / eyes_alpha_duration;
            var p = this.specialAttackCoolTimeTick / this.helmetAnimDuration;
            if(p > 1) 
            {
                p = 1;
                this.lastAttackAnim = null;
            }

            this.eyesAlpha = (a < 1) ? a : 1;
            this.helmetFrame = Math.floor((1-p) * (frames-1));
            this.backFrame = this.helmetFrame;
        }
	}

    specialAttackEnd()
    {
        this.lastAttack = this.getCurrentAttackType();
        this.lastAttackAnim = this.lastAttack

        this.specialAttackTimes++;
        this.allowMove = true;
        this.helmetFrame = 0;
        this.eyesAlpha = 1;
        this.backFrame = 0;
    }

    getCurrentAttackType()
    {
        return 'LASER';
        var time = this.specialAttackTimes;
        var attacks = 2;

        if(this.isEnraged)
        {
            attacks++;

            if(time%attacks == 0) return 'LASER';
            if(time%attacks == 1) return 'SAWS';
            if(time%attacks == 2) return 'OBSTACLES';
        }

        if(time%attacks == 0) return 'SAWS';
        if(time%attacks == 1) return 'SAWS';
    }

    specialAttackPreparationUpdate()
    {
        if(this.getCurrentAttackType() == 'SAWS') 
        {
            this.allowMove = false;
            for(var i in this.Shields)
                this.Shields[i].PrepareSaws(this.specialAttackPreparationProgress);
        }

        if(this.getCurrentAttackType() == 'LASER') 
        {
            var eyes_alpha_duration = 60;
            var a = this.specialAttackPreparationTick / eyes_alpha_duration;
            this.eyesAlpha = (a < 1) ? (1-a) : 0;

            if(a >= 1)
            {
                var frames = this.helmetFrames[0] * this.helmetFrames[1];
                var p = (this.specialAttackPreparationTick-eyes_alpha_duration) / this.helmetAnimDuration;
                if(p > 1) 
                {
                    var f = (this.specialAttackPreparationTick-eyes_alpha_duration-this.helmetAnimDuration) / (this.helmetAnimDuration * 2);
                    if(f > 1) f = 1;
                    this.backFrame = Math.floor(f* (frames-1));
                    p = 1;
                }
                this.helmetFrame = Math.floor(p * (frames-1));
            }


            if(this.specialAttackPreparationTick + this.laserIndicatorTime == this.AI.SpecialAttack.PreparationTime) this.showLaserIndicator();

            var angle = MathHelper.getAngle2(World.Player, this)-90;
            this.Rotation = angle%360;
        }
    }

    specialAttackUpdate()
    {
        this.allowMove = false;
        if(this.getCurrentAttackType() == 'SAWS') 
        {
            for(var i in this.Shields)
                this.Shields[i].UpdateSaws(this.specialAttackProgress);
        }

        if(this.getCurrentAttackType() == 'LASER') this.specialAttackLaser();
    }


    getLaserStats()
    {
        var stats = {};
            stats.damage = this.AD;
            stats.Pierce = 999;
            stats.Type = 'BulletLaserBeam';
            stats.Textures = 
            {
                start: 'projectile.laser.destroyer.start',
                mid: 'projectile.laser.destroyer.mid',
                end: 'projectile.laser.destroyer.end'
            };
            stats.laserDuration = 5 * Main.FPS;
            stats.element = ELEMENT.FIRE;
            stats.size = 100;
            // stats.visibleSizeTransition = false;
            stats.allowSelfRotationChange = false;
            stats.rotationSpeed = 30;
            stats.hurtDelay = 15;
            stats.hurtEntities = true;
            stats.RENDER_LAYER = Graphic.Layer.LightLevel2;

        return stats;
    }

    specialAttackLaser()
    {
        var angle = MathHelper.getAngle2(World.Player, this)-90;
        this.Rotation = angle%360;

        if(this.specialAttackTick == 1)
        {
            var bullets = 1;
            var stats = this.getLaserStats();

            AI_ShotOnCircle.StaticShoot(this, stats, bullets, {angle: angle});
        }
    }

    showLaserIndicator()
    {
        var angle = MathHelper.getAngle2(World.Player, this)-90;
        this.Rotation = angle%360;

        var stats = this.getLaserStats();
            stats.laserDuration = this.laserIndicatorTime * 1.2;
            stats.size = 10;
            stats.damage = 0;
            stats.Transparency = .5;
            stats.rotationSpeed = 180;

        AI_ShotOnCircle.StaticShoot(this, stats, 1, {angle: angle});
    }

    RenderTexture(context)
	{
        var x = this.x - Camera.xView;
        var y = this.y - Camera.yView;

        var width = this.width;
        var height = this.height;
        var rotation = 0;

        var alpha = (this.visible) ? this.Transparency : 0;
        

        Graphic.DrawRotatedAnimatedImage(context, this.backFrame, this.helmetFrames, 'XY', 
            TextureManager.Get(this.Textures.back), x, y, width, height, this.Scale, rotation, alpha
        );

        Graphic.DrawRotatedAnimatedImage(context, 0, 1, 'Y', 
            TextureManager.Get(this.Textures.eyes), x, y, width, height, this.Scale, rotation, this.eyesAlpha * alpha
        );

        Graphic.DrawRotatedAnimatedImage(context, this.helmetFrame, this.helmetFrames, 'XY', 
            TextureManager.Get(this.Textures.helmet), x, y, width, height, this.Scale, rotation, alpha
        );
	}
}
World.RegisterEntity(TheDestroyer);







class DestroyerShield extends Entity
{
	constructor(x, y, owner)
	{
		super(x, y);
		this.Owner = owner;
        this.ID = 0;
		
		this.name = "ENTITY.DESTROYER.SHIELD";
		this.Texture = 'entity.destroyer.shield';

		this.MAXHP = 1;
		this.HP = this.MAXHP;
		
		this.HitBox.Scale = .8;

		this.knockBackResistance = 1;

		this.Immunity.ALL = true;
		this.hideOnRadar = true;
        this.blockPierce = true;

        this.Frames = [1, 1];

        this.translate = {x: 0, y: 0};

        this.OpeningDuration = 5 * Main.FPS;
        this.isOpening = false;
        this.openAnimationStart = 0;
        this.isOpen = false;
        this.OpenTranslate = {x: -45, y: 15};
        this.OpenTranslate1 = {x: 45, y: 15};

        this.SawScale = 1.5;
        this.killOnBorderOut = false;
	}

    PrepareSaws(p)
    {
        this.SawsPreparationProgress = p;
    }

    UpdateSaws(p)
    {
        this.SawsAttackProgress = p;
        this.usingSaws = true;

        var delay = 3;
        if(this.ageInTicks%delay == 0)
        {
            var bullets = 1;
            var angle = this.Rotation;
            if(this.ID == 0) angle += 180;

            var stats = {};
                stats.spd = 1000;
                stats.Scale = this.SawScale;
                stats.damage = 10;
                stats.knockBack = 0;
                stats.Type = 'BulletSaw';

            AI_ShotOnCircle.StaticShoot(this, stats, bullets, {angle: angle});
        }

        if(p >= 1)
        {
            this.SawsPreparationProgress = 0;
            this.usingSaws = false;
            this.Rotation = 0;
        }
    }

	Update()
	{
        var s = this.Owner.baseScale;
        var tX = (this.width/8.1) * this.Scale * ((this.ID == 0) ? -1 : 1);

        if(!this.usingSaws)
        {
            this.x = this.Owner.x + (this.translate.x * s);
            this.y = this.Owner.y + (this.translate.y * s);
            this.Scale = this.Owner.Scale * 1.2;

            this.x += tX
        }
        else
        {
            var r = tX + this.translate.x * s;
            var rotation = (this.SawsAttackProgress * 360 * 3);
            this.Rotation = rotation;

            var end = MathHelper.lineToAngle([this.Owner.x, this.Owner.y], r, rotation);
            this.x = end.x;
            this.y = end.y;
        }

		super.Update();
        if(this.isOpening) this.OpenAnimationUpdate();
        this.isHurtAble = this.isOpen;

		if(!this.Owner.isAlive) this.Kill();
	}


	Hurt(damage, source)
	{
        if(source == this.Owner) return;

		if(Settings.General.ShowDamageDealt)
		{
			DamageIndicator.AddObject(this.x, this.y, Lang.Get('TEXT.BLOCK'), "DEALT", null);
		}
	}

    Open()
    {
        if(this.isOpen) return;
        this.isOpening = true;
        this.openAnimationStart = this.ageInTicks;
    }

    OpenAnimationUpdate()
    {
        var p = (this.ageInTicks - this.openAnimationStart) / this.OpeningDuration;
        if(p >= 1)
        {
            this.translate = (this.ID == 0) ? this.OpenTranslate : this.OpenTranslate1;
            this.isOpening = false;
            this.isOpen = true;
            this.Owner.ShieldsReady();
            return;
        }

        var t = (this.ID == 0) ? this.OpenTranslate : this.OpenTranslate1;

        var startAnimY = .75;
        var animYp = (p - startAnimY) * 4;
        if(animYp < 0) animYp = 0;

        this.translate.x = t.x * p;
        this.translate.y = t.y * animYp;
    }

    RenderTexture(context)
	{
        this.Scale = this.Owner.Scale * 1.2;

        var texture = TextureManager.Get(this.Texture);
        var x = this.x - Camera.xView;
        var y = this.y - Camera.yView;

        var width = this.width/2;
        var height = this.height;
        var rotation = this.Rotation;
        var tX = width/4;

        var alpha = this.Owner.Transparency;
       
        var frame = 0;

        var data = {clipWidth: -texture.width/2};
        if(this.ID == 1) 
        {
            data.startX = data.clipWidth * -1;
            tX *= -1;
        }



        if(this.SawsPreparationProgress && !this.usingSaws) 
        {
            var p = this.SawsPreparationProgress + .25;
            if(p > 1) p = 1;
            var sawTx = width * 1.5 * p;
            if(this.ID == 1) sawTx *= -1;
            Graphic.DrawRotatedImage(context, TextureManager.Get('projectile.saw'), x, y, 64, 64, this.SawScale, 0, 1, sawTx);
        }
        

		Graphic.DrawRotatedAnimatedImage(context, frame, this.Frames, 'XY', 
            texture, x, y, width, height, this.Scale, rotation, alpha, tX, 0, null, data
        );  
	}
}
World.RegisterEntity(DestroyerShield);







class DestroyerBodyPart extends Entity
{
	constructor(x, y, owner, id = 0)
	{
		super(x, y);
		this.Owner = owner;
        this.ID = id;
		
		this.name = "ENTITY.DESTROYER.PART";
		this.Texture = 'entity.destroyer.shield';

		this.MAXHP = 1;
		this.HP = this.MAXHP;
		
		this.HitBox.Scale = .8;

		this.knockBackResistance = 1;

		this.Immunity.ALL = true;
		this.hideOnRadar = true;

        this.Frames = [1, 1];
        this.isHurtAble = false;

        this.translate = {x: 0, y: 0};

        this.OpeningDuration = 5 * Main.FPS;
        this.isOpening = false;
        this.openAnimationStart = 0;
        this.isOpen = false;
        this.OpenTranslate = {x: 0, y: 45};
        this.OpenTranslate1 = {x: 0, y: 70};

        this.killOnBorderOut = false;

        this.transitionX =  new Transition(-2, 2, .5, true, 0.02, 0.02);
        if(id == 1) this.transitionX =  new Transition(5, -5, .5, true, 0.02, 0.02);
	}


	Update()
	{
        var s = this.Owner.baseScale;

		this.x = this.Owner.x + (this.transitionX.Update() * s);
		this.y = this.Owner.y + (this.translate.y * s);

		super.Update();
        if(this.isOpening) this.OpenAnimationUpdate();
        

		if(!this.Owner.isAlive) this.Kill();
	}

    Open()
    {
        if(this.isOpen) return;
        this.isOpening = true;
        this.openAnimationStart = this.ageInTicks;
    }

    OpenAnimationUpdate()
    {
        var p = (this.ageInTicks - this.openAnimationStart) / this.OpeningDuration;
        if(p >= 1)
        {
            this.translate = (this.ID == 0) ? this.OpenTranslate : this.OpenTranslate1;
            this.isOpening = false;
            this.isOpen = true;
            return;
        }

        var t = (this.ID == 0) ? this.OpenTranslate : this.OpenTranslate1;

        this.translate.y = t.y * p;
    }

    RenderTexture(context)
	{
        this.Scale = this.Owner.Scale * ((this.ID == 0) ? .6 : .3);

        var texture = TextureManager.Get(this.Texture);
        var x = this.x - Camera.xView;
        var y = this.y - Camera.yView;

        var width = this.width;
        var height = this.height;
        var rotation = 0;

        var alpha = (this.Owner.visible) ? this.Owner.Transparency : 0;
       
        var frame = 0;

		Graphic.DrawRotatedAnimatedImage(context, frame, this.Frames, 'XY', 
            texture, x, y, width, height, this.Scale, rotation, alpha
        );
	}
}
World.RegisterEntity(DestroyerBodyPart);



class Frogo extends EntityFrog
{
	constructor(x, y, isBoss = true)
	{
		super(x, y);
		
		this.name = "ENTITY.FROGO.NAME";
        this.Rotation = 180;

		this.MAXHP = 1600;
		this.HP = this.MAXHP;
		this.AD = 20;
		this.SPD = 100;

        this.ATTACK_SPEED = 1;
        this.ATTACK_RANGE = 9999;
        this.BULLET_SPEED = 6000;

        this.JumpDuration = .5;
        this.JumpDelay = 3;
        this.JumpDistance = this.SPD * 5;
        this.shakeOnJump = 3;
        this.jumps = 0;
        this.rageJumps = 4;

        this.isAttackingWithTongue = false;


        this.enragedAnimationDuration = 4 * Main.FPS;

        var bulletStats = 
		{
			Type: "BulletFrogTongue",
			Scale: 1,
            damage: 0
		};


        this.AI.Apply(new AI_Jump(false, this.JumpDelay, this.JumpDelay, Player));
		this.AI.Apply(new AI_AttackMelee(Player, 0, 2));
        this.AI.Apply(new AI_Observe(Player, 999999, function(owner){return owner.aggressive && !owner.isJumping}));
		this.AI.Apply(new AI_Walk());
        this.AI.Apply(new AI_AttackRange(World.Player, bulletStats, {shootTrigger: function(o){return o.isAttackingWithTongue}}));
        if(isBoss)
        {
            this.AI.Apply(new AI_Boss(this));
            this.AI.Apply(new AI_Enrage(this, 50));
        }
        
       

		this.LootTable = new LootTable([new LootTableItemData('TreasureOrbFrogo', 100, 1, 1)]);


        this.BossTheme = "interface.BossFight2";


        this.modelTextureF = 'entity.frogo.';
        this.modelTextureEnragedF = 'entity.frogo.enraged.';
        this.Model = new EntityFrogModel(this, 'entity.frogo.');

        this.defaultScale = 7;
        this.setScale(this.defaultScale);  
	}

    onJumpEnd()
    {
        var stats = {};
			stats.spd = 800;
			stats.damage = this.AD/2;
			stats[STAT.ATTACK_RANGE] = 9999;
			stats.Scale = 2;
            stats.knockBack = 2;

		if(this.isBoss) AI_ShotOnCircle.StaticShoot(this, stats, 16);

        this.jumps++;

        if(this.isEnraged)
        {
            if(this.jumps && this.jumps%this.rageJumps == 0) this.JumpDelay = 4;
            else this.JumpDelay = 1;

            if((this.jumps-1)%this.rageJumps == 0) 
            {
                this.AI.AttackRange.attackCharge = 0;
                this.isAttackingWithTongue = true;
            }
        }
    }

    onJumpStart()
    {
        this.isAttackingWithTongue = false;
    }

    Enrage()
    {
        this.isJumping = false;
        this.additionalScaleMultiplier = 1;
        this.AI.Jump.timeSinceChange = 0;
        this.AI.Jump.end = null;
        this.jumps = 1;
        this.JumpDelay = 1;

        var stats = {};
			stats.spd = 1000;
			stats.damage = this.AD;
			stats[STAT.ATTACK_RANGE] = 9999;
			stats.Scale = 3;
            stats.knockBack = 10;

        if(Difficulty(2))
        {
            this.Resistance[ELEMENT.PHYSICAL] = true;
            stats.damage = this.AD * 3;
        }
        
		AI_ShotOnCircle.StaticShoot(this, stats, 64);
        Camera.Shake(2, true, 25);
    }

    onEnrageAnimationProgress()
    {
        var new_scale = this.defaultScale + (2 * this.enrageAnimationProgress);
        this.setScale(new_scale);
    }

    onEnrageAnimationEnd()
    {
        this.Model.textureFamily = this.modelTextureEnragedF;
    }

    Render(context)
    {
        super.Render(context);

        if(this.isEnraged && this.lockAI)
        {
            this.Model.textureFamily = this.modelTextureEnragedF;
            this.Model.Transparency = this.enrageAnimationProgress;
            this.Model.Render(context);
            this.Model.textureFamily = this.modelTextureF;
        }
    }
}
World.RegisterEntity(Frogo);class LakeSpiderQueen extends Entity
{
	constructor(x, y)
	{
		super(x, y);
		
		this.name = "ENTITY.SPIDER.LAKE.QUEEN.NAME";
		this.description = "ENTITY.SPIDER.LAKE.QUEEN.DESCRIPTION";
		this.Title = "";

        this.defaultRotation = 180;

		this.MAXHP = 2500;
		this.HP = this.MAXHP;
		this.AD = 20;
		this.ATTACK_SPEED = 1.5;
        this.ATTACK_RANGE = 10000;
		this.FOLLOW_RANGE = 9999;
		this.ATTACK_RANGE_MIN = this.FOLLOW_RANGE;
        this.BULLET_SPEED = 950;
		this.SPD = 750;
		

		this.AI.Apply(new AI_AttackMelee(Player, this.AD));
        this.AI.Apply(new AI_Follow(World.Player, true, function(owner){return !owner.isPreparingDash;}));
		this.AI.Apply(new AI_Walk());
		this.AI.Apply(new AI_Observe(World.Player, this.FOLLOW_RANGE, function(owner){return owner.isPreparingDash;}))
		this.AI.Apply(new AI_LayEgg(3, 3, 3, 'EntityLakeEgg', {Scale: 2, entityCount: 9, timeToHatch: 15}, {eggTranslateY: 50}));
		this.AI.Apply(new AI_Boss(this));
		this.AI.Apply(new AI_Enrage(this, 50));


        this.RenderTransitions =
		{
			Scale: new Transition(1, 0.95, 0.25, true, 0.02, 0.02)
		};

		this.HitBox.Scale = .65;

		var bodyHitBox = new HitBox();
			bodyHitBox.Scale = this.HitBox.Scale * 2.2;
			bodyHitBox.translationY = -0.72;

		this.advancedHitBox.push(bodyHitBox);

        this.BossTheme = "interface.BossFight2";

        this.Model = new SpiderQueenModel(this);
		this.setScale(3);

        this.enragedAnimationDuration = 4 * Main.FPS;
		this.isPreparingDash = false;

		this.invincibleScale = 3;

		this.LootTable = new LootTable([new LootTableItemData('TreasureOrbAquamantula', 100, 1, 1)]);
    }

	Update()
	{
		super.Update();

		if(this.isLayingEgg)
		{
			this.allowMove = false;
			this.allowRotationChange = false;
			this.Rotation = 0;
		}
		else
		{
			this.allowMove = true;
			this.allowRotationChange = true;
		}

		if(this.isEnraged) this.EnrageUpdate();
	}


	Enrage()
    {
		this.isLayingEgg = false;

		this.AI.Apply(new AI_Dash(this, Player, false, 5, 5, {dashMultiplier: 5, dashDuration: 15, dashesInRow: 4, dashesInRowDelay: 20}));
		this.AI.Delete('LayEgg');
    }


    EnrageUpdate()
    {
		if(this.isDashing) this.allowRotationChange = false;
		else this.allowRotationChange = true;

		if(this.toDashProgress >= 80)
		{
			this.allowMove = false;
			this.isPreparingDash = true;
		}
		else
		{
			this.allowMove = true;
			this.isPreparingDash = false;
		}
    }

	onDashCollision()
	{
		var stun_duration = 2;
		ApplyEffect(this, 'Stun', 1, stun_duration);
		this.AI.Dash.setCoolTime(null, stun_duration*Main.FPS);
	}
}
World.RegisterEntity(LakeSpiderQueen);





class SpiderQueenModel extends ModelBase
{
	constructor(owner, textureFamily = '')
	{
		super(owner, textureFamily);

		this.Width = 2048;
		this.Height = 2048;

		this.Scale = 0.125;
		// this.Offset.x = -256;
		// this.Offset.y = -256;

		var body = new Part(512, 512, 100);
		body.SetTexture("entity.spider.queen.base", 512, 512);
		body.SetTextureRender(38, 1);
		body.SetRotation(0, 256, 256);

		var leg_right_3_pivot = new Part(20, 190, 100);
		leg_right_3_pivot.SetTexture("hand", 20, 100);
		leg_right_3_pivot.SetTextureRender(0, 1);
		leg_right_3_pivot.SetRotation(-80, 10, 10);
		leg_right_3_pivot.visible = false;

		var leg_right_4_pivot = new Part(20, 190, 100);
		leg_right_4_pivot.SetTexture("hand", 20, 100);
		leg_right_4_pivot.SetTextureRender(1, 2);
		leg_right_4_pivot.SetRotation(-60, 10, 10);
		leg_right_4_pivot.visible = false;

		var leg_right_2_pivot = new Part(20, 190, 100);
		leg_right_2_pivot.SetTexture("hand", 20, 100);
		leg_right_2_pivot.SetTextureRender(2, 3);
		leg_right_2_pivot.SetRotation(-100, 10, 10);
		leg_right_2_pivot.visible = false;

		var leg_right_1_pivot = new Part(20, 190, 100);
		leg_right_1_pivot.SetTexture("hand", 20, 100);
		leg_right_1_pivot.SetTextureRender(3, 4);
		leg_right_1_pivot.SetRotation(-120, 10, 10);
		leg_right_1_pivot.visible = false;

		var leg_left_1_pivot = new Part(20, 190, 100);
		leg_left_1_pivot.SetTexture("hand", 20, 100);
		leg_left_1_pivot.SetTextureRender(4, 5);
		leg_left_1_pivot.SetRotation(-240, 10, 10);
		leg_left_1_pivot.visible = false;

		var leg_left_2_pivot = new Part(20, 190, 100);
		leg_left_2_pivot.SetTexture("hand", 20, 100);
		leg_left_2_pivot.SetTextureRender(5, 6);
		leg_left_2_pivot.SetRotation(-260, 10, 10);
		leg_left_2_pivot.visible = false;

		var leg_left_3_pivot = new Part(20, 190, 100);
		leg_left_3_pivot.SetTexture("hand", 20, 100);
		leg_left_3_pivot.SetTextureRender(6, 7);
		leg_left_3_pivot.SetRotation(80, 10, 10);
		leg_left_3_pivot.visible = false;

		var leg_left_4_pivot = new Part(20, 190, 100);
		leg_left_4_pivot.SetTexture("hand", 20, 100);
		leg_left_4_pivot.SetTextureRender(7, 8);
		leg_left_4_pivot.SetRotation(60, 10, 10);
		leg_left_4_pivot.visible = false;

		var abdomen_pivot = new Part(20, 170, 100);
		abdomen_pivot.SetTexture("hand", 20, 100);
		abdomen_pivot.SetTextureRender(8, 9);
		abdomen_pivot.SetRotation(-180, 10, 10);
		abdomen_pivot.visible = false;

		var fang_left_pivot = new Part(20, 180, 100);
		fang_left_pivot.SetTexture("hand", 20, 100);
		fang_left_pivot.SetTextureRender(9, 10);
		fang_left_pivot.SetRotation(15, 10, 10);
		fang_left_pivot.visible = false;

		var abdomen = new Part(1024, 1024, 100);
		abdomen.SetTexture("entity.spider.queen.abdomen", 512, 512);
		abdomen.SetTextureRender(10, 11, 0, 0, 0, 0, -1, -1);
		abdomen.SetRotation(0, 512, 100);

		var fang_right_pivot = new Part(20, 180, 100);
		fang_right_pivot.SetTexture("hand", 20, 100);
		fang_right_pivot.SetTextureRender(11, 12);
		fang_right_pivot.SetRotation(-15, 10, 10);
		fang_right_pivot.visible = false;

		var fang_left = new Part(50, 100, 100);
		fang_left.SetTexture("entity.spider.fang.left", 50, 100);
		fang_left.SetTextureRender(12, 13);
		fang_left.SetRotation(-15, 25, 10);

		var fang_right = new Part(50, 100, 100);
		fang_right.SetTexture("entity.spider.fang.right", 50, 100);
		fang_right.SetTextureRender(13, 14);
		fang_right.SetRotation(15, 25, 10);

		var leg_4_1 = new Part(40, 460, 100);
		leg_4_1.SetTexture("entity.spider.queen.leg", 40, 230);
		leg_4_1.SetTextureRender(14, 15, 0, 0, 0, 0, -1, -1);
		leg_4_1.SetRotation(30, 20, 10);

		var leg_4_2 = new Part(40, 460, 100);
		leg_4_2.SetTexture("entity.spider.queen.leg", 40, 230);
		leg_4_2.SetTextureRender(15, 16, 0, 0, 0, 0, -1, 1);
		leg_4_2.SetRotation(15, 20, 10);

		var leg_4_3 = new Part(40, 460, 100);
		leg_4_3.SetTexture("entity.spider.queen.leg", 40, 230);
		leg_4_3.SetTextureRender(16, 17, 0, 0, 0, 0, -1, -1);
		leg_4_3.SetRotation(-15, 20, 10);

		var leg_3_1 = new Part(40, 345, 100);
		leg_3_1.SetTexture("entity.spider.queen.leg", 40, 230);
		leg_3_1.SetTextureRender(17, 18, 0, 0, 0, 0, -1, -1);
		leg_3_1.SetRotation(25, 20, 10);

		var leg_3_2 = new Part(40, 345, 100);
		leg_3_2.SetTexture("entity.spider.queen.leg", 40, 230);
		leg_3_2.SetTextureRender(18, 19, 0, 0, 0, 0, -1, 1);
		leg_3_2.SetRotation(20, 20, 10);

		var leg_3_3 = new Part(40, 345, 100);
		leg_3_3.SetTexture("entity.spider.queen.leg", 40, 230);
		leg_3_3.SetTextureRender(19, 20, 0, 0, 0, 0, -1, -1);
		leg_3_3.SetRotation(-20, 20, 10);

		var leg_2_1 = new Part(40, 345, 100);
		leg_2_1.SetTexture("entity.spider.queen.leg", 40, 230);
		leg_2_1.SetTextureRender(20, 21, 0, 0, 0, 0, -1, -1);
		leg_2_1.SetRotation(-25, 20, 10);

		var leg_2_2 = new Part(40, 345, 100);
		leg_2_2.SetTexture("entity.spider.queen.leg", 40, 230);
		leg_2_2.SetTextureRender(21, 22, 0, 0, 0, 0, -1, 1);
		leg_2_2.SetRotation(-20, 20, 10);

		var leg_2_3 = new Part(40, 345, 100);
		leg_2_3.SetTexture("entity.spider.queen.leg", 40, 230);
		leg_2_3.SetTextureRender(22, 23, 0, 0, 0, 0, -1, -1);
		leg_2_3.SetRotation(20, 20, 10);

		var leg_1_1 = new Part(40, 460, 100);
		leg_1_1.SetTexture("entity.spider.queen.leg", 40, 230);
		leg_1_1.SetTextureRender(23, 24, 0, 0, 0, 0, -1, -1);
		leg_1_1.SetRotation(-20, 20, 10);

		var leg_1_2 = new Part(40, 460, 100);
		leg_1_2.SetTexture("entity.spider.queen.leg", 40, 230);
		leg_1_2.SetTextureRender(24, 25, 0, 0, 0, 0, -1, 1);
		leg_1_2.SetRotation(-25, 20, 10);

		var leg_1_3 = new Part(40, 460, 100);
		leg_1_3.SetTexture("entity.spider.queen.leg", 40, 230);
		leg_1_3.SetTextureRender(25, 26, 0, 0, 0, 0, -1, -1);
		leg_1_3.SetRotation(15, 20, 10);

		var leg_8_1 = new Part(40, 460, 100);
		leg_8_1.SetTexture("entity.spider.queen.leg", 40, 230);
		leg_8_1.SetTextureRender(26, 27, 0, 0, 0, 0, 1, -1);
		leg_8_1.SetRotation(20, 20, 10);

		var leg_8_2 = new Part(40, 460, 100);
		leg_8_2.SetTexture("entity.spider.queen.leg", 40, 230);
		leg_8_2.SetTextureRender(27, 28);
		leg_8_2.SetRotation(25, 20, 10);

		var leg_8_3 = new Part(40, 460, 100);
		leg_8_3.SetTexture("entity.spider.queen.leg", 40, 230);
		leg_8_3.SetTextureRender(28, 29, 0, 0, 0, 0, 1, -1);
		leg_8_3.SetRotation(-15, 20, 10);

		var leg_7_1 = new Part(40, 345, 100);
		leg_7_1.SetTexture("entity.spider.queen.leg", 40, 230);
		leg_7_1.SetTextureRender(29, 30, 0, 0, 0, 0, 1, -1);
		leg_7_1.SetRotation(25, 20, 10);

		var leg_7_2 = new Part(40, 345, 100);
		leg_7_2.SetTexture("entity.spider.queen.leg", 40, 230);
		leg_7_2.SetTextureRender(30, 31);
		leg_7_2.SetRotation(20, 20, 10);

		var leg_7_3 = new Part(40, 345, 100);
		leg_7_3.SetTexture("entity.spider.queen.leg", 40, 230);
		leg_7_3.SetTextureRender(31, 32, 0, 0, 0, 0, 1, -1);
		leg_7_3.SetRotation(-20, 20, 10);

		var leg_6_1 = new Part(40, 345, 100);
		leg_6_1.SetTexture("entity.spider.queen.leg", 40, 230);
		leg_6_1.SetTextureRender(32, 33, 0, 0, 0, 0, 1, -1);
		leg_6_1.SetRotation(-25, 20, 10);

		var leg_6_2 = new Part(40, 345, 100);
		leg_6_2.SetTexture("entity.spider.queen.leg", 40, 230);
		leg_6_2.SetTextureRender(33, 34);
		leg_6_2.SetRotation(-20, 20, 10);

		var leg_6_3 = new Part(40, 345, 100);
		leg_6_3.SetTexture("entity.spider.queen.leg", 40, 230);
		leg_6_3.SetTextureRender(34, 35, 0, 0, 0, 0, 1, -1);
		leg_6_3.SetRotation(20, 20, 10);

		var leg_5_1 = new Part(40, 460, 100);
		leg_5_1.SetTexture("entity.spider.queen.leg", 40, 230);
		leg_5_1.SetTextureRender(35, 36, 0, 0, 0, 0, 1, -1);
		leg_5_1.SetRotation(-29, 20, 10);

		var leg_5_2 = new Part(40, 460, 100);
		leg_5_2.SetTexture("entity.spider.queen.leg", 40, 230);
		leg_5_2.SetTextureRender(36, 37);
		leg_5_2.SetRotation(-15, 20, 10);

		var leg_5_3 = new Part(40, 460, 100);
		leg_5_3.SetTexture("entity.spider.queen.leg", 40, 230);
		leg_5_3.SetTextureRender(37, 38, 0, 0, 0, 0, 1, -1);
		leg_5_3.SetRotation(15, 20, 10);

		body.AddChild(leg_right_3_pivot);
		body.AddChild(leg_right_4_pivot);
		body.AddChild(leg_right_2_pivot);
		body.AddChild(leg_right_1_pivot);
		body.AddChild(leg_left_1_pivot);
		body.AddChild(leg_left_2_pivot);
		body.AddChild(leg_left_3_pivot);
		body.AddChild(leg_left_4_pivot);
		body.AddChild(abdomen_pivot);
		body.AddChild(fang_left_pivot);
		abdomen_pivot.AddChild(abdomen);
		body.AddChild(fang_right_pivot);
		fang_left_pivot.AddChild(fang_left);
		fang_right_pivot.AddChild(fang_right);
		leg_right_4_pivot.AddChild(leg_4_1);
		leg_4_1.AddChild(leg_4_2);
		leg_4_2.AddChild(leg_4_3);
		leg_right_3_pivot.AddChild(leg_3_1);
		leg_3_1.AddChild(leg_3_2);
		leg_3_2.AddChild(leg_3_3);
		leg_right_2_pivot.AddChild(leg_2_1);
		leg_2_1.AddChild(leg_2_2);
		leg_2_2.AddChild(leg_2_3);
		leg_right_1_pivot.AddChild(leg_1_1);
		leg_1_1.AddChild(leg_1_2);
		leg_1_2.AddChild(leg_1_3);
		leg_left_1_pivot.AddChild(leg_8_1);
		leg_8_1.AddChild(leg_8_2);
		leg_8_2.AddChild(leg_8_3);
		leg_left_2_pivot.AddChild(leg_7_1);
		leg_7_1.AddChild(leg_7_2);
		leg_7_2.AddChild(leg_7_3);
		leg_left_3_pivot.AddChild(leg_6_1);
		leg_6_1.AddChild(leg_6_2);
		leg_6_2.AddChild(leg_6_3);
		leg_left_4_pivot.AddChild(leg_5_1);
		leg_5_1.AddChild(leg_5_2);
		leg_5_2.AddChild(leg_5_3);

		this.Parts.body = body;
		this.Parts.leg_right_3_pivot = leg_right_3_pivot;
		this.Parts.leg_right_4_pivot = leg_right_4_pivot;
		this.Parts.leg_right_2_pivot = leg_right_2_pivot;
		this.Parts.leg_right_1_pivot = leg_right_1_pivot;
		this.Parts.leg_left_1_pivot = leg_left_1_pivot;
		this.Parts.leg_left_2_pivot = leg_left_2_pivot;
		this.Parts.leg_left_3_pivot = leg_left_3_pivot;
		this.Parts.leg_left_4_pivot = leg_left_4_pivot;
		this.Parts.abdomen_pivot = abdomen_pivot;
		this.Parts.fang_left_pivot = fang_left_pivot;
		this.Parts.abdomen = abdomen;
		this.Parts.fang_right_pivot = fang_right_pivot;
		this.Parts.fang_left = fang_left;
		this.Parts.fang_right = fang_right;
		this.Parts.leg_4_1 = leg_4_1;
		this.Parts.leg_4_2 = leg_4_2;
		this.Parts.leg_4_3 = leg_4_3;
		this.Parts.leg_3_1 = leg_3_1;
		this.Parts.leg_3_2 = leg_3_2;
		this.Parts.leg_3_3 = leg_3_3;
		this.Parts.leg_2_1 = leg_2_1;
		this.Parts.leg_2_2 = leg_2_2;
		this.Parts.leg_2_3 = leg_2_3;
		this.Parts.leg_1_1 = leg_1_1;
		this.Parts.leg_1_2 = leg_1_2;
		this.Parts.leg_1_3 = leg_1_3;
		this.Parts.leg_8_1 = leg_8_1;
		this.Parts.leg_8_2 = leg_8_2;
		this.Parts.leg_8_3 = leg_8_3;
		this.Parts.leg_7_1 = leg_7_1;
		this.Parts.leg_7_2 = leg_7_2;
		this.Parts.leg_7_3 = leg_7_3;
		this.Parts.leg_6_1 = leg_6_1;
		this.Parts.leg_6_2 = leg_6_2;
		this.Parts.leg_6_3 = leg_6_3;
		this.Parts.leg_5_1 = leg_5_1;
		this.Parts.leg_5_2 = leg_5_2;
		this.Parts.leg_5_3 = leg_5_3;

		this.ApplyArmorModel();
		this.ApplyModelAnimation(SpiderQueenFangsAnimation);
		this.ApplyModelAnimation(SpiderQueenAbdomenAnimation);
		this.ApplyModelAnimation(SpiderQueenWalkAnimation);
		this.ApplyModelAnimation(SpiderQueenLayAnimation);
	}

	Update()
	{
		super.Update();
	}

	Render(context)
	{
		super.Render(context);
	}
}










class SpiderQueenFangsAnimation extends AnimationBase
{
    constructor(model)
    {
        super(model);

        this.setAnimationDuration((150 / this.Owner.SPD) * Main.FPS);
        this.iterations = 'INFINITE';

        this.setAnimationSpacing(.45, .55);

        // this.triggerFunction = function(anim){return anim.Owner.isJumping;};

        this.Data = 
        [
            new AnimationData('fang_left', 'Rotation', -5, -30),
            new AnimationData('fang_right', 'Rotation', 5, 30)
        ];
    }
}


class SpiderQueenAbdomenAnimation extends AnimationBase
{
    constructor(model)
    {
        super(model);

        this.setAnimationDuration(.5 * Main.FPS);
        this.iterations = 'INFINITE';

        this.setAnimationSpacing(.45, .55);

        this.Data = 
        [
            new AnimationData('abdomen', 'Transform.y', 100, 90)
        ];
    }
}







class SpiderQueenWalkAnimation extends AnimationBase
{
    constructor(model)
    {
        super(model);

        this.setAnimationDuration((150 / this.Owner.SPD) * Main.FPS * 1.5);
        this.iterations = 'INFINITE';

        this.setAnimationSpacing(.5, .5);

        this.triggerFunction = function(anim){return anim.Owner.isMoving() && !anim.Owner.isLayingEgg;};

        this.Data = 
        [
            new AnimationData('leg_2_1', 'Rotation', -25, -15, 1),
            new AnimationData('leg_3_1', 'Rotation', 25, 15),
            new AnimationData('leg_6_1', 'Rotation', -25, -15),
            new AnimationData('leg_7_1', 'Rotation', 25, 15),


            new AnimationData('leg_1_1', 'Transform.y', 100, 50, 1),
            new AnimationData('leg_1_2', 'Transform.y', 100, 50, 1),
            new AnimationData('leg_1_3', 'Transform.y', 100, 50, 1),

            new AnimationData('leg_2_1', 'Transform.y', 100, 75, -1),
            new AnimationData('leg_2_2', 'Transform.y', 100, 75, -1),
            new AnimationData('leg_2_3', 'Transform.y', 100, 75, -1),

            new AnimationData('leg_3_1', 'Transform.y', 100, 75, 1),
            new AnimationData('leg_3_2', 'Transform.y', 100, 75, 1),
            new AnimationData('leg_3_3', 'Transform.y', 100, 75, 1),

            new AnimationData('leg_4_1', 'Transform.y', 100, 50, -1),
            new AnimationData('leg_4_2', 'Transform.y', 100, 50, -1),
            new AnimationData('leg_4_3', 'Transform.y', 100, 50, -1),

            new AnimationData('leg_5_1', 'Transform.y', 100, 50, 1),
            new AnimationData('leg_5_2', 'Transform.y', 100, 50, 1),
            new AnimationData('leg_5_3', 'Transform.y', 100, 50, 1),

            new AnimationData('leg_6_1', 'Transform.y', 100, 75, -1),
            new AnimationData('leg_6_2', 'Transform.y', 100, 75, -1),
            new AnimationData('leg_6_3', 'Transform.y', 100, 75, -1),

            new AnimationData('leg_7_1', 'Transform.y', 100, 75, 1),
            new AnimationData('leg_7_2', 'Transform.y', 100, 75, 1),
            new AnimationData('leg_7_3', 'Transform.y', 100, 75, 1),

            new AnimationData('leg_8_1', 'Transform.y', 100, 50, -1),
            new AnimationData('leg_8_2', 'Transform.y', 100, 50, -1),
            new AnimationData('leg_8_3', 'Transform.y', 100, 50, -1)
        ];
    }

	// getAnimationDuration()
	// {
	// 	return ((150 / this.Owner.getSPD()) * Main.FPS * 1.5);
	// }
}








class SpiderQueenLayAnimation extends AnimationBase
{
    constructor(model)
    {
        super(model);

        this.setAnimationDuration(3 * Main.FPS / 10);
        this.iterations = 'INFINITE';

        this.setAnimationSpacing(.4, .6);

        this.triggerFunction = function(anim){return anim.Owner.isLayingEgg;};

        this.Data = 
        [
            new AnimationData('leg_1_1', 'Rotation', -30, -25, 1),
            new AnimationData('leg_1_2', 'Rotation', -30, -40, 1),
            new AnimationData('leg_1_3', 'Rotation', -30, -60, 1),

            new AnimationData('leg_2_1', 'Rotation', -20, 15, -1),
            new AnimationData('leg_2_2', 'Rotation', 60, 100, -1),
            new AnimationData('leg_2_3', 'Rotation', 65, 90, -1),

            new AnimationData('leg_3_1', 'Rotation', -30, 15, 1),
            new AnimationData('leg_3_2', 'Rotation', 60, 100, 1),
            new AnimationData('leg_3_3', 'Rotation', 65, 60, 1),

            new AnimationData('leg_4_1', 'Rotation', -30, -10, -1),
            new AnimationData('leg_4_2', 'Rotation', 60, 100, -1),
            new AnimationData('leg_4_3', 'Rotation', 65, 110, -1),

            new AnimationData('leg_5_1', 'Rotation', 30, 10, 1),
            new AnimationData('leg_5_2', 'Rotation', -60, -100, 1),
            new AnimationData('leg_5_3', 'Rotation', -65, -60, 1),

            new AnimationData('leg_6_1', 'Rotation', 30, -15, -1),
            new AnimationData('leg_6_2', 'Rotation', -60, -100, -1),
            new AnimationData('leg_6_3', 'Rotation', -65, -90, -1),

            new AnimationData('leg_7_1', 'Rotation', 20, -35, 1),
            new AnimationData('leg_7_2', 'Rotation', -60, -100, 1),
            new AnimationData('leg_7_3', 'Rotation', -65, -110, 1),

            new AnimationData('leg_8_1', 'Rotation', 30, 25, -1),
            new AnimationData('leg_8_2', 'Rotation', 30, 40, -1),
            new AnimationData('leg_8_3', 'Rotation', 30, 60, -1)
        ];
    }
}


class OrbitTest extends EntityBubble
{
	constructor(x, y)
	{
		super(x, y);
		
		this.level = 5;
		this.name = "Orbit Test";
		this.Title = "NASA, can you hear me?";
		this.Subtitle = "";
		
		this.MAXHP = 2000;
		this.HP = 2000;
		this.AD = 40;
		this.ATTACK_SPEED = 1;
		
		this.oxygen = 200;
		
		this.AI.Delete("AttackRange");
		this.AI.Apply(new AI_AttackMelee(Player, this.AD));
		this.AI.Apply(new AI_Boss(this));

		this.BossTheme = "interface.BossFight2";
		
		this.HitBox.Scale = 1;

		Commands.ApplyEffect(this, 'regeneration', 5, 9999999);




		this.HitBox.Update(this);

		var angle = 0;
		var angleStep = 360 / 40;
		var radius = this.HitBox.Radius + 10;
		this.OrbitRadiusTransition = new Transition(1, 1.4, 1, true, 1, 1);

		for(var i = 0; i < 40; i++)
		{
			angle += angleStep;

			var entity = new EntityBubble();
				entity.AI.Apply(new AI_OrbitAround(this, 90, radius, angle));
				entity.AI.Apply(new AI_AttackMelee(Player, this.AD));

				entity.AI.Delete("AttackRange");
				entity.AI.Delete("Follow");
				entity.AI.Delete("Wander");


				entity.isHidden = true;
				entity.isAggressive = true;
				entity.oxygen = 0;
				entity.spawnHeart = false;
				entity.ATTACK_SPEED = Main.FPS;

			World.AddEntity(entity);
		}

		this.setScale(10);
	}

	Update()
	{
		super.Update();

		this.OrbitRadius = (this.HitBox.Radius + 10) * this.OrbitRadiusTransition.Update();
	}
}
World.RegisterEntity(OrbitTest);



class OxyCell extends EntityBubbleFormation0
{
	constructor(x, y)
	{
		super(x, y);
		
		this.name = "ENTITY.OXY_CELL.NAME";
		this.Title = "";
		this.Subtitle = "Don`t be afraid!";

		this.MAXHP = 1000;
		this.HP = this.MAXHP;
		this.AD = 10;
		this.ATTACK_SPEED = 1;
		this.SPD = 300;
		this.Color = null;

        this.BULLET_SPEED = 800;

		
		this.AI.Delete("AttackRange");
		this.AI.Apply(new AI_AttackMelee(Player, this.AD*2));
		this.AI.Apply(new AI_Boss(this));
		this.AI.Apply(new AI_ShotOnCircle({
			shotCount: 20,
			shotDelayMin: 3,
			shotDelayMax: 3
		},
		{
			Scale: 2,
            knockBack: 3
		}));
        this.AI.Apply(new AI_Enrage(this, 50, {showAnimation: false, invincibleOnRage: false}));


		this.BossTheme = "interface.BossFight2";
        this.enragedAnimationDuration = Main.FPS;

		this.setScale(10);

        this.Clones = [];
        this.CloneSummons = 0;
        this.lastSummonTick = 0;
        this.SummonCD = 6 * Main.FPS;

        this.LootTable = new LootTable([new LootTableItemData('TreasureOrbOxyCell', 100, 1, 1)]);
        
	}

    Enrage()
    {
        this.isHurtAble = false;

        this.SPD*=1.5;
        this.BULLET_SPEED*=1.5;
        this.AI.ShotOnCircle.setShotDelay(2, 2);
    }

    onEnrageAnimationProgress()
    {
        this.AI.ShotOnCircle.attackCharge = 0;

        var new_scale = 10 - (5 * this.enrageAnimationProgress);
        this.setScale(new_scale);
    }

    onEnrageAnimationEnd()
    {
        this.isHurtAble = true;
    }

    EnrageUpdate()
    {
        if(!this.isHurtAble) return;

        var alive = 0;
        for(var i = 0; i < this.Clones.length; i++)
        {
            if(this.Clones[i].isAlive) 
            {
                alive++;
                break;
            }
        }
        
        if(alive == 0) 
        {
            if(this.lastSummonTick + this.SummonCD < this.ageInTicks) this.SummonClones();
        }
    }

    SummonClones()
    {
        var end, move, clone;
        var clones = 4;
        var cloneSpd = this.SPD * 3;
        this.Clones = [];

        var angle = (this.CloneSummons%2 == 0) ? 45 : 0;
        var angleStep = 360 / clones;
        var selfClone = MathHelper.randomInRange(0, clones-1);

        for(var i = 0; i < clones; i++)
        {
            end = MathHelper.lineToAngle(this, World.Radius*.66, angle);
            move = Motion.Get([this.x, this.y], [end.x, end.y], cloneSpd);
            clone = new OxyCellClone(this.x, this.y, move, this);
            if(i == selfClone) clone.isSelfClone = true;

            World.AddEntity(clone);
            this.Clones.push(clone);
            angle += angleStep;
        }

        this.CloneSummons++;

        // this.Transparency = 0;
        this.isHidden = true;
        this.allowMove = true;
        this.isHurtAble = false;
        this.lastSummonTick = this.ageInTicks;
    }

    onSelfCloneDeath(clone)
    {
        this.x = clone.x;
        this.y = clone.y;

        this.Transparency = 1;
        this.isHidden = false;
        this.allowMove = false;
        this.isHurtAble = true;
    }

	Update()
	{
        if(this.isEnraged) this.EnrageUpdate();
        super.Update();

		if(this.shotOnCircleCharge >= 40)
		{
			this.allowMove = false;
			this.allowFollow = false;

			this.rotationSpeed = this.baseRotationSpeed * 2;
			if(this.shotOnCircleCharge >= 80) this.rotationSpeed = this.baseRotationSpeed * 3;
		}
		else
		{
			this.rotationSpeed = this.baseRotationSpeed;
		}
		
	}
}
World.RegisterEntity(OxyCell);



class OxyCellClone extends OxyCell
{
	constructor(x, y, move, owner = World.Boss)
	{
		super(x, y);
		this.LootTable = new LootTable();

        this.isHurtAble = false;
        this.owner = owner;

        this.AI = new AI(this);
        this.isBoss = false;
        this.AI.Apply(new AI_AttackMelee(Player, this.AD*2));
        this.AI.Apply(new AI_Walk());

        this.moveX = move.x ?? 0;
        this.moveY = move.y ?? 0;

        this.Transparency = .25;
        this.setScale(owner.Scale);

        this.lockAI = false;
        this.isSelfClone = false;
	}

	Update()
	{
		super.Update();
        this.HP = this.owner.HP;

        var r = this.width * this.Scale;
		var distance = MathHelper.GetDistance([this.x, this.y], [World.CenterPoint.x, World.CenterPoint.y]);
		if(distance >= World.Radius - (r + 10)) this.Kill();
	}

    onKill()
    {
        if(this.isSelfClone) this.owner.onSelfCloneDeath(this);
    }
}
World.RegisterEntity(OxyCellClone);



class RubberDuck extends Entity
{
	constructor(x, y)
	{
		super(x, y);
		
		this.level = 2;
		this.name = "Rubber Duck";
		this.Title = "";
		this.Subtitle = "Don`t be afraid!";
		this.Texture = "entity.rubberDuck";
		this.TextureRotation = 180;
		this.Rotation = 180;

		this.MAXHP = 500;
		this.HP = this.MAXHP;
		this.AD = 10;
		this.ATTACK_SPEED = 1;
		this.SPD = 200;
		this.BULLET_SPEED = 350;
		this.FOLLOW_RANGE = 99999;
		// this.Color = new Color(0, 255, 0);

		this.oxygen = (World.Player?.stats.Level == 2 && World.Player?.oxygen < 100) ? 83 : 1;

		this.AI.Apply(new AI_Follow(World.Player, true));
		this.AI.Apply(new AI_Walk());
		this.AI.Apply(new AI_AttackMelee(Player, this.AD));
		this.AI.Apply(new AI_Boss(this));
		this.AI.Apply(new AI_ShotOnCircle({
			shotCount: 16,
			shotDelayMin: 8,
			shotDelayMax: 10
		},
		{
			Scale: 2
		}));

		this.BossTheme = "interface.BossFight2";
		
		this.HitBox.Scale = .95;

		this.LootTable = new LootTable([new LootTableItemData('StarterBag', 100, 1, 1)]);

		this.RenderTransitions =
		{
			Scale: new Transition(1, 0.95, 0.25, true, 0.02, 0.02)
		};

		this.setScale(10);
	}

	Update()
	{
		if(this.shotOnCircleCharge >= 80)
		{
			this.allowMove = false;
			this.allowFollow = false;

			if(this.ageInTicks%10 == 0)
			{
				this.Color = (this.Color == 'none' || !this.Color) ? new Color(200, 0, 0) : 'none';
			}
		}
		else
		{
			this.Color = 'none';
		}
		super.Update();
	}
}
World.RegisterEntity(RubberDuck);



class SpikySniper extends EntityTurret
{
	constructor(x, y)
	{
		super(x, y);
		
		this.level = 10;
		this.name = "Spiky Sniper";
		this.Scale = 10;
		this.MAXHP = 2000;
		this.HP = 2000;
		this.oxygen = 300;
		this.AD = 20;
		this.ATTACK_RANGE = 2000;
		this.BULLET_SPEED = 400;
		this.BULLETS_COUNT = 3;
		this.BULLET_SERIES = 1;
		this.rangeFromCenter = 0;
		
		this.bulletStats.Scale = 3.5;
		
		this.AI.Apply(new AI_ShotOnCircle
		(
			{
				shotCount: 16,
				shotDelayMin: 1,
				shotDelayMax: 3
			}, 
			{	
				Type: "BulletSpike",
				damage: 30, 
				Scale: 2,
				spd: 600
			}
		));
		this.AI.Apply(new AI_Boss(this));

		this.BossTheme = "interface.BossFight1";
	}

	Update()
	{
		super.Update();

		if(this.HP < this.MAXHP / 2)
		{
			this.AI.ShotOnCircle.shotDelayMax = 1;
			this.AI.ShotOnCircle.shotDelayMin = 0.5;
			this.BULLET_SPEED = 600;
			this.ATTACK_SPEED = 6;
		}
	}
}
World.RegisterEntity(SpikySniper);class TheFatOne extends EntityBubble
{
	constructor(x, y)
	{
		super(x, y);
		
		this.name = "ENTITY.THE_FAT_ONE.NAME";
		this.Texture = 'entity.the_fat_one.base';
		this.TextureMouth = 'entity.the_fat_one.mouth';
		// this.Title = "";
		// this.Subtitle = "Don`t be afraid!";

		this.MAXHP = 1600;
		this.HP = this.MAXHP;
		this.AD = 10;
		this.ATTACK_SPEED = 1;
		this.SPD = 200;
		this.Color = null;

        this.BULLET_SPEED = 300;

		this.JumpDuration = .5;
        this.JumpDelay = 3;
        this.JumpDistance = this.SPD * 3;
        this.shakeOnJump = 3;
        this.jumps = 0;
        this.jumpsPerSpecialAttack = 3;
		this.napalmDuration = 6;
		this.napalmTicks = 0;
		this.napalmAnim = 0;

		this.AI = new AI(this);
        this.AI.Apply(new AI_Jump(false, this.JumpDelay, this.JumpDelay, Player));
		this.AI.Apply(new AI_Walk());
		this.AI.Apply(new AI_AttackMelee(Player, this.AD*2));
		this.AI.Apply(new AI_Boss(this));
        this.AI.Apply(new AI_Enrage(this, 50));

		var stats = 
		{
            shotCount: 4,
            shotDelayMin: 99999,
            shotDelayMax: 99999,
            getStartAngleFromOwnerRotation: true
		};
        this.AI.Apply(new AI_ShotOnCircle(stats,
        {
            Scale: 2,
			damage: 0,
			Texture: 'effect.poison',
			onPlayerCollisionEffects: [['Poisoning', 1, 10, false]],
			onEntityCollisionEffects: [['Poisoning', 1, 10, false]]
        }, true));

		this.BossTheme = "interface.BossFight2";
        this.enragedAnimationDuration = 4 * Main.FPS;

		this.defaultScale = 8;
		this.setScale(this.defaultScale);

        this.LootTable = new LootTable([new LootTableItemData('TreasureOrbTheFatOne', 100, 1, 1)]);

		this.isUsingNapalm = false;
		this.baseHeight = this.height;
		this.allowRotationChange = false;

		this.rotationSpeed = 1.25;
	}

	onJumpEnd()
    {
        var stats = {};
			stats.spd = 800;
			stats.damage = this.AD/2;
			stats[STAT.ATTACK_RANGE] = 9999;
			stats.Scale = 2;
            stats.knockBack = 2;

		AI_ShotOnCircle.StaticShoot(this, stats, 16);


		this.jumps++;

		if(this.jumps && this.jumps%this.jumpsPerSpecialAttack == 0) 
		{
			this.JumpDelay = this.napalmDuration + 2;
		}
		else this.JumpDelay = (this.isEnraged) ? 1.5 : 3;

		if((this.jumps-1)%this.jumpsPerSpecialAttack == 0 && this.jumps >= this.jumpsPerSpecialAttack-1) 
		{
			this.isUsingNapalm = true;
			this.napalmTicks = 0;
		}
    }

	onJumpStart()
	{
		this.isUsingNapalm = false;
	}

    Enrage()
    {
        this.isJumping = false;
        this.additionalScaleMultiplier = 1;
		this.JumpDelay = 1.5;
		this.jumps = 0;

        this.AI.Jump.timeSinceChange = 0;
        this.AI.Jump.end = null;

		this.toJumpProgress = 30;
		this.height = this.baseHeight

		this.napalmTicks = 0;
		this.isUsingNapalm = false;
		this.napalmAnim = 0;

		this.AI.ShotOnCircle.setShotDelay(9999, 9999);
		this.AI.ShotOnCircle.attackCharge = 0;
    }

    onEnrageAnimationProgress()
    {
        var new_scale = this.defaultScale + (2 * this.enrageAnimationProgress);
        this.setScale(new_scale);
    }

    EnrageUpdate()
    {
        if(this.isUsingNapalm)
		{
			//om nom nom the player
			var strength = 500;
			if(Difficulty(2)) strength = 600;
			var motion = Motion.Get([World.Player.x, World.Player.y], [this.x, this.y], strength);
				World.Player.ApplyMove(motion);

			var angle = MathHelper.randomInRange(0, 360);

			Particle.SummonCirclePattern("bubble", this.x, this.y, 0.4, 1000, 1, 
				World.Radius, angle, null, false);
		}
    }

	Update()
	{
        if(this.isEnraged) this.EnrageUpdate();
        super.Update();

		var height_transform = .4;

		if(this.toJumpProgress >= 80)
		{
			var p = 1 - ((this.toJumpProgress-80) / 20) * height_transform;
			this.height = this.baseHeight * p;
		}

		if(this.toJumpProgress <= 10)
		{
			var p = (1-height_transform) + (this.toJumpProgress / 10) * height_transform;
			this.height = this.baseHeight * p;
		}


		if(this.isUsingNapalm)
		{
			this.napalmTicks++;
			this.Rotation = (this.Rotation + this.rotationSpeed)%360;

			if(this.napalmTicks == 60) this.AI.ShotOnCircle.setShotDelay(.15, .15);
			if(this.napalmTicks == (this.napalmDuration + 1) * Main.FPS) this.AI.ShotOnCircle.setShotDelay(9999, 9999);

			if(this.napalmTicks <= 60) this.napalmAnim = this.napalmTicks / 60;
			if(this.napalmTicks > 60 && this.napalmTicks < (this.napalmDuration + 1) * Main.FPS)
			{
				var p = (this.napalmTicks%20) / 20;
				this.napalmAnim = 1 - (p * .1);
			}
			if(this.napalmTicks >= (this.napalmDuration + 1) * Main.FPS) this.napalmAnim = 1- (this.napalmTicks - (this.napalmDuration + 1) * Main.FPS) / 60;
		}
	}


	RenderTexture(context)
	{
		var texture = TextureManager.Get(this.Texture);
		var texture_m = TextureManager.Get(this.TextureMouth);

        var x = this.x - Camera.xView;
        var y = this.y - Camera.yView;
        var height = this.height;
        var width = this.width;

		var height_diff = this.baseHeight - this.height;
		y += height_diff / 2 * this.Scale;

        var rotation = this.TextureRotation;
        var scale = this.Scale;
        var alpha = this.Transparency;

		var frame = this.TextureData.frame ?? 0;
		var frames = this.TextureData.frames ?? 1;
		var direction = this.TextureData.direction ?? 'Y';

		var m_height = height * (.25 + (this.napalmAnim * .75));


		Graphic.DrawRotatedAnimatedImage(context, frame, frames, direction, 
            texture, x, y, width, height, scale, rotation, alpha, this.Origin.x, this.Origin.y);

		Graphic.DrawRotatedAnimatedImage(context, frame, frames, direction, 
			texture_m, x, y, width, m_height, scale, rotation, alpha * .75, this.Origin.x, this.Origin.y);
	}
}
World.RegisterEntity(TheFatOne);




class Trimago extends EntityTrim
{
	constructor(x, y, isBoss = true)
	{
		super(x, y);
		
		this.name = "ENTITY.TRIMAGO.NAME";
        this.BossTheme = "interface.BossFight2";

		this.MAXHP = 1000;
		this.HP = this.MAXHP;
		this.AD = 10;
		this.ATTACK_SPEED = 1;
		this.SPD = 500;

		this.ATTACK_RANGE = 1500;
		this.FOLLOW_RANGE = 1500;
		this.BULLET_SPEED = 800;
		
		var stats = 
		{
            shotCount: 18,
            shotDelayMin: 5,
            shotDelayMax: 5,
            getStartAngleFromOwnerRotation: true
		};

        this.AI = new AI(this);
        this.AI.Apply(new AI_Bounce(this, 0, function(o){return MathHelper.getAngle2(o, World.Player)}, Player));
        this.AI.Apply(new AI_Walk());
        this.AI.Apply(new AI_AttackMelee(Player, 0, 1));
        this.AI.Apply(new AI_ShotOnCircle(stats,
        {
            Scale: 2
        }, true));
        if(isBoss)
        {
            this.AI.Apply(new AI_Boss(this));
            this.AI.Apply(new AI_Enrage(this, 50));
        }
		
		this.isAggressive = true;
		this.LootTable = new LootTable([new LootTableItemData('TreasureOrbTrimago', 100, 1, 1)]);

		this.setScale(8);

        this.canMoveWhileShooting = true;

        this.enragedAnimationDuration = 4 * Main.FPS;
        this.enragedAnimationEnd = false;

        this.napalmTicks = 0;
        this.napalmDuration = 6 * Main.FPS;
        this.napalmCooltime = 6 * Main.FPS;
        this.napalmCooltimeTicks = 0;

        this.Immunity.SLOW = true;
        this.timeToEat = 30;
	}

    Enrage()
    {
        this.SPD*=1.5;
        this.BULLET_SPEED = 300;

        this.shotOnCircleCharge = 0;
        this.AI.ShotOnCircle.setShotDelay(9999, 9999);
        this.AI.ShotOnCircle.shotCount = 3;
    }

    onEnrageAnimationProgress()
    {
        this.AI.ShotOnCircle.attackCharge = 0;

        var new_scale = 8 - (4 * this.enrageAnimationProgress);
        this.setScale(new_scale);
    }

    onEnrageAnimationEnd()
    {
        this.enragedAnimationEnd = true;

        var trims = 11;
        this.trimsAlive = trims;
        this.enrageTicks = 0;
        this.Trims = [];
        ApplyEffect(this, 'Invincibility', 1, this.timeToEat);
        for(var i = 0; i < trims; i++)
        {
            var angle = (360/trims) * i;
            var trim  = new Trimago(this.x, this.y, false);
                trim.AI = new AI(trim);
                trim.AI.Apply(new AI_Bounce(trim, angle));
                trim.AI.Apply(new AI_Walk());
                trim.AI.Apply(new AI_AttackMelee(Player, 0, 2));
                trim.MAXHP = (this.MAXHP / 2) / (trims+1);
                trim.HP = trim.MAXHP;
                trim.isAggressive = true;
                trim.onKill = function(){this.Master.trimsAlive--;}
                trim.LootTable = new LootTable();
                trim.setScale(this.Scale);
                trim.Master = this;

            this.Trims.push(trim);
            World.AddEntity(trim);
        }
    }

    EnrageUpdate()
    {
        if(!this.enragedAnimationEnd) return;

        this.enrageTicks++;
        this.napalmCooltimeTicks++; 

        if((this.napalmCooltimeTicks >= this.napalmCooltime))
        {
            this.napalmTicks++;
            if(this.napalmTicks < this.napalmDuration)
            {
                if(this.napalmTicks == 1) this.AI.ShotOnCircle.setShotDelay(.15, .15);
            }
            else
            {
                this.napalmCooltimeTicks = 0;
                this.napalmTicks = 0;
                this.AI.ShotOnCircle.setShotDelay(9999, 9999);
            }
        }

        if((this.napalmCooltimeTicks >= this.napalmCooltime*.5))
        {
            var p = (this.napalmCooltimeTicks-this.napalmCooltime*.5) / (this.napalmCooltime*.5);
            if(p>1) p = 1;
            this.rotationSpeed = this.baseRotationSpeed * (1-(p*.75));
        }

        if(this.trimsAlive == 0)
        {
            this.Effects.Clear('Invincibility');
            this.Trims = null;
        }

        if(this.enrageTicks >= this.timeToEat * Main.FPS && this.Trims)
        {
            for(var i in this.Trims)
            {
                var t = this.Trims[i];
                if(!t.isAlive) continue;

                t.AI.Delete('Bounce');
                t.AI.Apply(new AI_Follow(this));
                t.canBeEaten = true;
                t.SPD = this.SPD * 2;
            }

            this.Trims = null;
        }
    }

	Update()
	{
		super.Update();
        if(this.isEnraged) this.EnrageUpdate();
        this.Rotation = (this.Rotation + this.rotationSpeed)%360;

        if(this.Master && !this.Master.isAlive) return this.Kill();

        if(this.canBeEaten)
        {
            if(MathHelper.GetDistance(this, this.Master) <= this.Master.width * this.Master.Scale)
            {
                this.Master.HP += this.HP;
                this.Kill();
            }
        }
	}
}
World.RegisterEntity(Trimago);class Waterfly extends Entity
{
	constructor(x, y)
	{
		super(x, y);
		
		this.name = "ENTITY.WATERFLY.NAME";
		this.Title = "";

		this.MAXHP = 1500;
		this.HP = this.MAXHP;
		this.AD = 1;
		this.ATTACK_SPEED = 5;
        this.ATTACK_RANGE = 10000;
		this.FOLLOW_RANGE = 9999;
		// this.ATTACK_RANGE_MIN = this.FOLLOW_RANGE;
        this.BULLET_SPEED = 1000;
		this.SPD = 600;
        this.BULLETS_COUNT = 3;
        this.shootDuration = 5;
        this.dashed = false;
        this.Rotation = 180;
		

        // this.AI.Apply(new AI_Follow(World.Player, false));
		this.AI.Apply(new AI_AttackMelee(Player, 0, 20));
		this.AI.Apply(new AI_Walk());
        this.AI.Apply(new AI_AttackRange(World.Player, {Scale: 1.5}, {shootTrigger: function(o){return o.canShoot}}));
		this.AI.Apply(new AI_Observe(World.Player, this.FOLLOW_RANGE, function(owner){return (owner.canShoot && !owner.isDashing) || !owner.dashed;}))
		this.AI.Apply(new AI_Boss(this));
		this.AI.Apply(new AI_Enrage(this, 50));
        this.AI.Apply(new AI_Dash(this, Player, false, this.shootDuration, this.shootDuration, {dashMultiplier: 5, dashDuration: 25, dashesInRow: 1, dashesInRowDelay: 10}));


        this.RenderTransitions =
		{
			Scale: new Transition(1, 0.95, 0.25, true, 0.02, 0.02)
		};

		this.HitBox.Scale = .5;
        this.canShoot = true;

        this.BossTheme = "interface.BossFight2";

        this.Model = new ModelWaterfly(this);
		this.setScale(7);

        this.enragedAnimationDuration = 4 * Main.FPS;

		this.invincibleScale = 1.5;

		this.LootTable = new LootTable([new LootTableItemData('TreasureOrbWaterfly', 100, 1, 1)]);

        this.TwisterDuration = 60;
        this.TwisterSlowDuration = 5;
        this.TwisterSlowStrength = 25;
    }

    onDashEnd()
    {
        this.canShoot = true;
    }

    onDashStart()
    {
        this.canShoot = false;
        this.dashed = true;

        if(this.isEnraged) this.SummonTwister();
    }

    SummonTwister()
    {
		var angle = this.AI.Dash.dashAngle;
        var target = MathHelper.lineToAngle([this.x, this.y], 9999, angle);

        var stats = {};
            stats.damage = this.AD * 20;
            stats.timeToDespawn = this.TwisterDuration * Main.FPS;
            stats.SlowDuration = this.TwisterSlowDuration;
            stats.SlowStrength = this.TwisterSlowStrength;
            stats.Scale = 5;
        
        var bullet = new BulletWaterTwister(this.x, this.y, stats);
            bullet.Shoot(this, target);
            
        World.AddProjectile(bullet);
    }

	Enrage()
    {
        this.ATTACK_SPEED = 10;
        // this.BULLET_SPEED = 1200;
        this.BULLETS_COUNT = 5;
        this.shootDuration = 2.5;

        this.AI.Dash.coolTimeMin = this.shootDuration;
        this.AI.Dash.coolTimeMax = this.shootDuration;
    }
}
World.RegisterEntity(Waterfly);





class ModelWaterfly extends ModelBase
{
	constructor(owner)
	{
		super(owner);

		this.Width = 1024;
		this.Height = 700;

        this.Scale = 0.125;

		// this.Offset.x = -512;
		// this.Offset.y = -130;

		var base = new Part(256, 256, 100);
		base.SetTexture("entity.waterfly.base", 256, 256);
		base.SetTextureRender(1, 0);
		base.SetRotation(0, 128, 120);

		var tail_pivot = new Part(20, 130, 100);
		tail_pivot.SetTexture("hand", 20, 100);
		tail_pivot.SetTextureRender(2, 1);
		tail_pivot.SetRotation(0, 10, 10);
		tail_pivot.visible = false;

		var tail_1 = new Part(54, 54, 100);
		tail_1.SetTexture("entity.waterfly.tail", 54, 54);
		tail_1.SetTextureRender(3, 2);
		tail_1.SetRotation(0, 27, 5);

		var tail_2 = new Part(54, 54, 100);
		tail_2.SetTexture("entity.waterfly.tail", 54, 54);
		tail_2.SetTextureRender(4, 3);
		tail_2.SetRotation(0, 27, 5);

		var tail_3 = new Part(50, 50, 100);
		tail_3.SetTexture("entity.waterfly.tail", 54, 54);
		tail_3.SetTextureRender(5, 4);
		tail_3.SetRotation(0, 25, 5);

		var tail_4 = new Part(50, 50, 100);
		tail_4.SetTexture("entity.waterfly.tail", 54, 54);
		tail_4.SetTextureRender(6, 5);
		tail_4.SetRotation(0, 25, 5);

		var tail_5 = new Part(50, 50, 100);
		tail_5.SetTexture("entity.waterfly.tail", 54, 54);
		tail_5.SetTextureRender(7, 6);
		tail_5.SetRotation(0, 25, 5);

		var tail_6 = new Part(44, 44, 100);
		tail_6.SetTexture("entity.waterfly.tail", 54, 54);
		tail_6.SetTextureRender(8, 7);
		tail_6.SetRotation(0, 22, 5);

		var tail_7 = new Part(44, 44, 100);
		tail_7.SetTexture("entity.waterfly.tail", 54, 54);
		tail_7.SetTextureRender(9, 8);
		tail_7.SetRotation(0, 22, 5);

		var tail_8 = new Part(44, 44, 100);
		tail_8.SetTexture("entity.waterfly.tail", 54, 54);
		tail_8.SetTextureRender(10, 9);
		tail_8.SetRotation(0, 22, 5);

		var tail_9 = new Part(36, 36, 100);
		tail_9.SetTexture("entity.waterfly.tail", 54, 54);
		tail_9.SetTextureRender(11, 10);
		tail_9.SetRotation(0, 18, 5);

		var tail_10 = new Part(36, 36, 100);
		tail_10.SetTexture("entity.waterfly.tail", 54, 54);
		tail_10.SetTextureRender(12, 11);
		tail_10.SetRotation(0, 18, 5);

		var tail_11 = new Part(36, 36, 100);
		tail_11.SetTexture("entity.waterfly.tail", 54, 54);
		tail_11.SetTextureRender(13, 12);
		tail_11.SetRotation(0, 18, 5);

		var wing_pivot_left_1 = new Part(20, 54, 100);
		wing_pivot_left_1.SetTexture("hand", 20, 100);
		wing_pivot_left_1.SetTextureRender(14, 13);
		wing_pivot_left_1.SetRotation(62, 10, 10);
		wing_pivot_left_1.visible = false;

		var wing_pivot_right_1 = new Part(20, 54, 100);
		wing_pivot_right_1.SetTexture("hand", 20, 100);
		wing_pivot_right_1.SetTextureRender(15, 14);
		wing_pivot_right_1.SetRotation(-62, 10, 10);
		wing_pivot_right_1.visible = false;

		var wing_pivot_left_2waterfly = new Part(20, 76, 100);
		wing_pivot_left_2waterfly.SetTexture("hand", 20, 100);
		wing_pivot_left_2waterfly.SetTextureRender(16, 15);
		wing_pivot_left_2waterfly.SetRotation(31, 10, 10);
		wing_pivot_left_2waterfly.visible = false;

		var wing_pivot_right_2 = new Part(20, 76, 100);
		wing_pivot_right_2.SetTexture("hand", 20, 100);
		wing_pivot_right_2.SetTextureRender(17, 16);
		wing_pivot_right_2.SetRotation(-31, 10, 10);
		wing_pivot_right_2.visible = false;

		var wing_right_1 = new Part(500, 150, 100);
		wing_right_1.SetTexture("entity.waterfly.wing", 500, 150);
		wing_right_1.SetTextureRender(18, 17);
		wing_right_1.SetRotation(52, 10, 90);
		wing_right_1.Axis = "x";

		var wing_right_2 = new Part(500, 150, 100);
		wing_right_2.SetTexture("entity.waterfly.wing", 500, 150);
		wing_right_2.SetTextureRender(19, 18);
		wing_right_2.SetRotation(52, 10, 90);
		wing_right_2.Axis = "x";

		var wing_left_1 = new Part(500, 150, 100);
		wing_left_1.SetTexture("entity.waterfly.wing", 500, 150);
		wing_left_1.SetTextureRender(21, 19, 0, 0, 0, 0, -1, 1);
		wing_left_1.SetRotation(-52, 10, 90);
		wing_left_1.Axis = "x";

		var wing_left_2 = new Part(500, 150, 100);
		wing_left_2.SetTexture("entity.waterfly.wing", 500, 150);
		wing_left_2.SetTextureRender(20, 20, 0, 0, 0, 0, -1, 1);
		wing_left_2.SetRotation(-52, 10, 90);
		wing_left_2.Axis = "x";

		var tail_end = new Part(36, 24, 100);
		tail_end.SetTexture("entity.waterfly.tail.end", 55, 36);
		tail_end.SetTextureRender(0, -1);
		tail_end.SetRotation(0, 18, 0);

		base.AddChild(tail_pivot);
		tail_pivot.AddChild(tail_1);
		tail_1.AddChild(tail_2);
		tail_2.AddChild(tail_3);
		tail_3.AddChild(tail_4);
		tail_4.AddChild(tail_5);
		tail_5.AddChild(tail_6);
		tail_6.AddChild(tail_7);
		tail_7.AddChild(tail_8);
		tail_8.AddChild(tail_9);
		tail_9.AddChild(tail_10);
		tail_10.AddChild(tail_11);
		base.AddChild(wing_pivot_left_1);
		base.AddChild(wing_pivot_right_1);
		base.AddChild(wing_pivot_left_2waterfly);
		base.AddChild(wing_pivot_right_2);
		wing_pivot_right_1.AddChild(wing_right_1);
		wing_pivot_right_2.AddChild(wing_right_2);
		wing_pivot_left_2waterfly.AddChild(wing_left_1);
		wing_pivot_left_1.AddChild(wing_left_2);
		tail_11.AddChild(tail_end);

		this.Parts.base = base;
		this.Parts.tail_pivot = tail_pivot;
		this.Parts.tail_1 = tail_1;
		this.Parts.tail_2 = tail_2;
		this.Parts.tail_3 = tail_3;
		this.Parts.tail_4 = tail_4;
		this.Parts.tail_5 = tail_5;
		this.Parts.tail_6 = tail_6;
		this.Parts.tail_7 = tail_7;
		this.Parts.tail_8 = tail_8;
		this.Parts.tail_9 = tail_9;
		this.Parts.tail_10 = tail_10;
		this.Parts.tail_11 = tail_11;
		this.Parts.wing_pivot_left_1 = wing_pivot_left_1;
		this.Parts.wing_pivot_right_1 = wing_pivot_right_1;
		this.Parts.wing_pivot_left_2waterfly = wing_pivot_left_2waterfly;
		this.Parts.wing_pivot_right_2 = wing_pivot_right_2;
		this.Parts.wing_right_1 = wing_right_1;
		this.Parts.wing_right_2 = wing_right_2;
		this.Parts.wing_left_1 = wing_left_1;
		this.Parts.wing_left_2 = wing_left_2;
		this.Parts.tail_end = tail_end;

		this.ApplyArmorModel();
		this.ApplyModelAnimation(WaterflyWalkAnimation);
	}

	Update()
	{
		super.Update();
	}

	Render(context)
	{
		super.Render(context);
	}
}




class WaterflyWalkAnimation extends AnimationBase
{
    constructor(model)
    {
        super(model);

        this.setAnimationDuration(5);
        this.iterations = 'INFINITE';

        this.setAnimationSpacing(.5, .5);

        this.Data = 
        [
            new AnimationData('wing_right_1', 'Transform.x', 100, 30, 1),
            new AnimationData('wing_right_2', 'Transform.x', 100, 30, -1),

            new AnimationData('wing_left_1', 'Transform.x', 100, 30, -1),
            new AnimationData('wing_left_2', 'Transform.x', 100, 30, 1),
        ];
    }
}

class Zubath extends EntityBat
{
	constructor(x, y)
	{
		super(x, y);
		
		this.name = "ENTITY.ZUBATH.NAME";

		this.Texture = "entity.bat.base";
        this.Eyes = 'entity.bat.eyes';
        this.wingTextureLeft = 'entity.bat.wing.left';
        this.wingTextureRight = 'entity.bat.wing.right';

		this.MAXHP = 3500;
		this.HP = this.MAXHP;
		this.AD = 15;
		this.ATTACK_SPEED = 0.2;
        this.ATTACK_RANGE = 1500;
		this.FOLLOW_RANGE = 350;
        this.BULLET_SPEED = 750;
		this.SPD = 300;
        this.BULLETS_COUNT = 15;
		
		var bulletStats = 
		{
			Type: "BulletSoundWave",
			Scale: 3,
            Bounce: 1
		};

		this.isAggressive = true;

		this.AI.Delete('AttackMelee');
		this.AI.Delete('AttackRange');

		this.AI.Apply(new AI_AttackMelee(Player, this.AD, 2));
		this.AI.Apply(new AI_AttackRange(World.Player, bulletStats,{maximalAngle: 150, updateTrigger: function(o){return !o.isUsingSonicBoom}}));

		this.AI.Apply(new AI_Boss(this));
		this.AI.Apply(new AI_Enrage(this, 50));

		this.HitBox.Scale = .5;

		this.LootTable = new LootTable();

        this.WingAnimation = new Transition(0, 4, .15, true, 0, 0, false);
		this.setScale(5);

		this.BossTheme = "interface.BossFight2";
		this.enragedAnimationDuration = 4 * Main.FPS;

		this.isUsingSonicBoom = false;
		this.sonicBoomDuration = 5 * Main.FPS;
		this.sonicBoomPreparationTime = 5 * Main.FPS;
		this.sonicBoomCoolTime = 10 * Main.FPS;
		this.sonicBoomStart = 0;
		this.baseSonicIndicatorFrequency = 120;
		this.sonicIndicatorFrequency = this.baseSonicIndicatorFrequency;
	}

	Update()
	{
		super.Update();

		if(this.isEnraged) this.EnrageUpdate();
	}


	onEnrageAnimationEnd()
    {
		this.sonicBoomStart = this.ageInTicks + (this.sonicBoomCoolTime / 2);
    }


    EnrageUpdate()
    {
		if(this.ageInTicks == this.sonicBoomStart) this.isUsingSonicBoom = true;

		if(this.isUsingSonicBoom)
		{
			this.allowMove = false;
			var tick = this.ageInTicks - this.sonicBoomStart;
			
			this.attack_frame = Math.floor(2 * (tick/60));
			if(this.attack_frame > 2) this.attack_frame = 2;

			if(tick <= this.sonicBoomPreparationTime)
			{
				//prepare sonic boom

				//om nom nom the player
				var strength = 550;
				if(Difficulty(2)) strength = 650;
				var motion = Motion.Get([World.Player.x, World.Player.y], [this.x, this.y], strength);
					World.Player.ApplyMove(motion);

				if(tick <= this.sonicBoomPreparationTime)
				{
					var freq = this.sonicIndicatorFrequency;
					if(tick%freq == 0)
					{
						var scale = 20 * this.Scale;
						var x = this.x;
						var y = this.y;
						Particle.Summon('effect.sonic_boom.indicator', x, y, 0, 0, scale, 0, 1, 20, 
						{
							liveTime: 30, 
							baseScale: scale,
							center: true,
							// globalAlpha: 0.5,
							RENDER_LAYER: Graphic.Layer.LightLevel+1,
							onUpdate: function(){this.Scale = this.baseScale - (this.baseScale * (this.ageInTicks / this.liveTime)); this.opacity = 1 - (this.ageInTicks / this.liveTime)}
						});

						this.sonicIndicatorFrequency /= 2;
					}
				}
			}
			else
			{
				var delay = 60;
				tick -= this.sonicBoomPreparationTime;
				if(tick <= this.sonicBoomDuration+delay)
				{
					//sonic booom
					if(tick >= delay) this.SonicBoomShoot();
				}
				else
				{
					this.isUsingSonicBoom = false;
					this.sonicBoomStart = this.ageInTicks + this.sonicBoomCoolTime;
					this.sonicIndicatorFrequency = this.baseSonicIndicatorFrequency;
					this.allowMove = true;
				}
			}
		}
    }

	SonicBoomShoot()
	{
		var delay = 2;
        if(this.ageInTicks%delay == 0)
        {
            var bullets = 1;
            var angle = MathHelper.getAngle2(this, World.Player);

            var stats = {};
                stats.spd = 2500;
                stats.Scale = 30;
                stats.damage = 1;
                stats.knockBack = 0;
                stats.Type = 'BulletEcho';
				stats.showParticle = false;
				stats.scaleGrow = .025;
				stats.Bounce = 0;
				stats.playerEffectChance = 100;
				stats.onPlayerCollisionEffects = [['Stun', 1, .5, false]];

            AI_ShotOnCircle.StaticShoot(this, stats, bullets, {angle: angle});
        }
	}
}
World.RegisterEntity(Zubath);



class EntityVillageNPC extends Entity
{
	constructor(x, y)
	{
		super(x, y);
		
		this.isHurtAble = false;
		this.isNPC = true;
		
		this.AI.Apply(new AI_Talk(this));
		this.AI.Apply(new AI_Walk());
		this.AI.Apply(new AI_Wander(true, 7, 10, {r: 150}));
        this.AI.Apply(new AI_QuestIndicator(this));

		this.startDialog = 'MinerTest';
        this.firstMetDialog = 'MinerTest';

        this.dialogLine = this.firstMetDialog;

        this.Hands = 
        [
            ['entity.npc.hand.right', -54, -54, 16, 16, 180],
            ['entity.npc.hand.left', 6, -54, 16, 16, 180]
        ];

        this.availableNames = null;
		
        this.HandMove = new Transition(-.5, .5, 1, true, 0, 0, false);

        this.RenderTransitions =
		{
			Scale: new Transition(1, 0.95, 0.5, true, 0.02, 0.02)
		};
	}

    onKnockBack()
    {
        this.AI.Wander?.changeDir();
    }

    Update()
    {
        if(World.Boss) this.isHidden = true;
        else this.isHidden = false;
        
        super.Update();

        this.dialogLine = isNPCMet(this.getId()) ? this.startDialog : this.firstMetDialog;
    }

    getDisplayName()
    {
        var id = this.getId();
        if(isNPCMet(id)) 
        {
            if(World?.Player?.NPCData[id])
            {
                var name = World.Player.NPCData[id].displayName;
                if(name) return Lang.Get(name);

                if(this.availableNames)
                {
                    name = this.availableNames[MathHelper.randomInRange(0, this.availableNames.length-1)];
                    World.Player.NPCData[id].displayName = name;
                    return Lang.Get(name);
                }
            }

            return super.getDisplayName();
        }
        return '???';
    }
}



class DevMerchant extends EntityVillageNPC
{
	constructor(x, y)
	{
		super(x, y);
		
		this.name = 'Giovanni Lasagna';

		this.TextureRotation = 180;

		this.Textures = 
        {
            Base: 'entity.npc.chief.base',
            Hat: 'entity.npc.chief.hat'
        };

		this.SPD = 100;
		
		this.AI.Apply(new AI_TradeAble(this, Math.ceil(ItemHelper.totalItems/9) * 9));

		this.startDialog = 'DevMerchantStart';
        this.firstMetDialog = 'DevMerchantStart';
		this.setScale(2);
	}

	onTrade()
	{
		this.inventory = [];

		var itemList = ItemHelper.Items;

		for(var i in itemList)
		{
			var item = Item.Get(i);
                item.inShopPrice = 1;

            var c = (item.stackAble) ? item.maxStackSize : 1;

			this.addItemToInventory(item, c, true);
		}
	}


    RenderTexture(context)
    {
        var x = this.x - Camera.xView;
        var y = this.y - Camera.yView;
        var height = this.height;
        var width = this.width;

        var rotation = this.Rotation;
        var scale = this.Scale;
        var alpha = this.Transparency;

        var textureBase = TextureManager.Get(this.Textures.Base);
        var textureHat = TextureManager.Get(this.Textures.Hat);
        var baseRotation = rotation + this.TextureRotation;

        var hatOffset = 25 * (height/textureHat.height);

        Graphic.DrawRotatedImage(context, textureBase, x, y, width, height, scale, baseRotation, alpha);
        Graphic.DrawRotatedImage(context, textureHat, x, y, width, height, scale * 1.6, baseRotation, alpha, 0, hatOffset);
    }
}
World.RegisterEntity(DevMerchant);



class Mage extends EntityVillageNPC
{
	constructor(x, y)
	{
		super(x, y);
		
        this.TextureRotation = 180;

		this.SPD = 100;

		this.startDialog = 'MageDialog';
        this.firstMetDialog = 'MageMetDialog';

        this.Textures = 
        {
            Base: 'entity.npc.mage.base',
            Hat: 'entity.npc.mage.hat'
            // Hair: 'entity.npc.stylist.hair'
        };

        this.availableNames = 
        [
            'NPC.MAGE.NAME.0',
            'NPC.MAGE.NAME.1',
            'NPC.MAGE.NAME.2',
            'NPC.MAGE.NAME.3',
        ];

        // this.HairFrames = 12;
        // this.HairAnimation = new Transition(0, this.HairFrames -1, 1, false, 0, 0, true);

        this.setScale(1.5);
	}

    RenderTexture(context)
    {
        var x = this.x - Camera.xView;
        var y = this.y - Camera.yView;
        var height = this.height;
        var width = this.width;

        var rotation = this.Rotation;
        var scale = this.Scale;
        var alpha = this.Transparency;

        var textureBase = TextureManager.Get(this.Textures.Base);
        var textureHat = TextureManager.Get(this.Textures.Hat);
        var baseRotation = rotation + this.TextureRotation;

        var hatOffset = 25 * (height/textureHat.height);

        // var textureHair = TextureManager.Get(this.Textures.Hair);
        // var frame = this.HairAnimation.Update();

        // Graphic.DrawRotatedAnimatedImage(context, frame, this.HairFrames, 'Y', 
        // textureHair, x, y, width, height, scale * 1.5, baseRotation, alpha, 0, height * .5);

        Graphic.DrawRotatedImage(context, textureBase, x, y, width, height, scale, baseRotation, alpha);
        Graphic.DrawRotatedImage(context, textureHat, x, y, width, height, scale * 1.6, baseRotation, alpha, 0, hatOffset);
    }
}
World.RegisterEntity(Mage);



class Merchant extends EntityVillageNPC
{
	constructor(x, y)
	{
		super(x, y);
		
		this.name = Lang.Translate('NPC_MERCHANT_NAME');

		this.SPD = 100;
		
		this.AI.Apply(new AI_TradeAble(this));

		this.startDialog = 'MerchantTest';
		this.setScale(1);
	}

	onTrade()
	{
		this.inventory = [];

		var itemList = ItemHelper.GetItemsInLocationOrder('WEAPON');
		this.addItemToInventory(new LiquidOxygen(), 100, true);

		for(var i = 0; i < itemList.length; i++)
		{
			var item = Item.Get(itemList[i]);
			if(item.enchantAble) item.Enchant(new EnchantLock());
			item.Grade = GRADE.NORMAL;

			this.addItemToInventory(item, 1, true);
		}
	}
}
World.RegisterEntity(Merchant);



class Miner extends EntityVillageNPC
{
	constructor(x, y)
	{
		super(x, y);
		
		this.name = Lang.Translate('NPC_MINER_NAME');
        this.TextureRotation = 180;

		this.SPD = 100;

		this.startDialog = 'MinerDialog';
        this.firstMetDialog = 'MinerMetDialog';

        this.Texture = 'entity.npc.miner';

		this.availableNames = 
        [
            'NPC.MINER.NAME.0',
            'NPC.MINER.NAME.1',
            'NPC.MINER.NAME.2',
            'NPC.MINER.NAME.3',
        ];

		this.setScale(2);

		this.AI.Apply(new AI_TradeAble(this));

		this.lightRadius = 100;
	}

	onTrade()
	{
		this.inventory = [];

		this.addItemToInventory(new EssenceGradeExtractor(), 1, true);
		this.addItemToInventory(new BlessingGrade(), 1, true);
	}
}
World.RegisterEntity(Miner);



class QuestLineLevelUp1 extends QuestLine
{
    constructor()
    {
        super();

        this.requiredLevel = 1;

        this.levelToComplete = 10;
        this.NPC = 'SENSEI';
        this.name = 'QUEST.LEVELUP.1.NAME';
        this.Description = 'QUEST.LEVELUP.1.DESCRIPTION';
    }

    GetProgress()
    {
        return World.Player.stats.Level / this.levelToComplete * 100;
    }

    checkForCompletion()
    {
        if(World.Player.stats.Level >= this.levelToComplete) return true;

        return super.checkForCompletion();
    }

    GetReward()
    {
        var reward = new TheStick();
            reward.Grade = GRADE.NORMAL;
            reward.showNewItemInfo = true;
        World.Player.addItemToInventory(reward);
    }
}
QuestList.Init(QuestLineLevelUp1);





class QuestLineLevelUp2 extends QuestLineLevelUp1
{
    constructor()
    {
        super();
        this.levelToComplete = 20;
        this.requiredQuest = 'QuestLineLevelUp1';

        this.name = 'QUEST.LEVELUP.2.NAME';
        this.Description = 'QUEST.LEVELUP.2.DESCRIPTION';
    }
}
QuestList.Init(QuestLineLevelUp2);




class QuestLineLevelUp3 extends QuestLineLevelUp1
{
    constructor()
    {
        super();
        this.levelToComplete = 30;
        this.requiredQuest = 'QuestLineLevelUp2';

        this.name = 'QUEST.LEVELUP.3.NAME';
        this.Description = 'QUEST.LEVELUP.3.DESCRIPTION';
    }
}
QuestList.Init(QuestLineLevelUp3);














class QuestLineViViScissors extends QuestLineFindItem
{
    constructor()
    {
        super();

        this.requiredLevel = 10;

        this.NPC = 'STYLIST';
        this.name = 'QUEST.VIVISCISSORS.NAME';
        this.Description = 'QUEST.VIVISCISSORS.DESCRIPTION';
        this.Icon = 'item.quest.golden_scissors';

        this.requiredItem = 'ViVisScissors';
        this.Chance = 5;
        this.WholeLocation = 'Lake7';
    }

    GetReward()
    {
        World.Player.coins += 20000;
        World.Player.oxygen += 1500;

        var reward = new RandomAppearanceBox();
            reward.showNewItemInfo = true;
        World.Player.addItemToInventory(reward);
    }
}
QuestList.Init(QuestLineViViScissors);class Sensei extends EntityVillageNPC
{
	constructor(x, y)
	{
		super(x, y);
		
        this.TextureRotation = 180;

		this.SPD = 100;

		this.startDialog = 'SenseiDialog';

        this.Texture = 'entity.npc.sensei';

        this.availableNames = 
        [
            'NPC.SENSEI.NAME.0',
            'NPC.SENSEI.NAME.1',
            'NPC.SENSEI.NAME.2',
            'NPC.SENSEI.NAME.3',
        ];

        this.setScale(2);
	}
}
World.RegisterEntity(Sensei);



class Statue extends EntityVillageNPC
{
	constructor(x, y)
	{
		super(x, y);

        var e = new Obstacle();
        this.onPlayerCollision = e.onPlayerCollision;
        this.onEntityCollision = e.onEntityCollision;

        this.canBeKnockedBack = false;
        this.showHpBar = false;
        this.isHurtAble = true;
		this.knockBack = 1;
        this.knockBackTime = 5/60;
        this.isObstacle = true;

		this.SPD = 0;

		this.startDialog = 'StatueDialog';
        this.firstMetDialog = 'StatueMetDialog';

        this.Texture = 'entity.npc.statue';

        this.availableNames = 
        [
            'NPC.STATUE.NAME'
        ];

        this.allowRotationChange = false;
        this.AI = new AI(this);
        this.AI.Apply(new AI_Talk(this));
        this.AI.Apply(new AI_QuestIndicator(this));


        this.HitBox.Scale = .5;
        this.Hands = null;

        this.RenderTransitions = {};

        this.Immunity.All = true;

        this.setScale(4);
	}

    Sacrifice()
    {
        var current = World.Player.NPCData.STATUE.sacrifice;
        if(!current) current = 0;

        World.Player.NPCData.STATUE.sacrifice = current + World.Player.coins;
        World.Player.coins = 0;

        Save();
    }

    Hurt(){return;}
}
World.RegisterEntity(Statue);



class Stylist extends EntityVillageNPC
{
	constructor(x, y)
	{
		super(x, y);
		
		this.name = Lang.Translate('NPC.STYLIST.NAME');
		this.displayName = 'NPC.STYLIST.NAME';
        this.TextureRotation = 180;

		this.SPD = 100;

		this.startDialog = 'StylistDialog';
        this.firstMetDialog = 'StylistMetDialog';

        this.Textures = 
        {
            Base: 'entity.npc.stylist.base',
            Hair: 'entity.npc.stylist.hair'
        };

        this.HairFrames = 12;
        this.HairAnimation = new Transition(0, this.HairFrames -1, 1, false, 0, 0, true);

        this.setScale(1.5);
	}

    RenderTexture(context)
    {
        var x = this.x - Camera.xView;
        var y = this.y - Camera.yView;
        var height = this.height;
        var width = this.width;

        var rotation = this.Rotation;
        var scale = this.Scale;
        var alpha = this.Transparency;

        var textureBase = TextureManager.Get(this.Textures.Base);
        var baseRotation = rotation + this.TextureRotation;

        var textureHair = TextureManager.Get(this.Textures.Hair);
        var frame = this.HairAnimation.Update();

        Graphic.DrawRotatedAnimatedImage(context, frame, this.HairFrames, 'Y', 
        textureHair, x, y, width, height, scale * 1.5, baseRotation, alpha, 0, height * .5);

        Graphic.DrawRotatedImage(context, textureBase, x, y, width, height, scale, baseRotation, alpha);
    }
}
World.RegisterEntity(Stylist);



class BulletBoomerang extends ProjectileBoomerang
{
	constructor(x, y, stats)
	{
		super(x, y, stats);

		this.rotationSpeed = 360;
	}
	
	Update()
	{
		super.Update();

        this.Rotation += this.rotationSpeed / 60;
	}
}
Projectile.Types(BulletBoomerang);class BulletBambooStick extends BulletBoomerang
{
	constructor(x, y, stats)
	{
		super(x, y, stats);

		this.rotationSpeed = -360 * 3;

        this.Texture = 'projectile.bamboo_stick';
        // this.Texture = 'item.bamboo_stick';

        this.Hits = 10;
        this.knockBack = .5;
        this.knockOnPierce = true;
	}


    onEntityCollision(entity)
    {
        super.onEntityCollision(entity);

        if(!this.isCharged) return;

        var owner = World.Player;
        if(owner.stats.HP < owner.stats.MAXHP)
        {
            owner.stats.HP++;
            DamageIndicator.AddObject(owner.x, owner.y, 1, "HEAL");
        }
    }
}
Projectile.Types(BulletBambooStick);class BulletBubble extends Projectile
{
	constructor(x, y, stats)
	{
		super(x, y, stats);

		this.width = 20;
		this.height = 20;
	}
	
	Update()
	{
		super.Update();
	}
	
	Kill()
	{
		if(!this.noKillParticle) World.AddParticle(new Particle("bubble_pop", this.HitBox.x, this.HitBox.y, 20, this.width, this.height, this.Scale, true));
		super.Kill();
	}
}
Projectile.Types(BulletBubble);class BulletBubbleBullet extends Projectile
{
	constructor(x, y, stats)
	{
		super(x, y, stats);

		this.width = 20;
		this.height = 20;

        this.Texture = 'projectile.bubble.bullet';
	}
	
	Update()
	{
		super.Update();
	}
	
	Kill()
	{
		if(!this.noKillParticle) World.AddParticle(new Particle("bubble_pop", this.HitBox.x, this.HitBox.y, 20, this.width, this.height, this.Scale, true));
		super.Kill();
	}
}
Projectile.Types(BulletBubbleBullet);class BulletBubbleEnemy extends BulletBubble
{
	constructor(x, y, stats)
	{
		super(x, y, stats);

		this.Texture = 'bullet.bubble.enemy';

		this.setStats(stats);
	}
}
Projectile.Types(BulletBubbleEnemy);class BulletBubbleRocket extends Projectile
{
	constructor(x, y, stats)
	{
		super(x, y, stats);

		this.width = 20;
		this.height = 20;

        this.Texture = 'projectile.bubble.rocket';
	}
	
	Update()
	{
		super.Update();
	}
	
	Kill()
	{
		if(!this.noKillParticle) World.AddParticle(new Particle("bubble_pop", this.HitBox.x, this.HitBox.y, 20, this.width, this.height, this.Scale, true));
		super.Kill();
	}
}
Projectile.Types(BulletBubbleRocket);class BulletEcho extends Projectile
{
	constructor(x, y, stats)
	{
		super(x, y, stats);

		this.width = 20;
		this.height = 20;

		this.Texture = "projectile.echo";
        this.TextureRotation = 0;
		this.moveParticle = null;
        
        this.playerEffectChance = 5;
		this.entityEffectChance = 5;

        this.onPlayerCollisionEffects = [['Stun', 1, 1, false]];
        this.onEntityCollisionEffects = [['Stun', 1, 1, false]];
        this.scaleGrow = .04;

        this.showParticle = true;
        this.Bounce = 1;
        this.Pierce = 3;

        this.setStats(stats);

        this.setScale(this.Scale);
        this.additionalScaleMultiplier = 0;
        this.canBeLightSource = false;

        this.bulletSery = this.bulletSery ?? 0;
	}

    Update()
    {
        super.Update();

        if(this.additionalScaleMultiplier < (1 - (this.bulletSery * .1)))
            this.additionalScaleMultiplier+= this.scaleGrow;

            
        if(this.showParticle && this.ageInTicks%5 == 0)
        {
            var scale = this.Scale;
            var x = this.x;
            var y = this.y;
            Particle.Summon('projectile.echo', x, y, 0, 0, scale, 0, 1, 20, 
            {
                liveTime: 30, 
                baseScale: scale,
                center: true,
                // globalAlpha: 0.5,
                RENDER_LAYER: Graphic.Layer.LightLevel+1,
                onUpdate: function(){this.Scale = this.baseScale - (this.baseScale * (this.ageInTicks / this.liveTime)); this.opacity = 1 - (this.ageInTicks / this.liveTime)}
            });
        }
    }

    RenderTexture(context)
	{
		if(World.Location.getLightLevelInfo())
        {
            //make projectiles visible in cavern
            Graphic.addPostRenderFunction(Graphic.Layer.LightLevel, () => {
                    super.RenderTexture(ctx);
            });
        }
        else
        {
            super.RenderTexture(context);
        }
	}
}
Projectile.Types(BulletEcho);class BulletFlameStar extends Projectile
{
	constructor(x, y, stats)
	{
		super(x, y, stats);

		this.width = 20;
		this.height = 20;

		this.Texture = "projectile.flame_star";
		this.moveParticle = null;
        this.element = ELEMENT.FIRE;
	}
    
    Update()
    {
        super.Update();
    }
}
Projectile.Types(BulletFlameStar);class BulletFrogTongue extends ProjectileHook
{
	constructor(x, y, stats)
	{
		super(x, y, stats);

        this.Texture = 'projectile.frog.tongue.end';
        this.segmentTexture = 'projectile.frog.tongue';
        this.returnDeepInside = true;
        this.canHookWhileReturning = false;
	}

    onShoot()
    {
        this.source.allowRotationChange = false;
    }
    
    Update()
    {
        if(!this.source.isAlive) this.Kill();
        super.Update();
    }

    Render(context)
    {  
        var texture = TextureManager.Get(this.segmentTexture);

        var x = this.source.x - Camera.xView;
        var y = this.source.y - Camera.yView;
        var scale = this.Scale;

        var width = this.width;
        var height = MathHelper.GetDistance([this.x, this.y], [this.source.x, this.source.y]) - (width * scale * .3);

        var rotation = MathHelper.getAngle2([this.x, this.y], [this.source.x, this.source.y])+90;
        var alpha = this.Transparency;

		var frame = 0;
		var frames = 1;
		var direction = 'Y';


		Graphic.DrawRotatedAnimatedImage(context, frame, frames, direction, 
            texture, x, y, width, height/scale, scale, rotation, alpha, this.Origin.x, -height/scale/2);


        this.Rotation = rotation - 180;

        super.Render(context);
    }

    onKill()
    {
        this.source.allowRotationChange = true;
        super.onKill();
    }
}
Projectile.Types(BulletFrogTongue);class BulletFrostBall extends Projectile
{
	constructor(x, y, stats)
	{
		super(x, y, stats);

		this.width = 20;
		this.height = 20;

		this.Texture = "projectile.frost_ball";
		this.moveParticle = null;
        this.element = ELEMENT.ICE;
        this.Pierce = 999;
	}
    
    Update()
    {
        super.Update();

        if(this.ageInTicks%10 == 0)
        {
            var bullets = this.bullets ?? 3;
            var startAngle = MathHelper.randomInRange(0, 360);
            for(var i = 0; i < bullets; i++)
            {
                var angle = startAngle + ((360/bullets) * i);
                var dest = MathHelper.lineToAngle(this, 9999, angle);
                var motion = Motion.Get(this, dest, 60);

                var data = {};
                    data.moveX = motion.x;
                    data.moveY = motion.y;
                    data.Rotation = angle+90;
                    data.Scale = this.Scale * .75;
                    data.element = this.element;
                    data.SlowStrength = this.SlowStrength ?? 25;
                    data.SlowDuration = this.SlowDuration ?? 10;

                World.AddProjectile(new ExplosionIcicle(this.x, this.y, this.source, this.damage, 20, 2, data));
            }
        }
    }
}
Projectile.Types(BulletFrostBall);class BulletLaserBeam extends ProjectileLaserBeam
{
	constructor(x, y, stats)
	{
		super(x, y, stats);

		this.width = 20;
	}
	
	Update()
	{
		super.Update();
	}
	
	Kill()
	{
		// World.AddParticle(new Particle("bubble_pop", this.HitBox.x, this.HitBox.y, 20, this.width, this.height, this.Scale, true));
		super.Kill();
	}
}
Projectile.Types(BulletLaserBeam);class BulletRocketSmoke extends ProjectileRocket
{
	constructor(x, y, stats)
	{
		super(x, y, stats);

		this.width = 20;
		this.height = 20;
	}
	
	Update()
	{
		super.Update();
	}
	
	Kill()
	{
		var bullets = this.bullets;
		var startAngle = MathHelper.randomInRange(0, 360);
		for(var i = 0; i < bullets; i++)
		{
			var angle = startAngle + ((360/bullets) * i);
			var dest = MathHelper.lineToAngle(this, 9999, angle);
			var motion = Motion.Get(this, dest, MathHelper.randomInRange(20, 40));

			var data = {};
				data.moveX = motion.x;
				data.moveY = motion.y;
				data.Rotation = angle;

			World.AddProjectile(new ExplosionSmoke(this.x, this.y, this.source, this.explosionDamage, 50, 1, data));
		}
		
		super.Kill();
	}
}
Projectile.Types(BulletRocketSmoke);














class BulletRocketSpark extends ProjectileRocket
{
	constructor(x, y, stats)
	{
		super(x, y, stats);

		this.width = 20;
		this.height = 20;
	}
	
	Update()
	{
		super.Update();
	}
	
	Kill()
	{
		World.AddProjectile(new ExplosionSpark(this.x, this.y, this.source, this.explosionDamage, 250, 0.1));
		super.Kill();
	}
}
Projectile.Types(BulletRocketSpark);class BulletSaw extends Projectile
{
	constructor(x, y, stats)
	{
		super(x, y, stats);

		this.width = 64;
		this.height = 64;

        this.Texture = 'projectile.saw';
        this.RotationSpeed = 6;

        this.onPlayerCollisionEffects = [['DefBreak', 100, 5, false]];
        this.onEntityCollisionEffects = [['DefBreak', 100, 5, false]];
	}
	
	Update()
	{
		super.Update();

        this.Rotation += this.RotationSpeed;
	}
}
Projectile.Types(BulletSaw);class BulletSoundWave extends Projectile
{
	constructor(x, y, stats)
	{
		super(x, y, stats);

		this.width = 20;
		this.height = 20;

		this.Texture = "projectile.soundwave";
        this.TextureRotation = 270 - 45;
		this.moveParticle = null;

        this.baseScale = this.Scale;
        this.scaleTransition = new Transition(1, 0.5, 0.25, true, 0.02, 0.02);
	}

    Render(context)
	{
		this.Scale = this.baseScale * this.scaleTransition.Update();
		super.Render(context);
	}

    RenderTexture(context)
	{
		if(World.Location.getLightLevelInfo())
        {
            //make projectiles visible in cavern
            Graphic.addPostRenderFunction(Graphic.Layer.LightLevel, () => {
                    super.RenderTexture(ctx);
            });
        }
        else
        {
            super.RenderTexture(context);
        }
	}
}
Projectile.Types(BulletSoundWave);class BulletSpike extends Projectile
{
	constructor(x, y, stats)
	{
		super(x, y, stats);

		this.Texture = "projectile_spike";

		var texture = TextureManager.Get(this.Texture);
		if(texture)
		{
			this.width = texture.width;
			this.height = texture.height;
		}
	}
	
	Update()
	{
		super.Update();

		this.HitBox.ApplyRotation(this, this.Rotation);
	}
}
Projectile.Types(BulletSpike);class BulletSting extends Projectile
{
	constructor(x, y, stats)
	{
		super(x, y, stats);

		this.width = 20;
		this.height = 20;
        this.TextureRotation = 135+180;
        this.Texture = 'projectile.sting';
        this.explosionScale = .5;

        this.setStats(stats);
	}
	
	
	Kill()
	{
		var bullets = this.bullets;
		var startAngle = MathHelper.randomInRange(0, 360);
		for(var i = 0; i < bullets; i++)
		{
			var angle = startAngle + ((360/bullets) * i);
			var dest = MathHelper.lineToAngle(this, 9999, angle);
			var motion = Motion.Get(this, dest, this.spd);

			var data = {};
				data.moveX = motion.x;
				data.moveY = motion.y;
				data.Rotation = angle+90;
                data.bullets = 0;
                data.source = this.source;
                data.damage = this.damage;
                data.Scale = this.Scale * this.explosionScale;

			World.AddProjectile(new BulletSting(this.x, this.y, data));
		}
		
		super.Kill();
	}
}
Projectile.Types(BulletSting);
class BulletVirtuoso extends ProjectileLaserBeam
{
	constructor(x, y, stats)
	{
		super(x, y, stats);

        this.size = 50;

        this.Textures = 
		{
			start: 'projectile.laser.virtuoso.start',
			mid: 'projectile.laser.virtuoso.mid',
			end: 'projectile.laser.virtuoso.end'
		};

        this.visibleSizeTransition = false;

        this.laserAlphaTransition = new Transition(0, 1, 0.05, true, 0, 0);
	}

    Update()
	{
        this.gotMP = false;
		super.Update();
    }

    onEntityCollision(entity)
    {
        super.onEntityCollision(entity);

        if(this.Item && entity.isHurtAble && !this.gotMP) //cannot load stacks if enemy didnt take damage
        {
            this.gotMP = true;
            this.Item.currentMP++;
            if(this.Item.currentMP > this.Item.requiredMP) this.Item.currentMP = 0;
            // this.Item.Owner.specialAttackGauge = this.Item.currentMP / this.Item.requiredMP;
        }

        // if(!entity.isAlive) console.log('dead')
    }
}
Projectile.Types(BulletVirtuoso);class BulletWaterTwister extends Projectile
{
	constructor(x, y, stats)
	{
		super(x, y, stats);

		this.width = 64;
		this.height = 64;

        this.spd = 120;
        this.Scale = 3;

        this.Texture = 'projectile.water_twister';
        var rotationTime = 1;
        this.rotationSpeed = 360 / (rotationTime * Main.FPS);
        this.baseRotationSpeed = this.rotationSpeed;

        this.SlowStrength = 40;
        this.SlowDuration = 10;

        this.scaleTransitionTime = 60;
        this.Bounce = true;
        this.bounceTime = 9999;
        this.Pierce = 9999;
        this.element = ELEMENT.ICE;

        this.Hits = 2;

        this.setStats(stats);
        this.setScale(this.Scale);

        this.onPlayerCollisionEffects = [['Slow', this.SlowStrength, this.SlowDuration, false]];
		this.onEntityCollisionEffects = [['Slow', this.SlowStrength, this.SlowDuration, false]];
	}
	
	Update()
	{
        var hurtDelay = Math.round(Main.FPS / this.Hits);
        if(this.ageInTicks%hurtDelay == 0)
        {
            this.piercedEntities = [];
        }
		super.Update();

        if(this.ageInTicks <= this.scaleTransitionTime)
        {
            var p = this.ageInTicks / this.scaleTransitionTime;
            this.additionalScaleMultiplier = p;
        }

        if(this.ageInTicks > this.timeToDespawn - this.scaleTransitionTime)
        {
            var p = (this.timeToDespawn-this.ageInTicks) / this.scaleTransitionTime;
            this.additionalScaleMultiplier = p;
        }
	}

    Render(context)
    {
        this.Rotation = (this.Rotation + this.rotationSpeed)%360;
        super.Render(context);
    }
}
Projectile.Types(BulletWaterTwister);class CoveGuardianSpark extends Projectile
{
	constructor(x, y, stats)
	{
		super(x, y, stats);

		this.width = 20;
		this.height = 20;

		this.Texture = "spark_circle";
		this.moveParticle = null;
        this.element = ELEMENT.THUNDER;

        this.isKilled = false;
        this.damageDealDuration = 10;
        this.timeToExplode = Main.FPS * .5;
	}

	Update()
	{
		super.Update();
        if(this.baseMoveX == null) this.baseMoveX = this.moveX;
        if(this.baseMoveY == null) this.baseMoveY = this.moveY;

        if(!this.isKilled)
        {
            var range = this[STAT.ATTACK_RANGE] ?? 0;
            var distance = MathHelper.GetDistance([this.x, this.y], this.from);
            
            var p = distance/range;

            this.moveX = this.baseMoveX * (1-(p*p*p));
            this.moveY = this.baseMoveY * (1-(p*p*p));

            this.Transparency = p/2;

            if(p >= .98) this.Kill();
        }
        else 
        {
            if(this.ageInTicks >= this.damageDealDuration+this.timeToExplode) this.Kill();
            if(this.ageInTicks >= this.timeToExplode) this.Transparency = 1;
        }

		// if(this.ageInTicks % (Main.FPS / 5) == 0)
		// {
		// 	this.piercedEntities = [];
		// }

		// this.Rotation += MathHelper.randomInRange(70, 110);
	}

    onPlayerCollision(player)
	{
		if(!this.isKilled || this.ageInTicks < this.timeToExplode) return;
        super.onPlayerCollision(player);
	}
		
	onEntityCollision(entity)
	{
		if(!this.isKilled || this.ageInTicks < this.timeToExplode) return;
        super.onEntityCollision(entity);
	}

	Kill()
	{
		if(this.isKilled) return super.Kill();

        this[STAT.ATTACK_RANGE]*=100;
		this.ageInTicks = 0;
		this.isKilled = true;

        this.moveX = 0;
        this.moveY = 0;
	}
}
Projectile.Types(CoveGuardianSpark);
class ExplosionBase extends Explosion
{
	constructor(x, y, source, damage, radius, time)
	{
		super(x, y, source, damage, radius, time);

		this.Texture = 'ExplosionBase';
	}
}
Projectile.Types(ExplosionBase);class ExplosionIcicle extends Explosion
{
	constructor(x, y, source, damage, radius, time, data = {})
	{
		super(x, y, source, damage, radius, time);

        this.Scale = 1;
		this.Texture = 'projectile.icicle';

        for(var i in data)
        {
            this[i] = data[i];
        }

        this.onPlayerCollisionEffects = [['Slow', 25, 10, false]];
        this.onEntityCollisionEffects = [['Slow', 25, 10, false]];

        this.setScale(this.Scale);
	}

	Update()
	{
		super.Update();
        this.x += this.moveX * Main.DELTA;
        this.y += this.moveY * Main.DELTA;
	}
}
Projectile.Types(ExplosionIcicle);class ExplosionLightningStrike extends Explosion
{
	constructor(x, y, stats)
	{
		super(x, y, stats);

		this.width = 17;
		this.height = 50;

		this.Texture = "effect.lightning.strike";
        this.Indicator = 'effect.lightning.strike.indicator';
		this.moveParticle = null;
        this.element = ELEMENT.THUNDER;

        this.isKilled = false;
        this.strikeFrames = 6;
        this.strikeFrameDelay = 3;
        this.damageDealDuration = this.strikeFrameDelay * this.strikeFrames;
        this.timeToExplode = Main.FPS * 1;

        this.timeToDespawn = this.damageDealDuration+this.timeToExplode;
        this.lightningTicks = 0;
        this.isStriking = false;
        this.IndicatorDuration = 6;

        this.showIndicator = true;
        this.scaleTransition = false;

        this.setStats(stats);
	}

	Update()
	{
        this.moveX = 0;
        this.moveY = 0;
		super.Update();
        
        if(this.ageInTicks >= this.timeToExplode) 
        {
            this.isStriking = true;
            this.lightningTicks++;
        }
	}

    onPlayerCollision(player)
	{
		if(!this.isStriking) return;
        super.onPlayerCollision(player);
	}
		
	onEntityCollision(entity)
	{
		if(!this.isStriking) return;
        super.onEntityCollision(entity);
	}

    RenderTexture(context)
    {
        var texture = TextureManager.Get(this.Texture);
        var indicator = TextureManager.Get(this.Indicator);
        var x = this.x - Camera.xView;
        var y = this.y - Camera.yView;

        var width = this.width;
        var height = this.height * 2;
        var scale = this.Scale;

        var tY = (height * .6) * scale;

        var frame = Math.floor(this.lightningTicks/this.strikeFrameDelay);

        if(!this.isStriking) 
        {
            if(this.ageInTicks <= this.IndicatorDuration)
            {
                var alpha = 1 - (this.ageInTicks / (this.IndicatorDuration-5));
                var s = scale * .1 * (1.5-alpha);

                Graphic.DrawRotatedAnimatedImage(context, 0, 1, 'X', 
                indicator, x, y, width, width, s, 0, alpha);
            }
            return;
        }

        Graphic.DrawRotatedAnimatedImage(context, frame, this.strikeFrames, 'X', 
            texture, x, y-tY, width, height, scale, 0, this.Transparency);
    }
}
Projectile.Types(ExplosionLightningStrike);
class ExplosionSmoke extends Explosion
{
	constructor(x, y, source, damage, radius, time, data = {})
	{
		super(x, y, source, damage, radius, time);

        this.Scale = 1;
		this.Texture = 'explosion.smoke';
		// this.timeToDespawn += 2 * Main.FPS;

        for(var i in data)
        {
            this[i] = data[i];
        }

        this.setScale(this.Scale);
	}

	Update()
	{
		super.Update();
        this.x += this.moveX * Main.DELTA;
        this.y += this.moveY * Main.DELTA;

		// if(this.ageInTicks % (Main.FPS / 5) == 0)
		// {
		// 	this.piercedEntities = [];
		// }


        if(this.ageInTicks < this.timeToDespawn/2)
        {
            var p = this.ageInTicks / (this.timeToDespawn/2);
            this.Transparency = p;
        }
        else
        {
            var p = (this.ageInTicks - this.timeToDespawn/2) / (this.timeToDespawn/2);
            this.Transparency = 1-p;
        }

        this.Scale = this.baseScale + (this.baseScale * (this.ageInTicks / this.timeToDespawn));
	}
}
Projectile.Types(ExplosionSmoke);class ExplosionSpark extends Explosion
{
	constructor(x, y, source, damage, radius, time)
	{
		super(x, y, source, damage, radius, time);

		this.Texture = 'spark_circle';
		this.timeToDespawn += 2 * Main.FPS;
	}

	Update()
	{
		super.Update();

		if(this.ageInTicks % (Main.FPS / 5) == 0)
		{
			this.piercedEntities = [];
		}

		this.Rotation += MathHelper.randomInRange(70, 110);
		this.Rotation = MathHelper.ToAllowedAngle(this.Rotation);
	}
}
Projectile.Types(ExplosionSpark);class HolyBullet extends Projectile
{
	constructor(x, y, stats)
	{
		super(x, y, stats);

		this.width = 20;
		this.height = 20;

		this.Texture = "particleShine";
		this.Pierce = 20;
		this.Transparency = 0.9;
		this.moveParticle = null;

		//wbicie levela nie psuje accuracy
		this.missed = false;
	}
	
	Update()
	{
		this.Rotation += 20;
		if(this.ageInTicks%2 == 0)
		{
			this.Transparency = MathHelper.randomInRange(0.6, 1);
		}
		super.Update();
	}
}
Projectile.Types(HolyBullet);class FrogoPet extends Frogo
{
	constructor(x, y)
	{
		super(x, y, false);
		
		this.name = "ENTITY.FROGO.PET.NAME";

		this.AD = 10;
		this.SPD = 100;

        this.ATTACK_SPEED = 2;
        this.BULLET_SPEED = 6000;
        this.maxDistanceFromPlayer = 600;

        this.JumpDuration = .5;
        this.JumpDelay = 2;
        this.JumpDistance = this.SPD * 5;
        this.shakeOnJump = 0;
        this.knockBackResistance = 1;

        this.isFromPlayer = true;
        this.isBoss = false;
        this.isHurtAble = false;


        this.jumpDelays = {normal: 2, hurry: 1};

        // var bulletStats = 
		// {
		// 	Type: "BulletFrogTongue",
		// 	Scale: .1,
        //     damage: 0
		// };

        this.AI = new AI(this);

        this.AI.Apply(new AI_Jump(false, this.JumpDelay, this.JumpDelay, Entity, {focusPlayerOnPeaceful: true}));
		this.AI.Apply(new AI_AttackMelee(Entity, 0, 1));
        this.AI.Apply(new AI_Observe(Entity, this.JumpDistance, function(owner){return !owner.isJumping}));
		this.AI.Apply(new AI_Walk());
        // this.AI.Apply(new AI_AttackRange(Entity, bulletStats, {returnDeepInside: false, shootTrigger: function(o){return !o.isJumping}}));

        this.Model = new EntityFrogModel(this, 'entity.frogo.');

        this.defaultScale = 1;
        this.setScale(this.defaultScale);  

        this.LootTable = new LootTable([]);
        this.Immunity.ALL = true;
	}

    Update()
	{
		super.Update();

        if(!this.quote) this.quote = this.getDisplayName();

		var hide_time = Main.FPS * .5;
		var p = 0;
        var player = World.Player;
        var d = this.maxDistanceFromPlayer;

		if(World.isChangingLocation)
		{
			//hide when changing location
			p = 1 - (World.currentChangeTime / hide_time);
			if(p < 0) p = 0;
			this.Transparency = p;

            d /= 1000;

            if(p==0)
            {
                this.x = player.x;
                this.y = player.y;
            }
		}
		else
		{
			p = (World.timeSinceRoomChange / hide_time);
			if(p > 1) p = 1;

			this.Transparency = p;
		}

        if(MathHelper.GetDistance(this, World.Player) > d) 
        {
            this.AI.Jump.focus = Player;
            this.JumpDelay = this.jumpDelays.hurry;
            //tp to player if cannot jump to him
            if(MathHelper.GetDistance(this, World.CenterPoint) > World.Radius)
            {
                this.x = player.x;
                this.y = player.y;
            }
        }
        else 
        {
            this.AI.Jump.focus = Entity;
            this.JumpDelay = this.jumpDelays.normal;
        }
	}
}
World.RegisterEntity(FrogoPet);class TrapSpikes extends Entity
{
	constructor(x, y)
	{
		super(x, y);
		
		this.AD = 20;
		this.ATTACK_SPEED = .25;
		this.ATTACK_RANGE = 1000;
		this.FOLLOW_RANGE = 1000;
		this.Texture = "entity.trap.spikes";
		this.TextureOpen = "entity.trap.spikes.open";
		
		this.HitBox.Scale = 1;

        this.AI.Apply(new AI_AttackMelee(Player, this.AD));

		this.LootTable = new LootTable([]);
        this.isOpen = false;
        this.openAt = 0;

        this.isHurtAble = false;
        this.mustBeKilled = false;
        this.Immunity.ALL = true;
		this.hideOnRadar = true;

		this.setScale(3);
	}

    onMeleeAttack()
    {
        this.isOpen = true;
        this.openAt = this.ageInTicks;
    }
	
	Update()
	{
		super.Update();
		
        if(this.isOpen)
        {
            var time = Main.FPS / this.ATTACK_SPEED;
            if(this.ageInTicks - this.openAt >= time / 4) this.isOpen = false;
        }
	}

    RenderTexture(context)
    {
        var x = this.x - Camera.xView;
        var y = this.y - Camera.yView;

        var w = this.width;
        var h = this.height;

        Graphic.DrawRotatedImage(context, TextureManager.Get(this.Texture), x, y, w, h, this.Scale, 0, .25);
        if(this.isOpen) Graphic.DrawRotatedImage(context, TextureManager.Get(this.TextureOpen), x, y, w, h, this.Scale * 2);
    }
}
World.RegisterEntity(TrapSpikes);class InGame extends Interface
{
	static Initialize()
	{
		super.Initialize();
		this.RUNNING = RUNNING.INGAME;
		this.showMinimap = true;
		this.stageClear = false;
		this.stageClearTime = 5 * 60;
		this.pause = false;
		this.pauseTime = 0;
		this.lockEscape = false;
		this.stageClearTitleTime = 0;
		this.itemTitle = "";
		this.DeathScreenQuote = " ";
		this.levelInfoPos = [0, -50];

		this.UI_ID = 'ingame';

		this.heartTransition = new Transition(1, 1.5, 0.1, true, 0.05, 0.05);
		this.heartAnimation = -2;
		this.failScreenAlpha = new Transition(0, 0.8, 3);


		this.GUI = 
		{
			Map: new Map(),
			// Settings: new SettingsGUI(true),
			RunInfo: new RunInfo()
			// Dialog: new Dialog()
		};

		this.Scale = 1;
		this.heartAnimationLastTick = 0;
		this.heartDelay = 0;
		
		
		// this.Bars =
		// [
		// 	// new ProgressBar(20, 20, "barHP", World.Players[0].stats.MAXHP, World.Players[0].stats.MAXHP, function(){this.currentValue = World.Players[0].stats.HP; this.value = World.Players[0].stats.MAXHP}),
		// 	// new ProgressBar(20, 20, "barShield", World.Players[0].shield, World.Players[0].stats.MAXHP, function(){this.currentValue = World.Players[0].shield; this.value = World.Players[0].stats.MAXHP / 2; this.reverseProgressDisplay = true;}),
		// 	// new ProgressBar(19, 43, "barMP", 60, 0, function(){this.currentValue = Math.floor(World.Players[0].attackCharge); this.value = 60}),
			
		// 	new ProgressBar(50, 0, "barEXP", false, false, function()
		// 	{
		// 		this.style.width = canvas.width - 100;
		// 		this.y = canvas.height - 50;
				
		// 		this.currentValue = World.Players[0].oxygen;
		// 		this.value = World.Players[0].requiredOxygen;

		// 		InGame.levelInfoPos[0] = this.x;
		// 		InGame.levelInfoPos[1] = this.y - 15;
		// 		this.focusAble = false;
		// 		this.disabled = true;
		// 	}),
			
		// 	new ProgressBar(300, 0, "bossHP", false, false, function()
		// 	{
		// 		this.visible = false;
		// 		if(!World.Boss) return;
				
		// 		this.style.width = canvas.width - 600;
		// 		this.y = 30;
				
	
		// 		this.visible = true;
		// 		this.currentValue = World.Boss.HP;
		// 		this.value = World.Boss.MAXHP; 
		// 		this.innerHTML = "[BOSS] " + World.Boss.name;
		// 		this.focusAble = false;
		// 	})
		// ];

		// this.Buttons =
		// [
		// 	new Button(10, 0, 'ingameButton', '', false, 'options', function()
		// 	{
		// 		//Update
		// 		this.y = canvas.height - this.style.height - 10;
		// 		this.style.backgroundImage = 'gui.cog';
		// 	}, null, 
		// 	function()
		// 	{
		// 		InGame.pause = true;
		// 	})
		// ];
		
		this.PauseButtons =
		[
			new Button(-200, -200, "LargeButton", "Continue", false, "InGameContinue", function(){var center = Style.getCenterPosition("LargeButton"); this.x = center.x; this.y = center.y - 150}, false, function(){InGame.pause = false;}, false, false),
			new Button(-200, -200, "LargeButton", "Settings", false, "InGameContinue", function(){var center = Style.getCenterPosition("LargeButton"); this.x = center.x; this.y = center.y}, false, function(){InGame.GUI.Settings.Open = true;}, false, false),
			new Button(-200, -200, "LargeButton", "Quit", false, "InGameBack", function(){var center = Style.getCenterPosition("LargeButton"); this.x = center.x; this.y = center.y + 150}, false, function(){InGame.Transition(function(){Menu.Run();})}, false, false)
		];

		World.Initialize();
	}

	static Run()
	{
		super.Run();
		Graphic.showShader('background_transition');

		this.setHeartAnimationDelay();
	}

	static Pause()
	{
		this.pause = true;
		UI_Helper.Open('pause', false, null, function(){InGame.Resume()});
	}

	static Resume()
	{
		this.pause = false;
		UI_Helper.removeHistoryElement('pause');
	}

	static Quit()
	{
		this.Transition(function(){Menu.Run();});
		this.pause = true;
	}
	
	static Update()
	{
		this.backgroundTransparency = 0;
		Mouse.cursor = "default";

		if(!this.pause)
		{
			if(!World.Player.hand) Mouse.cursor = "ingame";
			World.Update();
			DamageIndicator.Update();

			InventoryGUI.updateItemsShine();
			DialogGUI.Update();
			AppearanceGUI.Update();
		}
		else
		{
			// Mouse.cursor = 'default';
			// if(!this.transition)
			// {
			// 	if(!this.GUI.Settings.Open)
			// 	{
			// 		for(var i = 0; i < this.PauseButtons.length; i++)
			// 		{
			// 			this.PauseButtons[i].Update();
			// 		}
			// 	}
			// }
		}


		this.Scale = (this.Scale > 2) ? 2 : this.Scale;
		this.Scale = (this.Scale < 1) ? 1 : this.Scale;

		//Skalowanie swiata
		if(Graphic.layersInfo[Graphic.Layer.BackgroundDecoration]) Graphic.layersInfo[Graphic.Layer.BackgroundDecoration].scale = this.Scale;
		if(Graphic.layersInfo[Graphic.Layer.Background]) Graphic.layersInfo[Graphic.Layer.Background].scale = this.Scale;
		if(Graphic.layersInfo[Graphic.Layer.Main]) Graphic.layersInfo[Graphic.Layer.Main].scale = this.Scale;
		if(Graphic.layersInfo[Graphic.Layer.Particle]) Graphic.layersInfo[Graphic.Layer.Particle].scale = this.Scale;

		if(World.Boss)
		{
			var boss_hp_progress = Math.round(World.Boss.HP / World.Boss.MAXHP * 100 * 100) / 100 + '%';
			var boss_hp_content = Math.round(World.Boss.HP) + ' / ' + World.Boss.MAXHP;

			UI_Helper.setBarProgress('boss_hp_bar', boss_hp_progress, true, boss_hp_content);
			set('#boss_name', 'dataset.name', World.Boss.getDisplayName(), true);
			set('#boss_hp_bar_container', 'style.display', '', true);
			set('#boss_hp_bar_container', 'dataset.poisoned', World.Boss.isPoisoned, true);
		}
		else
		{
			//thanks to this if, the boss hp bar will stay on screen after player death
			if(World.Player.isAlive) set('#boss_hp_bar_container', 'style.display', 'none', true);
		}
		
		if(!World.Player.isAlive)
		{
			Mouse.cursor = "default";
			return;
		} 

		// if((Settings.Controls.StateEscape) && (!this.GUI.Inventory.Open) && (!this.lockEscape) && (!this.GUI.Map.Open)&& (!this.GUI.Dialog.Open) && (!this.GUI.RunInfo.Open))
		// {
		// 	this.pause = (this.pause) ? false : true;
		// 	this.lockEscape = true;
		// }
		// else if(!Settings.Controls.StateEscape)
		// {
		// 	this.lockEscape = false;
		// }


		for(var name in this.GUI)
		{
			this.GUI[name].Update();
		}

		this.updateHeartAnimationDelay();
			
		super.Update();
	}

	static updateHeartAnimationDelay()
	{
		if(!this.heartDelay) return;

		if(this.heartAnimationLastTick + this.heartDelay <= Main.ageInTicks) 
		{
			UI_Helper.TriggerHeartAnimation();
			this.heartDelay = 0;
		}
	}

	static setHeartAnimationDelay(delay = 8 * Main.FPS)
	{
		this.heartDelay = delay;
		this.heartAnimationLastTick = Main.ageInTicks;
	}
	
	static Render()
	{
		World.Render();

		ChangeLayer(Graphic.Layer.GUI);
		
		super.Render();
		// if(World.Boss)
		// {
		// 	var obj = {};
		// 	obj.x = this.Bars[1].x;
		// 	obj.y = this.Bars[1].y + 2;
		// 	obj.style = Style.GetStyleByName("default");
		// 	obj.style.width = this.Bars[1].style.width;
		// 	obj.style.height = this.Bars[1].style.height;
		// 	obj.style.textAlign = "center";

		// 	var text = Math.round(World.Boss.HP) + "/" + World.Boss.MAXHP;
			
		// 	Style.FillText(ctx, obj, text);
		// }

		if(!this.transition)
		{
			// this.drawHearts();

			// var text = "Level: " + World.Player.stats.Level;
			// this.style = Style.GetStyleByName("menu");
			
			
			// this.style.fontSize = 20;
			// this.style.textAlign = "left";
			// Style.FillText(ctx, this, text, this.levelInfoPos[0], this.levelInfoPos[1]);
			

			if(Settings.General.showRadar) LocationRadar.Render();
			
			for(var name in this.GUI)
			{
				this.GUI[name].Render();
			}

			AppearanceGUI.Render();

			

			
			
			// var x = canvas.width - 150 - 10;
			
			// this.style.fontSize = 20;
			// this.style.width = 150;
			// this.style.textAlign = "center";
			// Style.FillText(ctx, this, text, x, 30);
			
			if(this.itemTitle)
			{
				this.style = Style.GetStyleByName("menu");
				this.style.fontSize = 30;
				Style.FillText(ctx, this, '"' + this.itemTitle + '"', canvas.width / 2, 150, null, null, 0.8);
			}

		}
		
		if(!World.Player.isAlive)
		{
			if(!UI_Helper.isOpen('death_screen'))
			{
				set('#death_screen_quote', 'innerText', this.DeathScreenQuote, true);
				UI_Helper.Open('death_screen', false);
			}
			

			// ChangeLayer(Graphic.Layer.Pause);

			// 	var alpha = this.failScreenAlpha.Update();

			// 	ctx.save();
			// 	ctx.fillStyle = "black";
			// 	ctx.globalAlpha = alpha;
			// 	ctx.fillRect(0, 0, canvas.width, canvas.height);
			// 	ctx.restore();

			// 	if(alpha == this.failScreenAlpha.To)
			// 	{
			// 		this.style = Style.GetStyleByName();
			// 		this.style.fontSize = 50;
			// 		Style.FillText(ctx, this, this.DeathScreenQuote, canvas.width / 2, canvas.height / 2 - 100);


			// 		this.style.fontSize = 30;
			// 		Style.FillText(ctx, this, 'Click to respawn', canvas.width / 2, canvas.height / 2 + 50);


			// 		if(Mouse.click)
			// 		{
			// 			Mouse.click = false;
			// 			World.Player.Respawn();
			// 		}
			// 	}
				

			// RestoreLayer();

			return;
		}
		
		if(this.pause)
		{
			// ChangeLayer(Graphic.Layer.Pause);
			// if(!this.transition && !this.GUI.Settings.Open)
			// {
			// 	var alpha = this.pauseTime / 3 / 10;
			// 	if(alpha > 0.7) alpha = 0.7;
				
			// 	ctx.save();
			// 	ctx.fillStyle = "black";
			// 	ctx.globalAlpha = alpha;
			// 	ctx.fillRect(0, 0, canvas.width, canvas.height);
			// 	ctx.restore();
				
			// 	for(var i = 0; i < this.PauseButtons.length; i++)
			// 	{
			// 		this.PauseButtons[i].Render();
			// 	}
				
			// 	this.pauseTime++;
			// }
			// RestoreLayer();
		}
		else 
		{
			if(this.showLevelUp)
			{
				this.showLevelUpMessage();
			}

			if(this.isRoomCleared)
			{
				if(!this.GUI.RunInfo.Open)
				{
					this.ShowTitle();
				}
			}

			this.pauseTime = 0;
		}
		
		if(!this.transition)
		{
			DamageIndicator.Render();

			if(World.Player.slow)
			{
				ctx.save();
				ctx.globalAlpha = 0.3;
				ctx.fillStyle = "white";
				ctx.fillRect(0, 0, canvas.width, canvas.height);
				ctx.restore();
			}
			
			var hurtTime = 8;
			if( (World.Player.timeSinceHurt > 0) && (World.Player.timeSinceHurt <= hurtTime))
			{
				var alpha = (Math.floor(World.Player.timeSinceHurt / (hurtTime / 2)) + (World.Player.timeSinceHurt % hurtTime) / 2) / 10;
				var width = canvas.width / 2;
				var height = canvas.height / 2;
				
				ctx.save();
				ctx.globalAlpha = alpha;
				
				var grd = ctx.createRadialGradient(width, height, 200, width, height, 800);
					grd.addColorStop(0, "rgba(255, 255, 255, 0)");
					grd.addColorStop(1, "red");
					
				ctx.fillStyle = grd;
				ctx.fillRect(0, 0, canvas.width, canvas.height);
				ctx.restore();
			}
		}

		set('#shader_background_transition', 'style.opacity', this.backgroundTransparency);

		if(KnowledgeGUI.isOpen) KnowledgeGUI.UpdatePreviews();
	}

	static showLevelUpMessage(init)
	{
		if(init)
		{
			this.levelUpTicks = 0;
			this.showLevelUp = true;
			this.levelUpTransition = new Transition(0, 1, 0.15, true, 0.5);
		}

		var time = 0.8 * Main.FPS;
		if(this.levelUpTicks > time)
		{
			this.showLevelUp = false;
			return;
		}

		var text = "Level Up!";
		var spd = 250;
		var x = World.Player.x - Camera.xView;
		var y = World.Player.y - Camera.yView;

		y -= this.levelUpTicks * spd * Main.DELTA;

		var alpha = this.levelUpTransition.Update();

		this.style.textAlign = 'center';
		this.style.fontSize = 35;

		Style.FillText(ctx, this, text, x, y, null, null, alpha);

		this.levelUpTicks++;
	}

	static ShowTitle(init, text)
	{
		if(init)
		{
			this.clearRoomTransition = new Transition(0, 1, 1.5, true, 1);
			this.isRoomCleared = true;
			this.customText = text;
		}

		var text = (World.Location.Perfect) ? "Perfect!" : "Clear!";
		if(this.customText)
		{
			text = this.customText;
		}
		this.style = Style.GetStyleByName("menu");
		this.style.fontSize = 150;

		var alpha = this.clearRoomTransition.Update();
		if(alpha == this.clearRoomTransition.From)
		{
			this.isRoomCleared = false;
		}

		var width = Style.GetTextSize(text, this.style);
		var scale = (canvas.width * .9) / width;

		if(scale < 1) this.style.fontSize *= scale;

		Style.FillText(ctx, this, text, canvas.width / 2, canvas.height / 2 - 40, null, null, alpha);
	}
	
	static StageClear()
	{
		var timeTo = Math.round(10 - (this.stageClearTime / 60));
		
		this.stageClearTime++;
		var text, text2;
		
		text = "";
		this.style = Style.GetStyleByName("menu");
		this.style.fontSize = 150;
		var alpha = 0.7;
		
		if(timeTo > 4)
		{
			text = (World.Location.Perfect) ? "Perfect!" : "Clear!";
			
			if(timeTo > 8)
			{
				alpha = (this.stageClearTime / 10) / 10;
			}
			else
			{
				alpha = 1 - ((this.stageClearTime -3 * 60) / 10) / 10;
			}
			
			if(alpha >= 0.7)
			{
				alpha = 0.7;
			}
			
			if(alpha < 0)
			{
				alpha = 0;
			}
			
			Style.FillText(ctx, this, text, canvas.width / 2, canvas.height / 2 - 40, null, null, alpha);

		}
		else
		{
			text = (timeTo - 1 > 0) ? timeTo - 1 : "Start!";			
			
			Style.FillText(ctx, this, text, canvas.width / 2, canvas.height / 2 - 40, null, null, alpha);
		}

		
		if(timeTo == 0)
		{
			if(World.Location instanceof TroubleBubble)
			{
				World.Location.NewStage();
			}
		}
	}
	
	static DrawMiniMap()
	{
		return;

		var width = 150;
		var height = 150;
		var point_size = 7;
		var entity_point = point_size - 2;
		
		var w_scale = (World.Radius * 2) / width;
		var h_scale = (World.Radius * 2) / height;
		
		var marginRight = 15;
		var x = canvas.width - width - marginRight;
		var y = 15;
		
		ctx.save();
		// ctx.fillStyle = "black";
		// ctx.globalAlpha = 0.2;
		ctx.fillStyle = "white";
		ctx.globalAlpha = 0.1;
		ctx.beginPath();
		ctx.arc(x + width / 2, y + height / 2, width / 2 + 5, 0, 2 * Math.PI);
		ctx.fill();
		ctx.restore();
		
		ctx.save();
		ctx.lineWidth = 5;
		ctx.strokeStyle  = "lightgray";
		ctx.beginPath();
		ctx.arc(x + width / 2, y + height / 2, (width / 2) + 5, 0, 2 * Math.PI);
		ctx.stroke();
		ctx.restore();
		
		if(World.isChangingLocation) return;
		//nie wyswietla obiektow podczas zmiany lokacji

		for(var i = 0; i < World.Entities.length; i++)
		{
			var s = 0;
			var color = "red";
			var entity = World.Entities[i];
			if(entity.isHidden) continue;
			if(entity.isFromPlayer) continue;		//do not show player dummies

			if( (entity instanceof Oxygen) || (entity instanceof EntityItem))
			{
				s = 3;
				color = "white";
				if(!entity.value)
				{
					//nie wyswietla na minimapie "pustych" tlenkow
					continue;
				}
			}
			
			if(entity instanceof EntityUpgrade)
			{
				s = 1;
				color = "yellow";
			}

			if(entity.isNPC)
			{
				color = 'white';
			}
			
			var px = (entity.x / w_scale) - ((World.Width / 2 - World.Radius) / w_scale) - entity_point - s + (marginRight / 2);
			var py = (entity.y / h_scale) - ((World.Width / 2 - World.Radius) / w_scale) - entity_point - s + (marginRight / 2);
			
			ctx.save();
			ctx.fillStyle = color;
			ctx.beginPath();
			ctx.arc(x + px, y + py, entity_point - s, 0, 2 * Math.PI);
			ctx.fill();
			ctx.restore();
		}
		
		var px = (World.Players[0].x / w_scale) - ((World.Width / 2 - World.Radius) / w_scale) - point_size + (marginRight / 2);
		var py = (World.Players[0].y / h_scale) - ((World.Width / 2 - World.Radius) / w_scale) - point_size + (marginRight / 2);
		
		ctx.save();
		ctx.fillStyle = "blue";
		ctx.beginPath();
		ctx.arc(x + px, y + py, point_size, 0, 2 * Math.PI);
		ctx.closePath();
		ctx.fill();
		ctx.restore();
	}

	static drawHearts()
	{
		this.heartAnimationTick = this.heartAnimationTick || 0;
		var heartAnimationDelay = 4 * Main.FPS;

		var heartValue = Player.GetHeartValue();

		var heartsInRow = 10;
		var heartFull = TextureManager.Get("heart");
		var heartHalf = TextureManager.Get("heart_half");
		var heartEmpty = TextureManager.Get("heart_empty");
		var heart;

		var hp = World.Player.stats.HP;
		var x = 10;
		var y = 10;
		var size = 32;
		var xStep = size;
		var yStep = (size / 2);

		var scale = this.heartTransition.Update();

		if(hp <= 2 * heartValue)
		{
			heartAnimationDelay = 0;
			if(hp == heartValue)
			{
				//dwa razy szybciej
				scale = this.heartTransition.Update();
			}
		}
		

		if(this.heartAnimation < hp / (2 * heartValue))
		{
			if(scale == this.heartTransition.From)
			{
				if(!this.lockHeartAnimation)
				{
					this.heartAnimation++;
					this.lockHeartAnimation = true;
				}
			}
			else
			{
				this.lockHeartAnimation = false;
			}
		}
		else
		{
			this.heartAnimationTick++;
			if(this.heartAnimationTick > heartAnimationDelay)
			{
				this.heartAnimation = 0;
				this.heartAnimationTick = 0;
				this.heartTransition.ageInTicks = 0;
			}
		}

		

		for(var i = 0; i < Math.floor(World.Player.stats.MAXHP / (2 * heartValue)); i++)
		{
			if(hp - 2 * heartValue >= 0)
			{
				heart = heartFull;
				hp -= 2 * heartValue;
			}
			else
			{
				heart = heartHalf;
				hp -= heartValue;
			}

			if(hp < 0)
			{
				heart = heartEmpty;
				hp -= 2 * heartValue;
			}

			if((this.heartAnimation == i) && (heart != heartEmpty))
			{
				ctx.drawImage(heart, x + (size - (size * scale)) / 2, y+ (size - (size * scale)) / 2, size * scale, size * scale);
			}
			else
			{
				ctx.drawImage(heart, x, y, size, size);
			}

			x += xStep;

			if(((i + 1) % heartsInRow == 0) && i != 0)
			{
				y += yStep;
				x -= xStep * heartsInRow;
			}
		}
	}
}
InterfaceControl.InitializeInterface(InGame);class Loading extends Interface
{
	static Initialize()
	{
		super.Initialize();
		this.UI_ID = 'loading_screen';
		this.ready = false;
	}
	
	static Update()
	{		
		if(this.ready) return;

		this.LoadProgress = Math.round( 
			(TextureManager.Loaded + SoundManager.Loaded) / 
			(TextureManager.ToLoad + SoundManager.ToLoad) * 100
		);

		UI_Helper.setBarProgress('loading_progress', this.LoadProgress + '%');

		if( (this.LoadProgress >= 100))
		{
			SoundManager.Ready = true;
			this.ready = true;
			document.getElementById('loading_ready').style.display = 'block';
			UI_Helper.Fade(function(){Menu.Run()}, 2);
		}
		
		super.Update();
	}
	
	static Render()
	{		
		ctx.save();
		ctx.fillStyle = "blue";
		ctx.globalAlpha = 0.5;
		ctx.fillRect(0, 0, canvas.width, canvas.height);
		ctx.restore();

		super.Render();
	}
}
InterfaceControl.InitializeInterface(Loading);class Menu extends Interface
{
	static Initialize()
	{
		super.Initialize();
		this.RUNNING = RUNNING.MENU;
		this.UI_ID = 'menu';
		this.ageInTicks = 0;

		var date = new Date();
		this.isValentineDay = (date.getDate() + "." + (date.getMonth() + 1) == "14.2") ? true : false;
		this.isChildrensDay = (date.getDate() + "." + (date.getMonth() + 1) == "1.6") ? true : false;
		
		this.bubbles = [];
		this.BubbleCount = 1024;
		this.currentBubbles = this.BubbleCount;
		
		for(var i = 0; i < this.BubbleCount; i++)
		{
			var scale = (MathHelper.randomInRange(8, 18) / 100);

			var x = MathHelper.randomInRange(0, canvas.width - 10);
			var y = MathHelper.randomInRange(0, canvas.height * 2);
			this.bubbles.push({x: x, y: y, scale: scale, texture: "bubble"});
		}
		
		this.Cwidth = canvas.width;
		
		this.titleY = -30;
		this.titleLoop = false;
		this.titleSpd = 350;
		this.titleRot = -1;
		this.bubbleSpd = 300;
		this.timeSinceShoot = 0;


		// this.Settings = new SettingsGUI();
	}

	static Run()
	{
		super.Run();
		SoundManager.Play("interface.MenuBackground", "BACKGROUND");
		Graphic.showShader('flare');
	}
	
	static Update()
	{			
		if(this.isShooting) Mouse.cursor = "ingame";

		if(!this.transition)
		{
			super.Update();

			SaveSelectionGUI.Update();
		}
	}
	
	static Render()
	{
		this.ageInTicks++;
		this.timeSinceShoot++;
		
		ctx.save();
		ctx.fillStyle = "#4a63e8";
		ctx.fillRect(0, 0, canvas.width, canvas.height);
		ctx.restore();
		
		var sc = 1;
		if(this.Cwidth < canvas.width)
		{
			sc = canvas.width / this.Cwidth;
		}
		
		for(var i = 0; i < this.bubbles.length; i++)
		{
			var bubble = this.bubbles[i];

			var texture = TextureManager.Get(bubble.texture);
			if(this.isValentineDay && bubble.texture != "bubble_pop")
			{
				texture = TextureManager.Get("valentineBubble");
			}
			if(this.isChildrensDay && bubble.texture != "bubble_pop")
			{
				texture = TextureManager.Get("valentineBubble");
			}
			
			if(bubble.texture == "bubble_pop")
			{
				var frames = texture.height / texture.width;
				if(this.ageInTicks % 5 ==0)
				{
					bubble.frame++;
				}
				
				if(bubble.frame >= frames)
				{
					bubble.frame = frames - 1;
					this.bubbles.splice(i, 1);
					i--;
				}
			}
			else
			{
				bubble.frame = 0;
				bubble.y -= this.bubbleSpd * bubble.scale * Main.DELTA;
				
				if(bubble.y < -100)
				{
					if(!this.transition)
					{
						bubble.y = canvas.height + 50;
					}
					else
					{
						this.bubbles.splice(i, 1);
						i--;
					}
				}

				var width = texture.width * bubble.scale;
				var height = texture.width * bubble.scale;
				
				
				if(!this.transition)
				{
					if(!Settings.Controls.StateMoveLeft) this.lockOsuKeyA = false;
					if(!Settings.Controls.StateMoveDown) this.lockOsuKeyS = false;

					//Klikniecie na babelki
					if(
						(Mouse.x >= bubble.x* sc) && (Mouse.x <= bubble.x* sc + width) && 
						(Mouse.y >= bubble.y) && (Mouse.y <= bubble.y + height) && 
						(
							(Mouse.click && !Mouse.lockClick) || 
							//for osu players xD
							(Settings.Controls.StateMoveLeft && !this.lockOsuKeyA) || 
							(Settings.Controls.StateMoveDown && !this.lockOsuKeyS)
						)
					)
					{
						this.bubbles[i].texture = "bubble_pop";

						texture = TextureManager.Get("bubble_pop");

						this.currentBubbles--;
						this.timeSinceShoot = 0;
						SoundManager.Play("effect.BubblePop", "EFFECT");
						Mouse.lockClick = true;

						if(Settings.Controls.StateMoveLeft) this.lockOsuKeyA = true;
						if(Settings.Controls.StateMoveDown) this.lockOsuKeyS = true;
					}
				}
			}
			
			var x = bubble.x * sc;
				
			ctx.drawImage(texture, 0, bubble.frame * texture.width, texture.width, texture.width, x, bubble.y, texture.width * bubble.scale, texture.width * bubble.scale);
		}
		
		var tittle = "Bubble Wars";
		var subtitle = " ";
		if(this.isValentineDay) subtitle = "Happy Valentine`s Day!";

		if(this.isChildrensDay) subtitle = "Happy Children`s Day! :)";

		this.style = Style.GetStyleByName("menu");
		
		
		this.titleY -= (this.titleSpd * Main.DELTA * this.titleRot) / 5;
		// var loop_y_min = 85;
		// var loop_y_max = 135;
		var loop_y_min = canvas.height * .12;	//12%
		var loop_y_max = canvas.height * .16;	//16%


		if(this.titleLoop)
		{
			if((this.titleY < loop_y_min) || (this.titleY > loop_y_max))
			{
				this.titleRot *= -1;
			}
		}
		
		if((this.titleY > loop_y_max - 5) && !this.titleLoop)
		{
			this.titleLoop = true;
			this.titleSpd = 150;
		}
		

		var bubbles_container = document.getElementById('menu_game_bubbles');
			bubbles_container.innerText = '';
		
		if(!this.transition)
		{
			Style.FillText(ctx, this, tittle, canvas.width / 2, this.titleY, null, null);
			this.style = Style.GetStyleByName("menu_subtitle");
			Style.FillText(ctx, this, subtitle, canvas.width / 2, this.titleY + 50, null, null);

			if(this.currentBubbles <= 1000)
			{
				this.isShooting = (this.timeSinceShoot < 2) ? true : this.isShooting;

				bubbles_container.innerText = "Bubbles: " + this.currentBubbles;
			}

			if(Settings.Controls.StateEscape)
			{
				if(this.timeSinceShoot < 3 * Main.FPS)
				{
					this.timeSinceShoot = 3 * Main.FPS;
				}
			}

			if(this.timeSinceShoot > 3 * Main.FPS) this.isShooting = false;

			document.getElementById('menu_buttons').dataset.fade = this.isShooting;

			SaveSelectionGUI.Render();
		}

		super.Render();
	}
	
	static Transition(onEnd)
	{
		UI_Helper.Hide();
		Graphic.hideShaders();
		this.bubbleSpd = 6000;
		super.Transition(onEnd);
	}
}
InterfaceControl.InitializeInterface(Menu);class Dialog
{
	constructor()
	{
		this.Open = false;

		this.LayoutHeight = 100;
		this.LayoutFrame = 0;
		this.LayoutFrames = Main.FPS / 2;
		this.x = 0;
		this.y = 0;
		this.Width = 0;
		this.Height = 100;
		this.innerMargin = 20;
		this.outerMargin = 100;

		this.charactersNum = 0;
		this.currentDialog = null;
	}

	static AddDialogLine(dialogLine)
	{
		if(!Dialog.DialogLines) Dialog.DialogLines = {};

		Dialog.DialogLines[dialogLine.id] = dialogLine;
	}

	Update()
	{
		return;
		if(InGame.pause) return;

		World.Player.isTalking = this.Open;
		if(!World.Player.canTalkWith) return;

		if((Settings.Controls.StateTalk) && (!this.lockOpen) && !InGame.GUI.Map.Open)
		{
			if(!InGame.GUI.Inventory.isShopOpen)
			{
				for(var name in InGame.GUI)
				{
					InGame.GUI[name].Open = false;
				}

				this.currentDialog = World.Player.canTalkWith.GetDialogLine();
				this.Open = true;
				this.lockOpen = true;
			}
		}
		else
		{
			if(!Settings.Controls.StateTalk)
			{
				this.lockOpen = false;
			}

			if(Settings.Controls.StateEscape) 
			{
				if(this.Open)
				{
					InGame.lockEscape = true;
					this.Open = false;
				}
			}
		}

		if(!this.Open)
		{
			this.charactersNum = 0;
		}
		else
		{
			Mouse.cursor = 'default';
		}

		


		this.Width = canvas.width - 2 * this.outerMargin;
		this.x = (canvas.width / 2) - (this.Width / 2);
		this.y = canvas.height - (this.LayoutHeight + this.Height + 50);
	}

	Render()
	{
		if(InGame.pause) 
		{
			this.LayoutFrame = 0;
			return;
		}

		this.LayoutFrame += (this.Open) ? 1 : -1;
		if(this.LayoutFrame < 0) 
		{
			this.LayoutFrame = 0;
			return;
		}

		if(this.LayoutFrame > this.LayoutFrames) this.LayoutFrame = this.LayoutFrames;

		this.charactersNum++;

		ChangeLayer(Graphic.Layer.GUI + 1);

			var margin = this.innerMargin;
			var height = this.LayoutHeight * (this.LayoutFrame / this.LayoutFrames);

			ctx.save();
			ctx.fillRect(0, 0, canvas.width, height);
			ctx.fillRect(0, canvas.height - height, canvas.width, height);
			ctx.restore();


			if(this.Open)
			{
				ctx.save();
				ctx.globalAlpha = 0.1;
				ctx.fillStyle = 'white';
				Graphic.roundRect(ctx, this.x - margin, this.y - margin, this.Width + 2 * margin, this.Height + 2 * margin, margin * 2, true, false);
				ctx.restore();



				if(this.currentDialog)
				{
					var optionsWidth = 150;
					var text = this.currentDialog.Text;
					var options = this.currentDialog.GetOptions();
					var x = this.x;
					var y = this.y;
					var maxTextWidth = this.Width - (optionsWidth + 50);

					this.style = Style.GetStyleByName("MenuInfo");
					this.style.fontSize = 20;
					this.style.textAlign = 'left';
					this.style.color = "lightblue";
					this.style.strokeColor = "#569af3";
					this.style.strokeSize = 3;

					var drawnCharacters = 0;

					var lines = Graphic.WrapText(text, maxTextWidth, this.style);
					var interline = 25;
					var drawOptions = true;

					for(var i = 0; i < lines.length; i++)
					{
						var textToDraw = " ";
						var line = lines[i];
						if(drawnCharacters + line.length < this.charactersNum)
						{
							textToDraw = line;
							drawnCharacters += line.length;

							Style.FillText(ctx, this, textToDraw, x, y + (interline * i));
						}
						else
						{
							var new_length = this.charactersNum - drawnCharacters;
							textToDraw = line.slice(0, new_length);

							Style.FillText(ctx, this, textToDraw, x, y + (interline * i));
							drawOptions = false;
							break;
						}
					}

					if(drawOptions)
					{
						this.style.textAlign = 'right';
						x = this.x + this.Width - (this.innerMargin / 2);
						for(var i = 0; i < options.length; i++)
						{
							text = options[i].Text;
							if(x - optionsWidth <= Mouse.x && x >= Mouse.x && y + (interline * i) < Mouse.y && y + (interline *(i + 1)) > Mouse.y)
							{
								text = "> " + text;
								if(Mouse.click)
								{
									if(isFunction(options[i].onClick)) options[i].onClick();
									Mouse.click = false;
								}
							}
							Style.FillText(ctx, this, text, x, y + (interline * i));
						}
					}
				}
			}
			

		RestoreLayer();

	}
}class Inventory
{
	constructor(owner)
	{
		this.Owner = owner;
		this.Open = false;
		this.isShopOpen = false;
		this.section = 0;
		this.x = 10;
		this.y = 150;
		this.Width = 206;
		this.Height = 430;
		this.backgroundColor = "rgba(255, 255, 255, 0.1)";
		this.style = Style.GetStyleByName("Default");
		this.hover = false;
		this.margin = 20;
		
		this.Slots = [[]];
		this.shopSlots = [];
		this.EqSlots = [];
		this.shopX = 0;
		this.shopY = 0;

		this.ItemInfoDisplay = new itemInfoDisplay();
		this.HoveredItem = null;
		
		this.EquipedItemInfoDisplay = new itemInfoDisplay();
		this.EquipedItemInfoDisplay.useMousePosition = false;

		this.shopOwner = null;
		
		this.createSlots();
	}

	OpenShop(shopOwner)
	{
		this.shopOwner = shopOwner;
		if(isFunction(shopOwner.onTrade)) shopOwner.onTrade();
		this.isShopOpen = true;
		this.Open = true;
	}
	
	
	Update()
	{
		if(InGame.pause) return;
		// if(InGame.GUI.Dialog.Open) return;

		if((Settings.Controls.StateOpenInventory) && (!this.lockInventory) && !InGame.GUI.Map.Open)
		{
			this.Open = (this.Open) ? false : true;
			this.isShopOpen = false;
			this.lockInventory = true;
		}
		else
		{
			if(!Settings.Controls.StateOpenInventory)
			{
				this.lockInventory = false;
			}

			if(Settings.Controls.StateEscape) 
			{
				if(this.Open)
				{
					InGame.lockEscape = true;
					this.Open = false;
					this.isShopOpen = false;
				}
			}
		}

		InGame.GUI.PlayerStats.Open = this.Open;

		if(!this.Open)
		{
			// if(this.Owner.hand)
			// {
			// 	this.Owner.addItemToInventory(this.Owner.hand);
			// 	this.Owner.hand = null;
			// }
			return;
		}
		// Mouse.cursor = 'default';
		if(this.Owner.hand || this.hover) Mouse.cursor = 'default';
		if(this.hover)
		{
			this.Owner.allowAttack = false;
		}

		if(InGame.GUI.RunInfo.Open) return;
		var i;
		this.hover = false;
		

		this.x = (canvas.width / 2) - (this.Width / 2);
		this.y = (canvas.height / 2) - (this.Height / 2);

		if(this.isShopOpen)
		{
			this.Owner.allowControl = false;
			this.Owner.allowMove = false;
			InGame.GUI.PlayerStats.Open = false;
			var maxSpaceBetweenShops = 100;
			var spaceBetweenShops = canvas.width - 2 * this.Width;
			if(spaceBetweenShops > maxSpaceBetweenShops) spaceBetweenShops = maxSpaceBetweenShops;

			this.x = (canvas.width / 2) - this.Width - spaceBetweenShops / 2;
			this.shopY = this.y;
			this.shopX = this.x + this.Width + spaceBetweenShops;

			for(i = 0; i < this.shopSlots.length; i++)
			{
				this.shopSlots[i].Owner = this.shopOwner;
				this.shopSlots[i].Update();
			}
		}
		else
		{
			for(i = 0; i < this.EqSlots.length; i++)
			{
				this.EqSlots[i].Update();
			}
		}


		this.equipmentSlotsX = canvas.width - (55 + 2 * this.margin);
		this.equipmentSlotsWidth = 60;
		this.radius = this.margin;

		//zapobiega na strzelanie podczas przesuwania przedmiotow
		if(
			Mouse.CheckHoverState(this.x - this.margin, this.y - this.margin, this.Width + 2 * this.margin, this.Height + 2 * this.margin) ||		//inventory
			Mouse.CheckHoverState(this.equipmentSlotsX, this.y - this.margin, this.equipmentSlotsWidth + this.margin, this.Height + 2 * this.margin) ||		//equipements
			(Mouse.CheckHoverState(this.shopX - this.margin, this.shopY - this.margin, this.Width + this.margin, this.Height + 2 * this.margin) && this.isShopOpen)//shop
		)
		{
			this.hover = true;
		}


		for(i = 0; i < this.Slots[this.section].length; i++)
		{
			this.Slots[this.section][i].Update();

			this.Slots[this.section][i].disabled = (i < this.Owner.stats.availableSlots) ? false : true;
		}

		this.ItemInfoDisplay.Update();
		this.EquipedItemInfoDisplay.Update();
	}
	
	Render()
	{
		if(!this.Open || InGame.GUI.Map.Open) return;
		if(InGame.pause) return;
		if(InGame.GUI.RunInfo.Open) return;


		var margin = this.margin;
		var infoColor = "lightblue";
		var infoStroke = "#569af3";

		//inventory slots background
		ctx.save();
		ctx.fillStyle = this.backgroundColor;
		Graphic.roundRect(ctx, this.x - margin, this.y - margin, this.Width + 2 * margin, this.Height + 2 * margin, this.radius, true, false);
		ctx.restore();

		this.style = Style.GetStyleByName("Default");

		var text = Lang.Translate('OXYGEN') + ":  " + ((this.Owner.coins > 0) ? Style.DottedText(this.Owner.coins) : this.Owner.coins);
		Style.FillText(ctx, this, text, false, (this.y + this.Height) - 20, infoColor, infoStroke);


		


		var i;

		if(!this.isShopOpen)
		{
			//equipment slots background
			ctx.save();
			ctx.fillStyle = this.backgroundColor;
			Graphic.roundRect(ctx, this.equipmentSlotsX, this.y - margin, this.equipmentSlotsWidth +  margin, this.Height + 2 * margin, this.radius, true, false);
			ctx.restore();

			for(i = 0; i < this.EqSlots.length; i++)
			{
				this.EqSlots[i].Render();
			}
		}
		else
		{
			ctx.save();
			ctx.fillStyle = this.backgroundColor;
			Graphic.roundRect(ctx, this.shopX - margin, this.shopY - margin, this.Width + 2 * margin, this.Height + 2 * margin, this.radius, true, false);
			ctx.restore();

			for(i = 0; i < this.shopSlots.length; i++)
			{
				this.shopSlots[i].Render();
			}

			text = "Trade with  " + this.shopOwner.name;
			this.style.textAlign = 'center';
			this.style.fontSize = 25;
			Style.FillText(ctx, this, text, canvas.width / 2, this.y - 80, infoColor, infoStroke);
		}
		
						
		
		
		for(i = 0; i < this.Slots[this.section].length; i++)
		{
			this.Slots[this.section][i].Render();
		}

		

		if(this.Owner.hand)
		{
			var item = this.Owner.hand;
			var scale = 1.5;
			var width = this.Slots[0][0].Width * scale;
			var height = this.Slots[0][0].Height * scale;

			ctx.drawImage(TextureManager.Get(item.Texture), Mouse.x - width / 2, Mouse.y - height / 2, width, height);
			item.DrawShine(Mouse.x - width / 2 + (15 * scale), Mouse.y - height / 2 + (15 * scale), scale);

			if(item.count > 1)
			{
				Style.FillText(ctx, this, item.count, Mouse.x + (width / scale) / 4, Mouse.y - 10 + (height / scale) / 4);
			}
			
		}

		this.ItemInfoDisplay.Render();
		this.EquipedItemInfoDisplay.Render();
	}
	
	
	createSlots()
	{
		var cols = 9;
		var rows = 7;
		var odstep = 55;
		var sections = 5;		//liczba sekcji slotow		(dostepne sa 4 dla gracza, + 1 dodatkowa)
		var id = 0;

		var armor_cols = 2;
		var armor_rows = 7;
		var armor_slot = 0;


		this.Width = cols * odstep;
		this.Height = (rows * odstep) + 20;
		
		for( var i = 0; i < sections; i++)
		{
			this.Slots[i] = [];
			for(var j = 0; j < rows; j++)
			{
				for(var k = 0; k < cols; k++)
				{
					var button = new InventorySlot((k * odstep), (j * odstep), false, "slot" + id, this.Owner, function()
					{
						this.x = InGame.GUI.Inventory.x + this.posX;
						this.y = InGame.GUI.Inventory.y + this.posY;
					});
						
					if(id >= this.Owner.stats.availableSlots)
					{
						button.disabled = true;
					}

					button.posX = (k * odstep);
					button.posY = (j * odstep);
					button.opacity = 0.8;

					this.Slots[i].push(button);
					id++;
				}
			}
		}



		var shopId = 0;


		for(var j = 0; j < rows; j++)
		{
			for(var k = 0; k < cols; k++)
			{
				var button = new InventorySlot((k * odstep), (j * odstep), false, "slot" + shopId, null, function()
				{
					this.x = InGame.GUI.Inventory.shopX + this.posX;
					this.y = InGame.GUI.Inventory.shopY + this.posY;

					this.disabled = false;

					if(this.Owner)
					{
						var item = this.GetItem();
						var id = parseInt(this.id.replace('slot', ''));
						if(id >= this.Owner.stats.availableSlots)
						{
							this.disabled = true;
						}

						if(item)
						{
							// item.price = item.buyPrice;
							item.isInShop = true;
						}
					}
				});

				button.RightClick = function()
				{
					var item = this.GetItem();
					if(!this.Owner) return;
					if(!item) return;

					var id = parseInt(this.id.replace('slot', ''));
					
					if(item.stackAble && item.count >= 1) this.Owner.sellCountable(id, InGame.GUI.Inventory.Owner);
					else this.Owner.Sell(id, InGame.GUI.Inventory.Owner);
				};

				button.Click = function(){
					if(!this.Owner) return;

					var id = parseInt(this.id.replace('slot', ''));

					var item = this.GetItem();
					if(!item)
					{
						if(InGame.GUI.Inventory.Owner.hand)
						{
							//sell
							this.Owner.Buy(InGame.GUI.Inventory.Owner.hand, InGame.GUI.Inventory.Owner);
						}
					}
					else
					{
						if(InGame.GUI.Inventory.Owner.hand)
						{
							//sell
							this.Owner.Buy(InGame.GUI.Inventory.Owner.hand, InGame.GUI.Inventory.Owner);
						}
						else
						{
							//buy
							this.Owner.Sell(id, InGame.GUI.Inventory.Owner, true);
						}
					}
				};

				button.posX = (k * odstep);
				button.posY = (j * odstep);
				button.opacity = 0.8;

				this.shopSlots.push(button);
				shopId++;
			}
		}



		
		var method = function()
		{
			this.x = canvas.width - 80;
			this.y = InGame.GUI.Inventory.y + this.posY;
		};
		
		//cannon
		this.EqSlots[0] = new InventorySlot(canvas.width, this.y, false, "slot141", this.Owner, method);
		this.EqSlots[0].posY = 10;
		
		//drive
		this.EqSlots[1] = new InventorySlot(canvas.width, this.y + odstep, false, "slot142", this.Owner, method);
		this.EqSlots[1].posY = 10 + odstep;
		
		//ammo
		this.EqSlots[2] = new InventorySlot(canvas.width, this.y + ( 2* odstep), false, "slot143", this.Owner, method);
		this.EqSlots[2].posY = 10 + 2 * odstep;



		//special1
		this.EqSlots[3] = new InventorySlot(canvas.width, this.y + ( 2* odstep), false, "slot144", this.Owner, method);
		this.EqSlots[3].posY = 10 + 3 * odstep;

		//special2
		this.EqSlots[4] = new InventorySlot(canvas.width, this.y + ( 2* odstep), false, "slot145", this.Owner, method);
		this.EqSlots[4].posY = 10 + 4 * odstep;

		//special3
		this.EqSlots[5] = new InventorySlot(canvas.width, this.y + ( 2* odstep), false, "slot146", this.Owner, method);
		this.EqSlots[5].posY = 10 + 5 * odstep;

		//special4
		this.EqSlots[6] = new InventorySlot(canvas.width, this.y + ( 2* odstep), false, "slot147", this.Owner, method);
		this.EqSlots[6].posY = 10 + 6 * odstep;
		
		
		for(var i = 0; i < this.EqSlots.length; i++)
		{
			this.EqSlots[i].opacity = 0.8;
			this.EqSlots[i].imgEmpty = this.EqSlots[i].getArmorSlot(i + 141).replace("EQUIPMENT_SLOT_", "").replace("0", "").replace("1", "").replace("2", "").replace("3", "").toLowerCase() + "_empty";
		}
		
	}
}class Map
{
	constructor()
	{
		this.MapScale = 1.3;
		this.Open = false;
		this.hover = false;

		this.MapControls =
		[
			new Button(-200, 10, "WorldMapSwitch", " ", false, "WorldMapLocation", function()
			{
				this.text = World.Location.Name;
				var style = Style.GetStyleByName(this.className);
				this.style.width = Style.GetTextSize(this.text, style).width + 20;
				this.disabled = (InGame.GUI.Map.WorldMapShowing == "LOCATION") ? true : false;

				if(this.hover)  World.Player.allowAttack = false;

			}, false, function(){InGame.GUI.Map.WorldMapShowing = "LOCATION";}, false, false),
			
			new Button(-200, 10, "WorldMapSwitch", " ", false, "WorldMapWorld", function()
			{
				this.text = Lang.Translate('WORLD_MAP');
				var style = Style.GetStyleByName(this.className);
				this.style.width = Style.GetTextSize(this.text, style).width + 20;
				this.disabled = (InGame.GUI.Map.WorldMapShowing == "WORLD") ? true : false;

				if(this.hover)  World.Player.allowAttack = false;

			}, false, function(){InGame.GUI.Map.WorldMapShowing = "WORLD";}, false, false),
		];

		this.CurrentRoomTransition = new Transition(0, 360, 2, false, 0, 0, true);
	}

	Update()
	{	
		if(InGame.pause) return;
		// if(InGame.GUI.Dialog.Open) return;
		// if(InGame.GUI.Inventory.isShopOpen) return;

		if((Settings.Controls.StateMap) && (!this.lockMap))
		{
			this.Open = (this.Open) ? false : true;
			this.lockMap = true;
			// InGame.GUI.Inventory.Open = false;
		}
		else if((!Settings.Controls.StateMap) || Settings.Controls.StateEscape)
		{
			this.lockMap = false;
			if(Settings.Controls.StateEscape) 
			{
				if(this.Open)
				{
					InGame.lockEscape = true;
					this.Open = false;
				}
			}
		}

		this.allowMap = true;
		if(World.Location)
		{
			if(!World.Location.allowMap)
			{
				this.WorldMapShowing = "WORLD";
				this.allowMap = false;
				return;
			}
		}


		if(this.Open)
		{
			for(var i = 0; i < this.MapControls.length; i++)
			{
				this.MapControls[i].Update();
			}

			Mouse.cursor = 'default';
			if(this.hover) {World.Player.allowAttack = false;}
		}
		
	}

	Render()
	{
		if(InGame.pause && this.Open) return;

		this.style = Style.GetStyleByName("menu");
		this.style.fontSize = 20;
		this.style.textAlign = "left";

		if(!this.Open && !InGame.GUI.Inventory.Open && this.allowMap && Settings.General.showMinimap)
		{
			this.DrawSmallMap();
		}
		else if(this.Open)
		{
			this.DrawMap();
		}
	}


	DrawSmallMap()
	{
		this.DrawMap(true);
	}

	DrawMap(isSmallVersion)
	{
		if(!World.Location) return;
		if(!World.Location.Rooms) return;

		var Rooms = World.Location.Rooms;

		var RoomsInRow = Rooms[0].length;
		var RoomsInColl = Rooms.length;

		var startRoomY = 0;
		var startRoomX = 0;

		var scale = this.MapScale;

		if(isSmallVersion)
		{
			var currentRoom = MathHelper.GetRoomByIndex(Rooms, World.Location.Room);

			scale = 0.4;
			if(RoomsInRow > 5)
			{
				var maxRow = RoomsInRow;
				startRoomX = currentRoom.x - 2;
				startRoomX = (startRoomX < 0) ? 0 : (startRoomX > maxRow - 5) ? maxRow - 5 : startRoomX;
				RoomsInRow = 5 + startRoomX;
				RoomsInRow = (RoomsInRow > maxRow) ? maxRow : RoomsInRow;
			}

			if(RoomsInColl > 5)
			{
				var maxColl = RoomsInColl;
				startRoomY = currentRoom.y - 2;
				startRoomY = (startRoomY < 0) ? 0 : (startRoomY > maxColl - 5) ? maxColl - 5 : startRoomY;
				RoomsInColl = 5 + startRoomY;
				RoomsInColl = (RoomsInColl > maxColl) ? maxColl : RoomsInColl;
			}
		}
		
		var roomRadius = 25 * scale;
		var roomLine = 7.5 * scale;
		var space = 25 * scale;

		var mapWidth = (Rooms[0].length * roomRadius * 2) + ((Rooms[0].length - 1) * space);
		var mapHeight = (Rooms.length * roomRadius * 2) + ((Rooms.length - 1) * space);

		var minMargin = 100;

		if(mapHeight + minMargin > canvas.height)
		{
			this.MapScale = Math.round((canvas.height / mapHeight) * 10) / 10;
			//zapobiega "mignieciu" mapy podczas przeskalowania
			return;
		}



		var startX = (canvas.width - mapWidth) / 2;
		var startY = (canvas.height - mapHeight) / 2;

		if(isSmallVersion)
		{
			var width = ((RoomsInRow - startRoomX) * roomRadius * 2) + ((RoomsInRow - startRoomX) * space);
			startX = canvas.width - (width + 20);
			startY = (Settings.General.showRadar) ? 150 + 40 : 30;

			ctx.save();
			ctx.globalAlpha = 0.1;
			ctx.fillStyle = "white";
			Graphic.roundRect(ctx, startX - 10, startY - 10, width + 10, width + 10, 20, true);
			ctx.restore();
		}
		else
		{
			ctx.save();
			ctx.globalAlpha = 0.1;
			ctx.fillStyle = "white";
			Graphic.roundRect(ctx, startX - 10, startY - 10, mapWidth + 20, mapHeight + 20, 20, true);
			ctx.restore();

			// var y = 30;
			// var text =  World.Location.Name;

			// this.style.fontSize = 30;
			// this.style.width = 1;
			// this.style.textAlign = "center";
			// Style.FillText(ctx, this, text, canvas.width / 2, y);

			this.hover = false;
			if(Mouse.x >= startX && Mouse.x <= (startX + mapWidth) && Mouse.y >= startY && Mouse.y <= (startY + mapHeight))
			{
				this.hover = true;
			}
		}


		var angle = this.CurrentRoomTransition.Update();

		var roomsToDraw = [];

		for(var i = startRoomY; i < RoomsInColl; i++)
		{
			for(var j = startRoomX; j < RoomsInRow; j++)
			{
				var room = Rooms[i][j];
				
				if(!room) continue;
				if((!room.playerWasThere) && (!Main.UnlockMiniMap)) continue;

				var sides = Room.GetRoomsOnSides(Rooms, {x: j, y: i});
				if(sides.top)
				{
					var nextRoomPos = Room.GetRoomOnSide({x: j, y: i}, SIDE.TOP, Rooms);
					var nextRoom = Rooms[nextRoomPos.y][nextRoomPos.x];
					if(nextRoom != null && !nextRoom.playerWasThere && room.isCleared)
					{
						var isSecret = (nextRoom.isSecretChamber) ? true : false;
						var info = {i: nextRoomPos.y, j: nextRoomPos.x, isCleared: nextRoomPos.isCleared, playerWasThere: false, isSecret: isSecret, isCurrent: false, isBoss: nextRoom.isBossChamber};
						roomsToDraw.push(info);
					}
				}

				if(sides.left)
				{
					var nextRoomPos = Room.GetRoomOnSide({x: j, y: i}, SIDE.LEFT, Rooms);
					var nextRoom = Rooms[nextRoomPos.y][nextRoomPos.x];
					if(nextRoom != null && !nextRoom.playerWasThere && room.isCleared)
					{
						var isSecret = (nextRoom.isSecretChamber) ? true : false;
						var info = {i: nextRoomPos.y, j: nextRoomPos.x, isCleared: nextRoomPos.isCleared, playerWasThere: false, isSecret: isSecret, isCurrent: false, isBoss: nextRoom.isBossChamber};
						roomsToDraw.push(info);
					}
				}

				if(sides.right)
				{
					var nextRoomPos = Room.GetRoomOnSide({x: j, y: i}, SIDE.RIGHT, Rooms);
					var nextRoom = Rooms[nextRoomPos.y][nextRoomPos.x];
					if(nextRoom != null && !nextRoom.playerWasThere && room.isCleared)
					{
						var isSecret = (nextRoom.isSecretChamber) ? true : false;
						var info = {i: nextRoomPos.y, j: nextRoomPos.x, isCleared: nextRoomPos.isCleared, playerWasThere: false,isSecret: isSecret, isCurrent: false, isBoss: nextRoom.isBossChamber};
						roomsToDraw.push(info);
					}
				}

				if(sides.bottom)
				{
					var nextRoomPos = Room.GetRoomOnSide({x: j, y: i}, SIDE.BOTTOM, Rooms);
					var nextRoom = Rooms[nextRoomPos.y][nextRoomPos.x];
					if(nextRoom != null && !nextRoom.playerWasThere && room.isCleared)
					{
						var isSecret = (nextRoom.isSecretChamber) ? true : false;
						var info = {i: nextRoomPos.y, j: nextRoomPos.x, isCleared: nextRoomPos.isCleared, playerWasThere: false,isSecret: isSecret, isCurrent: false, isBoss: nextRoom.isBossChamber};
						roomsToDraw.push(info);
					}
				}

				var current = false;
				if(room.id == World.Location.Room)
				{
					current = true;
				}

				var isSecret = (room.isSecretChamber) ? true : false;

				var info = {i: i, j: j, isCleared: room.isCleared, playerWasThere: room.playerWasThere, isSecret: isSecret, isCurrent: current, isBoss: room.isBossChamber, isStart: room.isStartChamber};
				roomsToDraw.push(info);
			}
		}

		//zapobiega nawarstwianiu sie pokoi
		var alreadyDrawn = [[]];

		for(var i = 0; i < roomsToDraw.length; i++)
		{
			var info = roomsToDraw[i];
			var text = null;
			var textColor = "white";

			if(info.j- startRoomX >= (RoomsInRow - startRoomX)) continue;
			if(info.i- startRoomY >= (RoomsInColl- startRoomY)) continue;
			if(info.i < startRoomY) continue;
			if(info.j < startRoomX) continue;

			var sides = Room.GetRoomsOnSides(Rooms, {x: info.j, y: info.i});
			var x = startX + ((info.j - startRoomX) * roomRadius * 2) + ((info.j - startRoomX) * space) + roomRadius;
			var y = startY + ((info.i - startRoomY) * roomRadius * 2) + ((info.i - startRoomY) * space) + roomRadius;
			// var x2 = startX + (info.j * roomRadius * 2) + (info.j * space);
			// var y2 = startY + (info.i * roomRadius * 2) + (info.i * space);

			if(alreadyDrawn[info.i])
			{
				if(alreadyDrawn[info.i][info.j])
				{
					continue;
				}
			}
			else
			{
				alreadyDrawn[info.i] = [];
			}
			alreadyDrawn[info.i][info.j] = true;

			var roomBackground = "blue";
			var roomStroke = "blue";

			if(info.isBoss)
			{
				if(info.isCleared)
				{
					roomBackground = "#b40000";
					roomStroke = "#b40000";
					text = "\u2714";
					textColor = roomStroke;
				}
				else
				{
					roomBackground = "red";
					roomStroke = "red";
				}
			}
			else if(info.isSecret)
			{
				if(info.playerWasThere)
				{
					textColor = "black";
				}
				roomBackground = "#222222";
				roomStroke = "#232323";
				text = "?";
			}
			else if(!info.isCleared)
			{
				roomBackground = "gray";
				roomStroke = "lightgray";
			}

			var isSelected = false;
			if(info.isStart)
			{
				roomBackground = "yellow";
				roomStroke = "yellow";
			}

			if(!isSmallVersion && (
				Main.UnlockMiniMap || (World.Player.canFastTravel && info.isCleared) || info.isStart
			))
			{
				var dist = MathHelper.GetDistance([x, y], [Mouse.x, Mouse.y]);
				if((dist < roomRadius) && (World.Location.isCleared) && !World.isChangingLocation)
				{
					if(!info.isCurrent)
					{
						isSelected = true;
						if(Mouse.click)
						{
							Mouse.lockClick = true;
							Mouse.click = false;
							this.Open = false;
							Commands.GoToRoom(info.i, info.j, 2);
						}
					}
				}
			}

			ctx.save();
			ctx.globalAlpha = 0.5;
			ctx.fillStyle = roomBackground;
			ctx.beginPath();
			ctx.arc(x, y, roomRadius, 0, Math.PI * 2);
			ctx.fill();
			ctx.closePath();
			ctx.restore();

			if(info.isCurrent || isSelected)
			{
				ctx.save();
				ctx.globalAlpha = (isSelected) ? 0.5 : 1;
				ctx.lineWidth = roomLine;
				ctx.strokeStyle = "white";
				Graphic.drawCircleWithBreaks(ctx, x, y, roomRadius + (space / 2), 4, 30, true, false, angle);
				ctx.restore();
			}

			ctx.save();
			ctx.lineWidth = roomLine;
			ctx.strokeStyle = roomStroke;
			Graphic.drawCircleWithBreaksOnSides(ctx, x, y, roomRadius, sides, 30, true);
			ctx.restore();

			if(text)
			{
				this.style.fontSize = roomRadius * 1.6;
				this.style.width = roomRadius * 2;
				this.style.height = roomRadius * 2.4;
				this.style.textAlign = "center";
				this.style.strokeSize = 0;
				this.style.fontWeight = "";
				Style.FillText(ctx, this, text, x - roomRadius, y - roomRadius, textColor);
			}
		}
	}

	DrawWorldMap()
	{
		return;
		ctx.save();
		ctx.globalAlpha = 0.4;
		ctx.fillRect(0, 0, canvas.width, canvas.height);
		ctx.restore();

		var toRender = [];
		var size = 10;
		var color = "white";
		var angle = this.CurrentRoomTransition.Update();

		var minMargin = 150;
		var height = canvas.height - minMargin;
		var width = height * 1.5;

		var startX = (canvas.width - width) / 2;
		var startY = (canvas.height - height) / 2;

		ctx.save();
		ctx.globalAlpha = 0.1;
		ctx.fillStyle = "white";
		Graphic.roundRect(ctx, startX - 10, startY - 10, width + 20, height + 20, 20, true);
		ctx.restore();

		if(Mouse.x >= startX && Mouse.x <= (startX + width) && Mouse.y >= startY && Mouse.y <= (startY + height))
		{
			World.Player.allowAttack = false;
		}

		// console.log(width + " / " + height);


		// var y = 30;
		// var text =  "World Map";

		// this.style.fontSize = 30;
		// this.style.width = 1;
		// this.style.textAlign = "center";
		// Style.FillText(ctx, this, text, canvas.width / 2, y);

		if(this.allowMap)
		{
			var sX = (canvas.width / 2) - (this.MapControls[0].style.width + this.MapControls[1].style.width) / 2;
			var _space = 20;

			this.MapControls[0].x = sX - _space;
			this.MapControls[0].Render();

			
			this.MapControls[1].x = sX + this.MapControls[0].style.width + _space;
			this.MapControls[1].Render();
		}
		else
		{
			var sX = (canvas.width / 2) - this.MapControls[1].style.width / 2;

			this.MapControls[1].x = sX;
			this.MapControls[1].Render();
		}


		this.style = Style.GetStyleByName("MenuInfo");
		this.style.textAlign = "center";

		

		for(var locationName in World.LocationList)
		{
			var location = World.LocationList[locationName];

			if(World.Player.locationInfo[locationName])
			{
				var prevLocationCleared = false;
				if(location.reqPrevLocation)
				{
					if(World.Player.locationInfo[location.reqPrevLocation])
					{
						if(World.Player.locationInfo[location.reqPrevLocation].isCleared)
						{
							prevLocationCleared = true;
						}
					}
				}
				

				if( (World.Player.locationInfo[locationName].isCleared) || (prevLocationCleared) )
				{
					toRender[locationName] = 
					{
						pos: location.MapPos,
						isVillage: location.isVillage,
						specialIcon: location.specialIcon,
						name: location.Name,
						id: locationName,
						requiredLevel: location.requiredLevel,
						canPlayerEnter: (location.requiredLevel > World.Player.stats.Level) ? false : true,
						isCurrent: (locationName == World.Location.constructor.name) ? true : false,
						isCleared: World.Player.locationInfo[locationName].isCleared,
						rank: World.Player.locationInfo[locationName].rank
					};
				}
			}
		}

		var tCanvas = document.createElement("canvas");
			tCanvas.width = canvas.width;
			tCanvas.height = canvas.height;
		var tCtx = tCanvas.getContext("2d");


		for(var locationName in toRender)
		{
			var loc = toRender[locationName];
			var x = startX + loc.pos.x;
			var y = startY + loc.pos.y;
			var isSelected = false;
			//sprawdzanie czy ma zostac wyswietlony


			var dist = MathHelper.GetDistance([x,  y], [Mouse.x, Mouse.y]);
			if((dist < size) && (World.Location.isCleared) && !World.isChangingLocation)
			{
				isSelected = true;
				if(!loc.isCurrent && loc.canPlayerEnter)
				{
					if(Mouse.click)
					{
						Mouse.lockClick = true;
						Mouse.click = false;
						this.Open = false;
						Commands.GoToLocation(loc.id);
					}
				}
			}


			if(loc.isVillage)
			{
				color = "white";
			}
			else if(loc.isCleared)
			{
				color = "yellow";
			}
			else
			{
				color = "red";
			}

			//sciezki
			if(World.LocationList[loc.id].reqPrevLocation)
			{
				var x2 = startX + toRender[World.LocationList[loc.id].reqPrevLocation].pos.x;
				var y2 = startY + toRender[World.LocationList[loc.id].reqPrevLocation].pos.y;

				ctx.save();
				ctx.strokeStyle = "white";
				ctx.lineWidth = 5;
				ctx.beginPath();
				ctx.setLineDash([5, 10]);
				ctx.moveTo(x, y);
				ctx.lineTo(x2, y2);
				ctx.stroke();
				ctx.closePath();
				ctx.restore();
			}


			tCtx.save();
			tCtx.fillStyle = color;
			tCtx.beginPath();
			tCtx.arc(x, y, size, 0, Math.PI * 2);
			tCtx.fill();
			tCtx.closePath();
			tCtx.restore();
			
			//gdzies tutaj jest problem

			if(isSelected || loc.isCurrent)
			{
				tCtx.save();
				tCtx.globalAlpha = (isSelected) ? 0.5 : 1;
				tCtx.lineWidth = 2;
				tCtx.strokeStyle = "white";
				Graphic.drawCircleWithBreaks(tCtx, x, y, size + 5, 4, 30, true, false, angle);
				tCtx.restore();

				if(isSelected)
				{
					var text = loc.name;
					
					if(!loc.canPlayerEnter)
					{
						text += " (lv." + loc.requiredLevel + "+)";
					}
					Style.FillText(tCtx, this, text, Mouse.x, Mouse.y - 30);
				}
			}

			ctx.drawImage(tCanvas, 0, 0);


			if(loc.rank)
			{
				var colors = RunInfo.GetRankColor(loc.rank);

				Style.FillText(ctx, this, loc.rank, x - 5, y + 10, colors.color);
			}
		}
	}
}class PlayerStats
{
	constructor(owner)
	{
		this.Owner = owner;
		this.Open = false;
		this.SelfOpen = false;

		this.margin = 20;

		this.x = this.margin;
		this.y = 0;
		this.Width = 150;
		this.Height = 0;

		this.backgroundColor = "rgba(255, 255, 255, 0.1)";
		this.style = Style.GetStyleByName("Default");
		this.hover = false;
		

		var SPbuttonOnClick = function()
		{
			this.Owner.UseSPpoint(this.id);
		};

		var SPbuttonOnUpdate = function()
		{
			if(this.clickTime > Main.FPS / 2)
			{
				var spd = 10;

				if(this.clickTime >  Main.FPS)
				{
					spd = 15;
				}

				if(this.clickTime > 2 * Main.FPS)
				{
					spd = 30;
				}

				if(this.clickTime % (Main.FPS / spd) == 0)
				{
					this.Click();
				}
			}
		};

		this.SPbuttons = 
		[
			new Button(0, 0, "SPbutton", "[+]", false, "MAXHP", SPbuttonOnUpdate, null, SPbuttonOnClick),
			new Button(0, 0, "SPbutton", "[+]", false, "AD", SPbuttonOnUpdate, null, SPbuttonOnClick),
			new Button(0, 0, "SPbutton", "[+]", false, "ATTACK_SPEED", SPbuttonOnUpdate, null, SPbuttonOnClick),
			new Button(0, 0, "SPbutton", "[+]", false, "SPD", SPbuttonOnUpdate, null, SPbuttonOnClick),
			new Button(0, 0, "SPbutton", "[+]", false, "LUCK", SPbuttonOnUpdate, null, SPbuttonOnClick)
		];
	}
	
	
	Update()
	{
		return;
		if(InGame.pause) return;

		if((Settings.Controls.StateOpenPlayerStats) && (!this.lockKey) && !InGame.lookingAtMap)
		{
			this.SelfOpen = (this.SelfOpen) ? false : true;
			this.lockKey = true;
		}
		else
		{
			if(!Settings.Controls.StateOpenPlayerStats)
			{
				this.lockKey = false;
			}
		}

		this.Open = (this.SelfOpen) ? true : this.Open;

		if(!this.Open) return;
		if(InGame.GUI.Map.Open) return;
		if(InGame.GUI.RunInfo.Open) return;
		if(InGame.GUI.Dialog.Open) return;

		
		this.Height = InGame.GUI.Inventory.Height;
		this.y = (canvas.height / 2) - (this.Height / 2);
		

		//zapobiega na strzelanie podczas przesuwania przedmiotow
		this.hover = false;
		if(
			Mouse.CheckHoverState(this.x, this.y - this.margin, this.Width + 2 * this.margin, this.Height + 2 * this.margin)
		)
		{
			this.Owner.allowAttack = false;
			this.hover = true;
			Mouse.cursor = 'default';
		}
	}
	
	Render()
	{
		if(!this.Open) return;
		if(InGame.GUI.Map.Open) return;
		if(InGame.pause) return;
		if(InGame.GUI.RunInfo.Open) return;
		if(InGame.GUI.Dialog.Open) return;

		var margin = this.margin;
		var infoColor = "lightblue";
		var hoverColor = '#00ff00';
		var infoStroke = "#569af3";
		var text = "";
		var color = infoColor;
		var interline = 25;


		//player stats background
		ctx.save();
		ctx.fillStyle = this.backgroundColor;
		Graphic.roundRect(ctx, this.x, this.y - margin, this.Width + 2 * margin, this.Height + 2 * margin, margin, true, false);
		ctx.restore();
		
		
		var x = this.x + (this.margin / 2);
		var y = this.y;
		text = "Exp:  " + this.Owner.oxygen + " / " + this.Owner.requiredOxygen;
		Style.FillText(ctx, this, text, x, y, infoColor, infoStroke);

		y += interline;
		y += interline;
		text = "Life:  " + this.Owner.stats.HP + " / " + this.Owner.stats.MAXHP;
		color = (this.SPbuttons[0].hover) ? hoverColor : infoColor;
		Style.FillText(ctx, this, text, x, y, color, infoStroke);


		y += interline;
		var dmg = World.Player.GetDamageValues();
		text = "Damage:  " + dmg.min + " - " + dmg.max;
		color = (this.SPbuttons[1].hover) ? hoverColor : infoColor;
		Style.FillText(ctx, this, text, x, y, color, infoStroke);

		y += interline;
		var as = (this.Owner.stats.ATTACK_SPEED == parseInt(this.Owner.stats.ATTACK_SPEED)) ? this.Owner.stats.ATTACK_SPEED + ".0" : this.Owner.stats.ATTACK_SPEED;
		text = "Attack Speed:  " + as;
		color = (this.SPbuttons[2].hover) ? hoverColor : infoColor;
		Style.FillText(ctx, this, text, x, y, color, infoStroke);

		y += interline;
		text = "Attack Range:  " + this.Owner.stats.ATTACK_RANGE;
		Style.FillText(ctx, this, text, x, y, infoColor, infoStroke);




		y += interline;
		text = "SPD:  " + this.Owner.stats.SPD;
		color = (this.SPbuttons[3].hover) ? hoverColor : infoColor;
		Style.FillText(ctx, this, text, x, y, color, infoStroke);


		var plusButtonMargin = 0;

		y += interline * 2;
		if(this.Owner.stats.availableSP > 0)
		{
			plusButtonMargin = 20;
			text = "SP:  " + this.Owner.stats.availableSP;
			this.style.textAlign = "right";
			Style.FillText(ctx, this, text, x + this.Width + (margin / 2), y, infoColor, infoStroke);
			this.style.textAlign = "left";
		}


		y += interline;
		this.SPbuttons[0].Owner = this.Owner;
		this.SPbuttons[0].y = y;
		text = "Resistance:  " + this.Owner.SPstats.MAXHP[0];
		Style.FillText(ctx, this, text, x + plusButtonMargin, y, infoColor, infoStroke);



		y += interline;
		this.SPbuttons[1].Owner = this.Owner;
		this.SPbuttons[1].y = y;
		text = "Power:  " + this.Owner.SPstats.AD[0];
		Style.FillText(ctx, this, text, x + plusButtonMargin, y, infoColor, infoStroke);


		y += interline;
		this.SPbuttons[2].Owner = this.Owner;
		this.SPbuttons[2].y = y;
		text = "Dexterity:  " + this.Owner.SPstats.ATTACK_SPEED[0];
		Style.FillText(ctx, this, text, x + plusButtonMargin, y, infoColor, infoStroke);


		y += interline;
		this.SPbuttons[3].Owner = this.Owner;
		this.SPbuttons[3].y = y;
		text = "Swiftness:  " + this.Owner.SPstats.SPD[0];
		Style.FillText(ctx, this, text, x + plusButtonMargin, y, infoColor, infoStroke);

		y += interline;
		this.SPbuttons[4].Owner = this.Owner;
		this.SPbuttons[4].y = y;
		text = "Luck:  " + this.Owner.stats.LUCK;
		Style.FillText(ctx, this, text, x + plusButtonMargin, y, infoColor, infoStroke);

		
			for(var i = 0; i < this.SPbuttons.length; i++)
			{
				var button = this.SPbuttons[i];

				// y += interline;
				// button.Owner = this.Owner;
				// button.y = y;
				// text = "Resistance:  " + this.Owner.SPstats.MAXHP[0];
				// Style.FillText(ctx, this, text, x + plusButtonMargin, y, infoColor, infoStroke);

				if(plusButtonMargin)
				{
					button.x = x;
					button.y += 10;
					button.Update();
					button.opacity = (button.hover) ? 1 : 0.5;

					button.style.color = infoColor;
					button.style.strokeColor = infoStroke;
					button.Render();
				}
				else
				{
					button.clickTime = 0;
					button.hover = false;
				}
			}
	}
}class RunInfo
{
	constructor()
	{
		this.Open = false;

		this.x = 0;
		this.y = 0;
		this.Width = 500;
		this.Height = 300;

		this.backgroundColor = "rgba(255, 255, 255, 0.1)";
		this.style = Style.GetStyleByName("Default");
		this.hover = false;

		this.rankSizeTransition = new Transition(240, 80, 1.3);
		this.alphaTransition = new Transition(0, 1, 1.1);

		this.shineAlphaTransition = new Transition(0, 0.9, 0.9);
		this.shineSizeTransition = new Transition(0, 4000, 0.1);
		this.shineRotateTransition = new Transition(360, 0, 40, false, 0, 0, true);
		this.shineSizeAfter = new Transition(60, 80, 0.5, true, 0, 0);

		this.xButton = new Button(0, 0, 'RunInfoClose', 'x', false, '', null, null, function(){InGame.GUI.RunInfo.Open = false});
	}

	static GetRankColor(rank)
	{
		var color = '#ffe30f';
		var stroke = '#ffc00f';
				
		if(rank.includes('A'))
		{
			color = '#39ef00';
			stroke = '#39c600';
		}

		if(rank.includes('B')) 
		{
			color = '#3eb5ff';
			stroke = '#3e8aff';
		}

		if(rank.includes('C'))
		{
			color = '#e337f8';
			stroke = '#c21dd6';
		}

		if(rank.includes('D'))
		{
			color = '#fe5757';
			stroke = '#d74444';
		}

		if(rank.includes('F'))
		{
			color = '#afafaf';
			stroke = '#8c8c8c';
		}

		return {color: color, stroke: stroke};
	}
	
	
	Update()
	{
		if(InGame.pause) return;
		if(!this.Open) return;

		if(Settings.Controls.StateEscape)
		{
			InGame.lockEscape = true;
			this.Open = false;
		}


		World.Player.allowControl = false;
		this.xButton.Update();
	}
	
	Render()
	{
		if(!this.Open) return;
		this.ageInTicks++;

		this.x = (canvas.width / 2) - (this.Width / 2);
		this.y = (canvas.height / 2) - (this.Height / 2);

		var margin = 20;

		if(Mouse.click)
		{
			//przerwanie animacji napisow
			Mouse.click = false;
			this.ageInTicks = 99999;
		}

		var textLines = [];

		ChangeLayer(Graphic.Layer.GUI);

			ctx.save();
			ctx.fillStyle = 'rgba(0, 0, 0, 0.4';
			ctx.fillRect(0, 0, canvas.width, canvas.height);
			ctx.restore();

			ctx.save();
			ctx.fillStyle = this.backgroundColor;
			Graphic.roundRect(ctx, this.x, this.y - margin, this.Width + 2 * margin, this.Height + 2 * margin, margin * 2, true, false);
			ctx.restore();


			var runStats = this.runStats;
			var runInfo = this.runInfo;

			this.style = Style.GetStyleByName("MenuInfo");
			this.style.fontSize = 25;
			this.style.textAlign = 'center';
			this.style.color = "lightblue";
			this.style.strokeColor = "#569af3";
			this.style.strokeSize = 3;


			


			var text = "";
			var x = this.x + margin;
			var y = this.y + margin + 30;
			var lineHeight = 20;


			text = "Run Summary:";
			Style.FillText(ctx, this, text, x + (this.Width / 2), y - 50);

			ctx.save();
			ctx.fillStyle = 'lightgray';
			ctx.fillRect(this.x  + margin, this.y + 30, this.Width, 2);
			ctx.restore();


			this.style.fontSize = 18;
			this.style.textAlign = 'left';


			this.xButton.x = x + this.Width - 25;
			this.xButton.y = this.y - 5;
			this.xButton.Render();


			
			
			var time = TicksToTime(runStats.timeInLocation);
			var timeText = "";
			if(time.h) timeText += time.h + ":";
			var s = (time.s < 10) ? "0" + time.s : time.s;
			var m = (time.m < 10) ? "0" + time.m : time.m;
			timeText += m + ":" + s;

			

			
			text = "Time: " + timeText;
			textLines.push({x: x, y: y, text: text});
			// Style.FillText(ctx, this, text, x, y, null, null, alpha);
			y += lineHeight;


	
			text = "Total XP gained: " + runStats.totalExperienceEarned;
			textLines.push({x: x, y: y, text: text});
			y += lineHeight;


			text = "Total Oxygen earned: " + runStats.totalGoldEarned;
			textLines.push({x: x, y: y, text: text});
			y += lineHeight;
			y += lineHeight;


			text = "Defeated Bosses: " + runStats.defeatedBosses + " / " + runInfo.bossChambers;
			textLines.push({x: x, y: y, text: text});
			y += lineHeight;


			text = "Defeated Enemies: " + (runStats.defeatedEnemies + runStats.defeatedBosses);
			textLines.push({x: x, y: y, text: text});
			y += lineHeight;


			text = "Secrets Found: " + runStats.foundSecretRooms + " / " +  runInfo.secretChambers;
			textLines.push({x: x, y: y, text: text});
			y += lineHeight;
			y += lineHeight;



			text = "Performance: " + (Math.round(runInfo.performance * 100) / 100) + "%";
			textLines.push({x: x, y: y, text: text});
			y += lineHeight;




			text = "Shot Accuracy: " + (Math.round(runInfo.accuracy * 100) / 100) + "%";
			textLines.push({x: x, y: y, text: text});
			y += lineHeight;


			var drawRank = true;
			var drawnCharacters = 0;
			var availableCharacters = this.ageInTicks;

			for(var i = 0; i < textLines.length; i++)
			{
				var textToDraw = " ";
				var line = textLines[i];
				if(drawnCharacters + line.text.length < availableCharacters)
				{
					textToDraw = line.text;
					drawnCharacters += line.text.length;

					Style.FillText(ctx, this, textToDraw, line.x, line.y);
				}
				else
				{
					var new_length = availableCharacters - drawnCharacters;
					textToDraw = line.text.slice(0, new_length);

					Style.FillText(ctx, this, textToDraw, line.x, line.y);
					drawRank = false;
					break;
				}
			}



			if(drawRank)
			{
				text = runInfo.rank;
				this.style.fontSize = this.rankSizeTransition.Update();
				this.style.textAlign = 'right';
				this.style.strokeSize = 10;

				var colors = RunInfo.GetRankColor(runInfo.rank);

				Style.FillText(ctx, this, text, x + this.Width, this.y + (this.Height / 2), colors.color, colors.stroke, this.alphaTransition.Update());

				if(this.style.fontSize == this.rankSizeTransition.To && (runInfo.rank.includes('S')))
				{
					//animacja sie zakonczyla
					var size = Style.GetTextSize(text, this.style);
					var width = size.width;
					var height = size.height;

					var shineSize = this.shineSizeTransition.Update();
					var alpha = 0.5;

					if(shineSize == this.shineSizeTransition.To)
					{
						shineSize = this.shineSizeAfter.Update();
						alpha = this.shineAlphaTransition.Update();
					}

					var rotation = this.shineRotateTransition.Update();

					var shineX = x + this.Width - width + 20;
					var shineY = this.y + (this.Height / 2) - (height / 2) + 10;
					
					Graphic.ApplyShineEffect(shineX, shineY, shineSize, alpha, rotation);
				}
			}

		RestoreLayer();
	}

	open(runStats)
	{
		var runInfo = runStats.getRunInfo();
		if(runInfo)
		{
			this.runStats = runStats;
			this.runInfo = runInfo;
			this.Open = true;
			this.ageInTicks = 0;
			this.rankSizeTransition.ageInTicks = 1;
		}
	}
}class SettingsGUI
{
	constructor(useShadow)
	{
		this.Open = false;
		this.lastOpen = this.Open;
		this.useShadow = useShadow;

		this.margin = 20;

		this.x = 0;
		this.y = 0;
		this.Width = 500;
		this.Height = 0;


		this.SetX = 0;

		this.backgroundColor = "white";

		this.className = "menu_subtitle";
		this.style;
		this.hover = false;

		this.currentOption = "General";

		this.Buttons =
		[
			new Button(-200, -200, "OptionsButton", "General", false, "General", null, false, function(){this.Owner.currentOption = this.id;}, false, false),
			new Button(-200, -200, "OptionsButton", "Sound", false, "Sound", null, false, function(){this.Owner.currentOption = this.id;}, false, false),
			new Button(-200, -200, "OptionsButton", "Controls", false, "Controls", null, false, function(){this.Owner.currentOption = this.id;}, false, false),
			new Button(-200, -200, "OptionsButton", "Back", false, "OptionsBack", null, false, function(){this.Owner.Open = false;}, false, false)
		];

		this.SoundSliders =
		{
			"General": new Slider(0, 0, "SettingsSlider", "General", 0, 100, Settings.Sound.General * 100, false, null, function(){Settings.Sound.General = this.value / 100}),
			"Music": new Slider(0, 0, "SettingsSlider", "Music", 0, 100, Settings.Sound.Music * 100, false, null, function(){Settings.Sound.Music = this.value / 100;}),
			"Effects": new Slider(0, 0, "SettingsSlider", "Effects", 0, 100, Settings.Sound.Effects * 100, false, null, function(){Settings.Sound.Effects = this.value / 100;})
		};






		var controlsUpdate = function()
		{
			if(this.text == "")
			{
				this.text = Settings.Controls[this.id];
			}

			if(Mouse.focus === this)
			{
				this.style.color = "#569af3";
				if(Main.lastKey != this.lastKey && Main.lastKey.toUpperCase() != this.text.toUpperCase())
				{
					this.text = Main.lastKey.toUpperCase();
					Settings.Controls[this.id] = Main.lastKey.toUpperCase();
					Mouse.focus = null;
				}
			}

			if(this.text == " ")
			{
				this.text = "SPACE";
			}

			if(this.text.includes("ARROW"))
			{
				this.text = this.text.replace("ARROW", "");
			}
		};

		var controlsClick = function()
		{
			this.lastKey = Main.lastKey;
		};


		this.controlsError = false;

		this.ControlsButtons =
		{
			MoveUp: new Button(-200, -200, "OptionsControlsButton", "", false, "PlayerMoveUp", controlsUpdate, null, controlsClick),
			MoveDown: new Button(-200, -200, "OptionsControlsButton", "", false, "PlayerMoveDown", controlsUpdate, null, controlsClick),
			MoveLeft: new Button(-200, -200, "OptionsControlsButton", "", false, "PlayerMoveLeft", controlsUpdate, null, controlsClick),
			MoveRight: new Button(-200, -200, "OptionsControlsButton", "", false, "PlayerMoveRight", controlsUpdate, null, controlsClick),

			Bounce: new Button(-200, -200, "OptionsControlsButton", "", false, "Bounce", controlsUpdate, null, controlsClick),
			OpenInventory: new Button(-200, -200, "OptionsControlsButton", "", false, "OpenInventory", controlsUpdate, null, controlsClick),
			OpenPlayerStats: new Button(-200, -200, "OptionsControlsButton", "", false, "OpenPlayerStats", controlsUpdate, null, controlsClick),
			OpenMap: new Button(-200, -200, "OptionsControlsButton", "", false, "OpenMap", controlsUpdate, null, controlsClick)
		};


		var checkboxUpdate = function()
		{
			this.checked = Settings.General[this.id];
			this.style.backgroundColor = (this.checked) ? '#2ce92c' : 'gray';
		};

		var checkboxClick = function()
		{
			this.checked = (this.checked) ? false : true;
			Settings.General[this.id] = this.checked;
		};

		this.GeneralCheckboxes =
		{
			showFPS: new Button(-200, -200, "OptionsCheckbox", "", false, "showFPS", checkboxUpdate, null, checkboxClick),
			showMinimap: new Button(-200, -200, "OptionsCheckbox", "", false, "showMinimap", checkboxUpdate, null, checkboxClick),
			showRadar: new Button(-200, -200, "OptionsCheckbox", "", false, "showRadar", checkboxUpdate, null, checkboxClick),
			AlwaysShowItemPrice:  new Button(-200, -200, "OptionsCheckbox", "", false, "AlwaysShowItemPrice", checkboxUpdate, null, checkboxClick)
		};
	}
	
	
	Update()
	{
		this.style = Style.GetStyleByName(this.className);

		if(Settings.Controls.StateEscape)
		{
			if(this.Open)
			{
				InGame.lockEscape = true;
				InGame.pause = true;
				this.Open = false;
			}
		}


		if(this.lastOpen != this.Open)
		{
			this.lastOpen = this.Open;
			Settings.Save();
		}

		if(!this.Open) return;

		
		this.Height = canvas.height * 60 / 100;
		this.y = (canvas.height / 2) - (this.Height / 2);
		this.x = (canvas.width / 2) - (this.Width / 2);

		this.SetX = this.x + this.Buttons[0].style.width + this.margin;
		
		var interline = 0;

		for(var i = 0; i < this.Buttons.length; i++)
		{
			this.Buttons[i].disabled = (this.Buttons[i].id == this.currentOption) ? true : false;

			this.Buttons[i].Owner = this;
			if(this.Buttons[i].id == "OptionsBack")
			{
				this.Buttons[i].y = this.y + this.Height - this.Buttons[i].style.height;
				this.Buttons[i].x = this.x + 10;
			}
			else
			{
				this.Buttons[i].x = this.x + 10;
				this.Buttons[i].y = this.y + ((interline * this.Buttons[i].style.height) + 10);
				interline++;
			}
			this.Buttons[i].Update();
		}

	}
	
	Render()
	{
		if(!this.Open) return;

		ChangeLayer(Graphic.Layer.Pause);

		var margin = this.margin;
		var alpha = 0.2;

		if(this.useShadow)
		{
			ctx.save();
			ctx.fillStyle = "black";
			ctx.globalAlpha = 0.7;
			ctx.fillRect(0, 0, canvas.width, canvas.height);
			ctx.restore();

			alpha = 0.3;
		}

		ctx.save();
		ctx.fillStyle = this.backgroundColor;
		ctx.globalAlpha = alpha;
		Graphic.roundRect(ctx, this.x, this.y - margin, this.Width + 2 * margin, this.Height + 2 * margin, margin * 2, true, false);
		ctx.restore();


		for(var i = 0; i < this.Buttons.length; i++)
		{
			this.Buttons[i].Render();
		}



		//line
		ctx.save();
		ctx.fillStyle = this.backgroundColor;
		ctx.globalAlpha = 1;
		ctx.fillRect(this.SetX, this.y - margin / 2, 2, this.Height + margin);
		ctx.restore();



		//title
		var setWidth = this.Width - (this.SetX - this.x);
		var x = this.SetX + (setWidth / 2);
		var y = this.y + margin / 2;
		var text = this.currentOption;
		Style.FillText(ctx, this, text, x, y);

		if(isFunction(this["Draw" + this.currentOption + "Options"]))
		{
			this["Draw" + this.currentOption + "Options"]();
		}


		RestoreLayer();
	}

	DrawGeneralOptions()
	{
		this.style = Style.GetStyleByName("MenuInfo");
		this.style.fontSize = 20;

		var text = "";
		var x = this.SetX + 20;
		var y = this.y + this.margin + 30;
		var buttonsMarginX = 270;
		var buttonsMarginY = -5;
		var lineHeight = 15;



		for(var name in this.GeneralCheckboxes)
		{
			var box = this.GeneralCheckboxes[name];
				box.x = x + buttonsMarginX;
				box.y = y + buttonsMarginY;
				box.Update();
				box.Render();

			text = Lang.Get('OPTIONS_GENERAL_' + name.toUpperCase());
			Style.FillText(ctx, this, text, x, y);

			y = box.y + box.style.height + lineHeight;
		}
	}

	DrawSoundOptions()
	{	
		this.style = Style.GetStyleByName("MenuInfo");
		this.style.fontSize = 25;

		var text = "";
		var x = this.SetX + 20;
		var y = this.y + this.margin + 30;


		//General
		text = "General";
		Style.FillText(ctx, this, text, x, y);

		var slider = this.SoundSliders.General;
			slider.x = x;
			slider.y = y + Style.GetTextSize(text, this.style).height + 10;

			slider.Update();
			slider.Render();

		text = slider.value + "%";
		Style.FillText(ctx, this, text, slider.x + slider.style.width + 20, slider.y);




		y = slider.y + slider.style.height + 40;

		//Music
		text = "Music";
		Style.FillText(ctx, this, text, x, y);

		slider = this.SoundSliders.Music;
			slider.x = x;
			slider.y = y + Style.GetTextSize(text, this.style).height + 10;

			slider.Update();
			slider.Render();

		text = slider.value + "%";
		Style.FillText(ctx, this, text, slider.x + slider.style.width + 20, slider.y);










		y = slider.y + slider.style.height + 40;

		//Effects
		text = "Effects";
		Style.FillText(ctx, this, text, x, y);

		slider = this.SoundSliders.Effects;
			slider.x = x;
			slider.y = y + Style.GetTextSize(text, this.style).height + 10;

			slider.Update();
			slider.Render();

		text = slider.value + "%";
		Style.FillText(ctx, this, text, slider.x + slider.style.width + 20, slider.y);
	}




	DrawControlsOptions()
	{	
		this.style = Style.GetStyleByName("MenuInfo");
		this.style.fontSize = 20;

		var text = "";
		var x = this.SetX + 20;
		var y = this.y + this.margin + 30;
		var buttonsMarginX = 170;
		var buttonsMarginY = -5;
		var lineHeight = 15;

		var usedKeys = {};


		text = "Move Up";
		Style.FillText(ctx, this, text, x, y);

		var button = this.ControlsButtons.MoveUp;
			button.x = x + buttonsMarginX;
			button.y = y + buttonsMarginY;
			button.Update();
			if(usedKeys[button.text]) button.style.color = "#ff0000";
			usedKeys[button.text] = true;
			button.Render();

		y = button.y + button.style.height + lineHeight;




		text = "Move Down";
		Style.FillText(ctx, this, text, x, y);

		button = this.ControlsButtons.MoveDown;
			button.x = x + buttonsMarginX;
			button.y = y + buttonsMarginY;
			button.Update();
			if(usedKeys[button.text]) button.style.color = "#ff0000";
			usedKeys[button.text] = true;
			button.Render();

		y = button.y + button.style.height + lineHeight;



		text = "Move Left";
		Style.FillText(ctx, this, text, x, y);

		button = this.ControlsButtons.MoveLeft;
			button.x = x + buttonsMarginX;
			button.y = y + buttonsMarginY;
			button.Update();
			if(usedKeys[button.text]) button.style.color = "#ff0000";
			usedKeys[button.text] = true;
			button.Render();

		y = button.y + button.style.height + lineHeight;



		text = "Move Right";
		Style.FillText(ctx, this, text, x, y);

		button = this.ControlsButtons.MoveRight;
			button.x = x + buttonsMarginX;
			button.y = y + buttonsMarginY;
			button.Update();
			if(usedKeys[button.text]) button.style.color = "#ff0000";
			usedKeys[button.text] = true;
			button.Render();

		y = button.y + button.style.height + lineHeight;




		text = "Bounce";
		Style.FillText(ctx, this, text, x, y);

		button = this.ControlsButtons.Bounce;
			button.x = x + buttonsMarginX;
			button.y = y + buttonsMarginY;
			button.Update();
			if(usedKeys[button.text]) button.style.color = "#ff0000";
			usedKeys[button.text] = true;
			button.Render();

		y = button.y + button.style.height + lineHeight;



		text = "Open Inventory";
		Style.FillText(ctx, this, text, x, y);

		button = this.ControlsButtons.OpenInventory;
			button.x = x + buttonsMarginX;
			button.y = y + buttonsMarginY;
			button.Update();
			if(usedKeys[button.text]) button.style.color = "#ff0000";
			usedKeys[button.text] = true;
			button.Render();

		y = button.y + button.style.height + lineHeight;




		text = "Open Map";
		Style.FillText(ctx, this, text, x, y);

		button = this.ControlsButtons.OpenMap;
			button.x = x + buttonsMarginX;
			button.y = y + buttonsMarginY;
			button.Update();
			if(usedKeys[button.text]) button.style.color = "#ff0000";
			usedKeys[button.text] = true;
			button.Render();

		y = button.y + button.style.height + lineHeight;



		text = "Open Stats";
		Style.FillText(ctx, this, text, x, y);

		button = this.ControlsButtons.OpenPlayerStats;
			button.x = x + buttonsMarginX;
			button.y = y + buttonsMarginY;
			button.Update();
			if(usedKeys[button.text]) button.style.color = "#ff0000";
			usedKeys[button.text] = true;
			button.Render();

		y = button.y + button.style.height + lineHeight;



	}
}class ItemSpecial extends ItemUpgradeAble
{
	constructor()
	{
		super(true);
		
		this.type = TYPE.SPECIAL;
		this.slot = SLOT.SPECIAL;

		this.upgradeAble = false;
		// this.Grade = GRADE.NORMAL;
		this.enchantSlots = 1;
	}
}class RandomAppearanceBox extends Item
{
	constructor()
	{
		super();

		this.stackAble = false;
		this.upgradeAble = false;
		this.enchantAble = false;

        this.type = TYPE.APPEARANCE_BOX;

		this.Texture = 'item.appearance_box.unknown';
        this.name = "ITEM.APPEARANCE_BOX.NAME";

        this.Grade = GRADE.LEGENDARY;
        this.showGrade = false;
        this.canBeSold = false;
		
        this.Description = 'ITEM.APPEARANCE_BOX.DESCRIPTION';
	}

    getAvailableSkins()
    {
        var all = Player.Skins;
        var owned = World.Player.Appearance.AvailableSkins;
        var available = [];

        for(var name in all)
        {
            if(owned[name]) continue;

            var id = name.replace('Skin', '');
            var appearance_box = Item.Get(id+'AppearanceBox');
            if(appearance_box) available.push(name);
        }

        for(var i in World.Player.inventory)
        {
            var item = World.Player.inventory[i];
            if(!item) continue;
            if(item.type != TYPE.APPEARANCE_BOX) continue;

            var index = available.indexOf('Skin'+item.Skin);
            if(index != -1) available.splice(index, 1)
        }

        return available;
    }

    getDescription()
	{
        var available = this.getAvailableSkins();
        if(available.length == 0)
        {
            return ['Cannot be used.'];
        }

        var desc = Lang.Get(this.Description);
        for(var i in available)
        {
            var skin = available[i];
            var id = skin.replace('Skin', '');
            var appearance_box = Item.Get(id+'AppearanceBox');
            if(!appearance_box) continue;

            desc += '\n-'+appearance_box.getDisplayName();
        }

        return desc.split('\n');
	}

	onUse(player)
	{
        var available = this.getAvailableSkins();
        if(available.length == 0) return;

        var skin = available[MathHelper.randomInRange(0, available.length-1)];

        var id = skin.replace('Skin', '');
        var appearance_box = Item.Get(id+'AppearanceBox');
        if(!appearance_box) return;

        player.addItemToInventory(appearance_box);

        this.count--;

		if(this.count <= 0)
		{
			var index = player.inventory.indexOf(this);
			if(index > -1) player.inventory[index] = null;
		}

        Save();
	}
}
ItemHelper.InitializeItem(RandomAppearanceBox);



class AppearanceBox extends RandomAppearanceBox
{
	constructor(type = '', name = null)
	{
		super();
		this.Texture = 'item.appearance_box.'+type.toLowerCase();
        this.name = "ITEM.APPEARANCE_BOX.FIXED.NAME";
		
        this.Description = "ITEM.APPEARANCE_BOX.FIXED.DESCRIPTION";
        this.Skin = type;

        if(!name) name = type.toUpperCase().replace('SKIN', '');
        this.ARGS = {TYPE: Lang.Get('SKIN.'+name+'.NAME')};
	}

    getDescription()
	{
        return Lang.Get(this.Description, this.ARGS).split('\n');
	}

	onUse(player)
	{
		player.Appearance.AvailableSkins['Skin'+this.Skin] = true;

        var index = player.inventory.indexOf(this);
        if(index > -1) player.inventory[index] = null;
        Save();
	}
}
ItemHelper.InitializeItem(AppearanceBox);



class KitsuneAppearanceBox extends AppearanceBox
{
	constructor(){super('Kitsune');}
}
ItemHelper.InitializeItem(KitsuneAppearanceBox);

class KitsuneAngelicAppearanceBox extends AppearanceBox
{
	constructor(){super('KitsuneAngelic', 'KITSUNE.ANGELIC');}
}
ItemHelper.InitializeItem(KitsuneAngelicAppearanceBox);



class ReaperAppearanceBox extends AppearanceBox
{
	constructor(){super('Reaper');}
}
ItemHelper.InitializeItem(ReaperAppearanceBox);
class BlessingGrade extends Item
{
	constructor()
	{
		super();

		this.type = TYPE.ITEM;
        this.Grade = GRADE.NORMAL;
		
		this.Texture = "item.blessing_stone";
		this.name = "ITEM.BLESSING_STONE.BROKEN.NAME";
		this.Description = "ITEM.BLESSING_STONE.BROKEN.DESCRIPTION";

		this.price = 1000;
	}
}
ItemHelper.InitializeItem(BlessingGrade);








class BlessingGrade0 extends Item
{
	constructor(grade = GRADE.COMMON)
	{
		super();

		this.type = TYPE.BLESSING;
        this.Grade = grade;
		
		this.Texture = "item.blessing_stone.common";
		this.name = "ITEM.BLESSING_STONE.NAME";
		this.Description = "ITEM.BLESSING_STONE.DESCRIPTION";

        this.ARGS = {GRADE: Lang.Get('NORMAL')};

		this.price = 1000;

        this.Recipe = new ItemRecipe(this, [
            ['BlessingGrade', 1],
            ['LiquidOxygen', 10],
            ['EssenceGrade0', 4]
        ]);
	}

    Require(item)
    {
        if(!item) return false;
        if(!item.enchantAble) return false;
        if(item.slot == SLOT.CORE) return false;

        var gradesOrder = ItemHelper.GetGradesOrder();
        var currentGrade = gradesOrder.indexOf(item.Grade);
        var myGrade = gradesOrder.indexOf(this.Grade);
        if(currentGrade == -1) return false;

        //this item can only be used on items with grade one less
        if(currentGrade == myGrade - 1) return true;

        return false;
    }

    Bless(item)
    {
        item.Grade = this.Grade;
    }
}
ItemHelper.InitializeItem(BlessingGrade0);







class BlessingGrade1 extends BlessingGrade0
{
	constructor()
	{
		super(GRADE.RARE);
        this.Texture = "item.blessing_stone.rare";

        this.ARGS = {GRADE: Style.InjectColor(GRADE.COMMON)};

        this.Recipe = new ItemRecipe(this, [
            ['BlessingGrade', 1],
            ['LiquidOxygen', 20],
            ['EssenceGrade1', 4]
        ]);
	}
}
ItemHelper.InitializeItem(BlessingGrade1);




class BlessingGrade2 extends BlessingGrade0
{
	constructor()
	{
		super(GRADE.MYTHICAL);
        this.Texture = "item.blessing_stone.mythical";

        this.ARGS = {GRADE: Style.InjectColor(GRADE.RARE)};

        this.Recipe = new ItemRecipe(this, [
            ['BlessingGrade', 1],
            ['LiquidOxygen', 50],
            ['EssenceGrade2', 4]
        ]);
	}
}
ItemHelper.InitializeItem(BlessingGrade2);


class BlessingGrade3 extends BlessingGrade0
{
	constructor()
	{
		super(GRADE.LEGENDARY);
		this.Texture = "item.blessing_stone.legendary";

        this.ARGS = {GRADE: Style.InjectColor(GRADE.MYTHICAL)};
        
        this.Recipe = new ItemRecipe(this, [
            ['BlessingGrade', 1],
            ['LiquidOxygen', 100],
            ['EssenceGrade3', 4]
        ]);
	}
}
ItemHelper.InitializeItem(BlessingGrade3);



class BlessingGrade4 extends BlessingGrade0
{
	constructor()
	{
		super(GRADE.ANGELIC);
		
		this.Texture = "item.blessing_stone.angelic";

        this.ARGS = {
            GRADE: Style.InjectColor(GRADE.LEGENDARY), 
            GRADE2: Style.InjectColor(GRADE.DEMONIC, 'DATA')
        };

        this.Description = "ITEM.BLESSING_STONE.DESCRIPTION.2";
        this.Recipe = null;
	}

    Require(item)
    {
        if(!item) return false;
        if(!item.enchantAble) return false;

        var gradesOrder = ItemHelper.GetGradesOrder();
        var currentGrade = gradesOrder.indexOf(item.Grade);
        if(currentGrade == -1) return false;

        //this item can only be used on items with grade one less
        //demonic got index one higher than angelic, but its the same tier
        if(item.Grade == GRADE.DEMONIC) return true;
        if(item.Grade == GRADE.LEGENDARY) return true;
    }
}
ItemHelper.InitializeItem(BlessingGrade4);


class BlessingGrade5 extends BlessingGrade0
{
	constructor()
	{
		super(GRADE.DEMONIC);

        this.ARGS = {
            GRADE: Style.InjectColor(GRADE.LEGENDARY), 
            GRADE2: Style.InjectColor(GRADE.ANGELIC, 'DATA')
        };

        this.Description = "ITEM.BLESSING_STONE.DESCRIPTION.2";
		
		this.Texture = "item.blessing_stone.demonic";
        this.Recipe = null;
	}

    Require(item)
    {
        if(!item) return false;
        if(!item.enchantAble) return false;

        var gradesOrder = ItemHelper.GetGradesOrder();
        var currentGrade = gradesOrder.indexOf(item.Grade);
        if(currentGrade == -1) return false;

        //this item can only be used on items with grade one less
        //demonic got index one higher than angelic, but its the same tier
        if(item.Grade == GRADE.LEGENDARY) return true;
        if(item.Grade == GRADE.ANGELIC) return true;

        return false;
    }
}
ItemHelper.InitializeItem(BlessingGrade5);





class BlessingGrade6 extends BlessingGrade0
{
	constructor()
	{
		super(GRADE.DIVINE);

		this.Texture = "item.blessing_stone.divine";

        this.ARGS = {
            GRADE: Style.InjectColor(GRADE.ANGELIC, 'DATA'), 
            GRADE2: Style.InjectColor(GRADE.DEMONIC, 'DATA')
        };

        this.Description = "ITEM.BLESSING_STONE.DESCRIPTION.2";
        this.Recipe = null;
	}

    Require(item)
    {
        if(!item) return false;
        if(!item.enchantAble) return false;

        var gradesOrder = ItemHelper.GetGradesOrder();
        var currentGrade = gradesOrder.indexOf(item.Grade);
        if(currentGrade == -1) return false;

        //this item can only be used on items with grade one less
        //demonic got index one higher than angelic, but its the same tier
        if(item.Grade == GRADE.DEMONIC) return true;
        if(item.Grade == GRADE.ANGELIC) return true;

        return false;
    }
}
ItemHelper.InitializeItem(BlessingGrade6);
























class ConcentratedBossAura extends Item
{
	constructor()
	{
		super();

		this.type = TYPE.ITEM;
        this.Grade = GRADE.DEMONIC;
        this.showGrade = false;
		
		this.Texture = "item.aura.boss";
		this.name = "ITEM.CONCENTRATED_AURA.BOSS.NAME";
		this.Description = "ITEM.CONCENTRATED_AURA.BOSS.DESCRIPTION";

		this.price = 1000;
	}
}
ItemHelper.InitializeItem(ConcentratedBossAura);




class ConcentratedAura0 extends Item
{
	constructor(grade = GRADE.COMMON)
	{
		super();

		this.type = TYPE.BLESSING;
        this.Grade = grade;
		
		this.Texture = "item.aura.common";
		this.name = "ITEM.CONCENTRATED_AURA.NAME";
		this.Description = "ITEM.CONCENTRATED_AURA.DESCRIPTION";

        this.ARGS = {GRADE: Lang.Get('NORMAL')};

		this.price = 1000;

        this.Recipe = new ItemRecipe(this, [
            ['ConcentratedBossAura', 1],
            ['LiquidOxygen', 10],
            ['EssenceGrade0', 4]
        ]);
	}

    Require(item)
    {
        if(!item) return false;
        if(!item.enchantAble) return false;
        if(item.slot != SLOT.CORE) return false;

        var gradesOrder = ItemHelper.GetGradesOrder();
        var currentGrade = gradesOrder.indexOf(item.Grade);
        var myGrade = gradesOrder.indexOf(this.Grade);
        if(currentGrade == -1) return false;

        //this item can only be used on items with grade one less
        if(currentGrade == myGrade - 1) return true;

        return false;
    }

    Bless(item)
    {
        item.Grade = this.Grade;
    }
}
ItemHelper.InitializeItem(ConcentratedAura0);



class ConcentratedAura1 extends ConcentratedAura0
{
	constructor()
	{
		super(GRADE.RARE);
        this.Texture = "item.aura.rare";

        this.ARGS = {GRADE: Style.InjectColor(GRADE.COMMON)};

        this.Recipe = new ItemRecipe(this, [
            ['ConcentratedBossAura', 1],
            ['LiquidOxygen', 20],
            ['EssenceGrade1', 4]
        ]);
	}
}
ItemHelper.InitializeItem(ConcentratedAura1);

class ConcentratedAura2 extends ConcentratedAura0
{
	constructor()
	{
		super(GRADE.MYTHICAL);
        this.Texture = "item.aura.mythical";

        this.ARGS = {GRADE: Style.InjectColor(GRADE.RARE)};

        this.Recipe = new ItemRecipe(this, [
            ['ConcentratedBossAura', 1],
            ['LiquidOxygen', 50],
            ['EssenceGrade2', 4]
        ]);
	}
}
ItemHelper.InitializeItem(ConcentratedAura2);


class ConcentratedAura3 extends ConcentratedAura0
{
	constructor()
	{
		super(GRADE.LEGENDARY);
        this.Texture = "item.aura.legendary";

        this.ARGS = {GRADE: Style.InjectColor(GRADE.MYTHICAL)};

        this.Recipe = new ItemRecipe(this, [
            ['ConcentratedBossAura', 1],
            ['LiquidOxygen', 100],
            ['EssenceGrade3', 4]
        ]);
	}
}
ItemHelper.InitializeItem(ConcentratedAura3);class BoomerangBase extends ItemWeaponBoomerang
{
	constructor()
	{
		super(true);

		this.type = TYPE.BOOMERANG;
		
		this.Texture = "ShadowScythe";
		this.name = "Boomerang 1";
		this.enchantSlots = 2;

		this.primary = 
		[
			new ItemBonus(STAT.ATTACK_DAMAGE, 40),
            new ItemBonus(STAT.ATTACK_SPEED, 1),
            new ItemBonus(STAT.CR, 10),
			new ItemBonus(STAT.ATTACK_RANGE, 1500)
		];

		this.Lore = "ITEM_BUBBLE_TERMINATOR_LORE";
	
		this.Model = new ModelCannonBase('model.item.bubbleCannon1');
	}

    canIncreaseBulletsCount()
    {
        return true;
    }
}
ItemHelper.InitializeItem(BoomerangBase);




class TheStick extends BoomerangBase
{
	constructor()
	{
		super(true);

        this.BulletType = "BulletBambooStick";

		this.Texture = "item.bamboo_stick";
		this.name = "ITEM.BAMBOO_STICK.NAME";
		this.enchantSlots = 3;

		this.primary = 
		[
			new ItemBonus(STAT.ATTACK_DAMAGE, 1),
            new ItemBonus(STAT.ATTACK_SPEED, 2.5),
            new ItemBonus(STAT.ATTACK_RANGE, 650)
		];

		this.Lore = "ITEM.BAMBOO_STICK.LORE";
        this.Description = ['ITEM.BAMBOO_STICK.DESCRIPTION'];
	
		this.Model = new ModelBoomerangBase('item.bamboo_stick', 0, 1.75, -.5, -.2);

        this.requiredMP = 400;
        this.MPgain = 'HIT';
		this.knockBack = .5;
	}

    onSpecialCharge()
    {
        this.lastProjectile.isCharged = true;
    }
}
ItemHelper.InitializeItem(TheStick);




class BubbleTerminator extends ItemWeaponLaser
{
	constructor()
	{
		super(true);

		this.type = TYPE.CANNON;
		
		this.Texture = "ShadowScythe";
		this.name = "MD Bubble Terminator 3000";
		this.enchantSlots = 3;

		this.primary = 
		[
			new ItemBonus(STAT.ATTACK_DAMAGE, 20),
			new ItemBonus(STAT.DURATION, 120),
			new ItemBonus(STAT.COOLTIME, 60),
			new ItemBonus(STAT.ATTACK_RANGE, 3000)
			// new ItemBonus(STAT.MAX_HP, [10, 20, 30, 40, 50], true, true),
		];

		this.Lore = "ITEM_BUBBLE_TERMINATOR_LORE";
	
		this.Model = new ModelCannonBase('model.item.bubbleCannon1');
	}
}
ItemHelper.InitializeItem(BubbleTerminator);class CannonBase extends ItemWeapon
{
	constructor()
	{
		super(true);

		this.Grade = GRADE.NORMAL;
		this.type = TYPE.CANNON;
		
		this.Texture = "item.cannonBase";
		this.name = "Base Cannon";
		this.enchantSlots = 1;
		this.price = 50;

		this.BulletType = 'BulletBubble';


		this.primary = 
		[
			new ItemBonus(STAT.ATTACK_DAMAGE, 10),
			new ItemBonus(STAT.ATTACK_SPEED, 1),
			new ItemBonus(STAT.ATTACK_RANGE, 450),
		];

		this.ammoCost = 0;
	
		this.Model = new ModelCannonBase('model.item.cannonBase');
	}
}
ItemHelper.InitializeItem(CannonBase);





class Cannon1 extends ItemWeapon
{
	constructor()
	{
		super(true);
		
		this.type = TYPE.CANNON;
		
		this.Texture = "item.bubbleCannon1";
		this.name = "ITEM.CANON.BUBBLE.1.NAME";
		this.enchantSlots = 2;

		this.BulletType = 'BulletBubble';

		this.primary = 
		[
			new ItemBonus(STAT.ATTACK_DAMAGE, 20),
			new ItemBonus(STAT.ATTACK_SPEED, 1.5),
			new ItemBonus(STAT.ATTACK_RANGE, 500)
		];

		this.ammoCost = 5;
	
		this.Model = new ModelCannonBase('model.item.bubbleCannon1');
	}
}
ItemHelper.InitializeItem(Cannon1);





class Cannon2 extends ItemWeapon
{
	constructor()
	{
		super(true);
		
		this.type = TYPE.CANNON;
		
		this.Texture = "item.bubbleCannon1";
		this.name = "ITEM.CANON.BUBBLE.2.NAME";
		this.enchantSlots = 2;

		this.BulletType = 'BulletBubble';

		this.primary = 
		[
			new ItemBonus(STAT.ATTACK_DAMAGE, 40),
			new ItemBonus(STAT.ATTACK_SPEED, 1.5),
			new ItemBonus(STAT.ATTACK_RANGE, 550)
		];

		this.ammoCost = 15;
	
		this.Model = new ModelCannonBase('model.item.bubbleCannon1');
	}
}
ItemHelper.InitializeItem(Cannon2);class Core1 extends ItemUpgradeAble
{
	constructor()
	{
		super(true);
		
		this.type = TYPE.CORE;
		this.slot = SLOT.CORE;
		
		this.Texture = "item.core.base";
        this.TextureAnimation = 
        {
            framesX: 5,
            framesY: 6,
            speed: 0.25,
            scale: 1.5
        };

		this.name = "ITEM.CORE.BASE.NAME";
        this.Description = 'ITEM.CORE.BASE.DESCRIPTION';
        this.Lore = 'ITEM.CORE.BASE.LORE';
		this.enchantSlots = 0;

		this.primary = [];

        this.Grade = GRADE.NORMAL;

        this.canBeSold = false;
        this.isUnique = true;

        this.Tries = 0;
	}

    getEnchantSlots()
    {
        if(this.Grade == GRADE.COMMON) return 1;
        if(this.Grade == GRADE.RARE) return 1;
        if(this.Grade == GRADE.MYTHICAL) return 2;
        if(this.Grade == GRADE.LEGENDARY) return 3;

        if(this.Grade == GRADE.ANGELIC) return 3;
        if(this.Grade == GRADE.DEMONIC) return 3;
        if(this.Grade == GRADE.DIVINE) return 3;

		return this.enchantSlots;
    }

    GetPrimaryBonuses()
	{
        if(this.Grade == GRADE.COMMON) return [new ItemBonus(STAT.MAX_HP, 20)];
        if(this.Grade == GRADE.RARE) return [new ItemBonus(STAT.MAX_HP, 40)];
        if(this.Grade == GRADE.MYTHICAL) return [new ItemBonus(STAT.MAX_HP, 60)];
        if(this.Grade == GRADE.LEGENDARY) return [new ItemBonus(STAT.MAX_HP, 80)];

        if(this.Grade == GRADE.ANGELIC) return [new ItemBonus(STAT.MAX_HP, 100)];
        if(this.Grade == GRADE.DEMONIC) return [new ItemBonus(STAT.MAX_HP, 100)];
        if(this.Grade == GRADE.DIVINE) return [new ItemBonus(STAT.MAX_HP, 100)];

		return this.primary;
	}

    onDropOut()
    {
        World.Player.addItemToInventory(this);
        this.Tries++;
        if(World.Player.hand === this) World.Player.hand = null;

        if(this.Tries >= 3)  World.Player.Hurt(999999, {deathQuote: 'DEATH_QUOTE.CORE_DROP'});
    }


    // Drop(x, y, ownerInventory, dirX)
	// {
	// 	console.log('nope');
	// }
}
ItemHelper.InitializeItem(Core1);class Drive1 extends ItemUpgradeAble
{
	constructor()
	{
		super(true);
		
		this.type = TYPE.DRIVE;
		this.slot = SLOT.DRIVE;
		
		this.Texture = "item.drive1";
		this.name = "Drive I";
		this.enchantSlots = 1;

		this.primary = 
		[
			new ItemBonus(STAT.MOVEMENT_SPEED, 10)
			// new ItemBonus(STAT.ACCELERATION, acc)
		];
	
		this.Model = new ItemModel("driveBase", 81, 31, 2, 0, -42);
	}
}
// ItemHelper.InitializeItem(Drive1);
class TheEcho extends ItemWeapon
{
	constructor()
	{
		super(true);
		
		this.type = TYPE.CANNON;
		
		this.Texture = "item.bubbleCannon1";
		this.name = "ITEM.THE_ECHO.NAME";
		this.enchantSlots = 3;

		this.BulletType = 'BulletEcho';

		this.primary = 
		[
			new ItemBonus(STAT.ATTACK_DAMAGE, 10),
			new ItemBonus(STAT.ATTACK_SPEED, 4)
		];

        this.isUnique = true;
		this.ammoCost = 20;

        // this.BULLET_SERIES = 4;
        this.BULLET_SERY_DELAY = 5;
	
		this.Model = new ModelCannonBase('model.item.bubbleCannon1');
	}

    GetAdditionalBulletStats()
    {
        var s = super.GetAdditionalBulletStats();
        s.spd = 1100;
        s.Scale = 10;
        s.Bounce = 1;
        s.Pierce = 5;

        return s;
    }
}
ItemHelper.InitializeItem(TheEcho);class Sapphire1 extends Item
{
	constructor(bonus = 5)
	{
		super();

		this.stackAble = false;
		this.type = TYPE.ENCHANT;
		
		this.Texture = "item.sapphire";
		this.name = "ITEM.ENCHANT.SAPPHIRE.NAME";
		this.shineStrength = 0;
		this.Grade = GRADE.NORMAL;

		this.bonus = new ItemBonus(STAT.DAMAGE_ICE, bonus);

		this.Description = 'ITEM.ENCHANT.GEM.DESCRIPTION';
		this.price = 1000;
	}

	Require(item)
	{
		if(item.slot != SLOT.CANNON) return false;
        if(item.Element == ELEMENT.ICE) return true;
        if(item.Charged?.element == ELEMENT.ICE) return true;

		return false;
	}
}
ItemHelper.InitializeItem(Sapphire1);






class Sapphire2 extends Sapphire1
{
	constructor()
	{
		super(10);

		this.Grade = GRADE.COMMON;
	}
}
ItemHelper.InitializeItem(Sapphire2);


class Sapphire3 extends Sapphire1
{
	constructor()
	{
		super(15);

		this.Grade = GRADE.RARE;
	}
}
ItemHelper.InitializeItem(Sapphire3);


class Sapphire4 extends Sapphire1
{
	constructor()
	{
		super(20);

		this.Grade = GRADE.MYTHICAL;
	}
}
ItemHelper.InitializeItem(Sapphire4);


class Sapphire5 extends Sapphire1
{
	constructor()
	{
		super(25);

		this.Grade = GRADE.LEGENDARY;
	}
}
ItemHelper.InitializeItem(Sapphire5);























class Topaz1 extends Item
{
	constructor(bonus = 5)
	{
		super();

		this.stackAble = false;
		this.type = TYPE.ENCHANT;
		
		this.Texture = "item.topaz";
		this.name = "ITEM.ENCHANT.TOPAZ.NAME";
		this.shineStrength = 0;
		this.Grade = GRADE.NORMAL;

		this.bonus = new ItemBonus(STAT.DAMAGE_THUNDER, bonus);

		this.Description = 'ITEM.ENCHANT.GEM.DESCRIPTION';
		this.price = 1000;
	}

	Require(item)
	{
		if(item.slot != SLOT.CANNON) return false;
        if(item.Element == ELEMENT.THUNDER) return true;
        if(item.Charged?.element == ELEMENT.THUNDER) return true;

		return false;
	}
}
ItemHelper.InitializeItem(Topaz1);






class Topaz2 extends Topaz1
{
	constructor()
	{
		super(10);

		this.Grade = GRADE.COMMON;
	}
}
ItemHelper.InitializeItem(Topaz2);


class Topaz3 extends Topaz1
{
	constructor()
	{
		super(15);

		this.Grade = GRADE.RARE;
	}
}
ItemHelper.InitializeItem(Topaz3);


class Topaz4 extends Topaz1
{
	constructor()
	{
		super(20);

		this.Grade = GRADE.MYTHICAL;
	}
}
ItemHelper.InitializeItem(Topaz4);


class Topaz5 extends Topaz1
{
	constructor()
	{
		super(25);

		this.Grade = GRADE.LEGENDARY;
	}
}
ItemHelper.InitializeItem(Topaz5);
























class Emerald1 extends Item
{
	constructor(bonus = 1)
	{
		super();

		this.stackAble = false;
		this.type = TYPE.ENCHANT;
		
		this.Texture = "item.emerald";
		this.name = "ITEM.ENCHANT.EMERALD.NAME";
		this.shineStrength = 0;
		this.Grade = GRADE.NORMAL;

		this.bonus = new ItemBonus(STAT.DAMAGE_POISON, bonus);

		this.Description = 'ITEM.ENCHANT.GEM.DESCRIPTION';
		this.price = 1000;
	}

	Require(item)
	{
		if(item.slot != SLOT.CANNON) return false;
        if(item.Element == ELEMENT.POISON) return true;
        if(item.Charged?.element == ELEMENT.POISON) return true;

		return false;
	}
}
ItemHelper.InitializeItem(Emerald1);






class Emerald2 extends Emerald1
{
	constructor()
	{
		super(2);

		this.Grade = GRADE.COMMON;
	}
}
ItemHelper.InitializeItem(Emerald2);


class Emerald3 extends Emerald1
{
	constructor()
	{
		super(3);

		this.Grade = GRADE.RARE;
	}
}
ItemHelper.InitializeItem(Emerald3);


class Emerald4 extends Emerald1
{
	constructor()
	{
		super(4);

		this.Grade = GRADE.MYTHICAL;
	}
}
ItemHelper.InitializeItem(Emerald4);


class Emerald5 extends Emerald1
{
	constructor()
	{
		super(5);

		this.Grade = GRADE.LEGENDARY;
	}
}
ItemHelper.InitializeItem(Emerald5);class EnchantCrystalAD extends Item
{
	constructor(bonus = 5)
	{
		super();

		this.stackAble = false;
		this.type = TYPE.ENCHANT;
		
		this.Texture = "item.enchant.crystal.blue";
		this.name = "ITEM.ENCHANT.CRYSTAL.AD.NAME";
		this.shineStrength = 0;
		this.Grade = GRADE.NORMAL;

		this.bonus = new ItemBonus(STAT.ATTACK_DAMAGE, bonus, true);

		this.Description = 'ITEM.ENCHANT.CRYSTAL.DESCRIPTION';
		this.price = 1000;
	}

	Require(item)
	{
		if(item.slot == SLOT.SPECIAL) return true;

		return false;
	}
}
ItemHelper.InitializeItem(EnchantCrystalAD);




class EnchantCrystalAD2 extends EnchantCrystalAD
{
	constructor()
	{
		super(10);

        this.Grade = GRADE.COMMON;
	}
}
ItemHelper.InitializeItem(EnchantCrystalAD2);


class EnchantCrystalAD3 extends EnchantCrystalAD
{
	constructor()
	{
		super(15);

        this.Grade = GRADE.RARE;
	}
}
ItemHelper.InitializeItem(EnchantCrystalAD3);


class EnchantCrystalAD4 extends EnchantCrystalAD
{
	constructor()
	{
		super(20);

        this.Grade = GRADE.MYTHICAL;
	}
}
ItemHelper.InitializeItem(EnchantCrystalAD4);


class EnchantCrystalAD5 extends EnchantCrystalAD
{
	constructor()
	{
		super(25);

        this.Grade = GRADE.LEGENDARY;
	}
}
ItemHelper.InitializeItem(EnchantCrystalAD5);










class EnchantCrystalDEF extends EnchantCrystalAD
{
	constructor(bonus = 5)
	{
		super();
		
		this.Texture = "item.enchant.crystal.white";
		this.name = "ITEM.ENCHANT.CRYSTAL.DEF.NAME";
		this.bonus = new ItemBonus(STAT.DEFENSE, bonus, true);
	}
}
ItemHelper.InitializeItem(EnchantCrystalDEF);



class EnchantCrystalDEF2 extends EnchantCrystalDEF
{
	constructor()
	{
		super(10);

        this.Grade = GRADE.COMMON;
	}
}
ItemHelper.InitializeItem(EnchantCrystalDEF2);


class EnchantCrystalDEF3 extends EnchantCrystalDEF
{
	constructor()
	{
		super(15);

        this.Grade = GRADE.RARE;
	}
}
ItemHelper.InitializeItem(EnchantCrystalDEF3);


class EnchantCrystalDEF4 extends EnchantCrystalDEF
{
	constructor()
	{
		super(20);

        this.Grade = GRADE.MYTHICAL;
	}
}
ItemHelper.InitializeItem(EnchantCrystalDEF4);


class EnchantCrystalDEF5 extends EnchantCrystalDEF
{
	constructor()
	{
		super(25);

        this.Grade = GRADE.LEGENDARY;
	}
}
ItemHelper.InitializeItem(EnchantCrystalDEF5);




























class EnchantCrystalBlock extends EnchantCrystalAD
{
	constructor(bonus = 5)
	{
		super();
		
		this.Texture = "item.enchant.crystal.black";
		this.name = "ITEM.ENCHANT.CRYSTAL.BLOCK.NAME";
		this.Description = "ITEM.ENCHANT.CRYSTAL.BLOCK.DESCRIPTION";
		this.bonus = new ItemBonus(STAT.BLOCK_CHANCE, bonus);
	}
}
ItemHelper.InitializeItem(EnchantCrystalBlock);



class EnchantCrystalBlock2 extends EnchantCrystalBlock
{
	constructor()
	{
		super(10);

        this.Grade = GRADE.COMMON;
	}
}
ItemHelper.InitializeItem(EnchantCrystalBlock2);


class EnchantCrystalBlock3 extends EnchantCrystalBlock
{
	constructor()
	{
		super(15);

        this.Grade = GRADE.RARE;
	}
}
ItemHelper.InitializeItem(EnchantCrystalBlock3);


class EnchantCrystalBlock4 extends EnchantCrystalBlock
{
	constructor()
	{
		super(20);

        this.Grade = GRADE.MYTHICAL;
	}
}
ItemHelper.InitializeItem(EnchantCrystalBlock4);


class EnchantCrystalBlock5 extends EnchantCrystalBlock
{
	constructor()
	{
		super(25);

        this.Grade = GRADE.LEGENDARY;
	}
}
ItemHelper.InitializeItem(EnchantCrystalBlock5);





























class EnchantCrystalMastery extends EnchantCrystalAD
{
	constructor(bonus = 5)
	{
		super();
		
		this.Texture = "item.enchant.crystal.purple";
		this.name = "ITEM.ENCHANT.CRYSTAL.MASTERY.NAME";
		this.Description = "ITEM.ENCHANT.CRYSTAL.MASTERY.DESCRIPTION";
		this.bonus = new ItemBonus(STAT.ELEMENTAL_MASTERY, bonus);
	}
}
ItemHelper.InitializeItem(EnchantCrystalMastery);



class EnchantCrystalMastery2 extends EnchantCrystalMastery
{
	constructor()
	{
		super(10);

        this.Grade = GRADE.COMMON;
	}
}
ItemHelper.InitializeItem(EnchantCrystalMastery2);


class EnchantCrystalMastery3 extends EnchantCrystalMastery
{
	constructor()
	{
		super(15);

        this.Grade = GRADE.RARE;
	}
}
ItemHelper.InitializeItem(EnchantCrystalMastery3);


class EnchantCrystalMastery4 extends EnchantCrystalMastery
{
	constructor()
	{
		super(20);

        this.Grade = GRADE.MYTHICAL;
	}
}
ItemHelper.InitializeItem(EnchantCrystalMastery4);


class EnchantCrystalMastery5 extends EnchantCrystalMastery
{
	constructor()
	{
		super(25);

        this.Grade = GRADE.LEGENDARY;
	}
}
ItemHelper.InitializeItem(EnchantCrystalMastery5);class EnchantGemAD extends Item
{
	constructor(bonus = 5)
	{
		super();

		this.stackAble = false;
		this.type = TYPE.ENCHANT;
		
		this.Texture = "item.enchant.gem.blue";
		this.name = "ITEM.ENCHANT.GEM.AD.NAME";
		this.shineStrength = 0;
		this.Grade = GRADE.NORMAL;

		this.bonus = new ItemBonus(STAT.ATTACK_DAMAGE, bonus);
		this.price = 1000;

		this.Description = 'ITEM.ENCHANT.GEM.DESCRIPTION';
	}

	Require(item)
	{
		if(item.slot == SLOT.CANNON) return true;

		return false;
	}
}
ItemHelper.InitializeItem(EnchantGemAD);


class EnchantGemAD2 extends EnchantGemAD
{
	constructor()
	{
		super(10);

		this.Grade = GRADE.COMMON;
	}
}
ItemHelper.InitializeItem(EnchantGemAD2);


class EnchantGemAD3 extends EnchantGemAD
{
	constructor()
	{
		super(15);

		this.Grade = GRADE.RARE;
	}
}
ItemHelper.InitializeItem(EnchantGemAD3);

class EnchantGemAD4 extends EnchantGemAD
{
	constructor()
	{
		super(20);

		this.Grade = GRADE.MYTHICAL;
	}
}
ItemHelper.InitializeItem(EnchantGemAD4);

class EnchantGemAD5 extends EnchantGemAD
{
	constructor()
	{
		super(25);

		this.Grade = GRADE.LEGENDARY;
	}
}
ItemHelper.InitializeItem(EnchantGemAD5);







/*//////////////////////////////////////////       CHARGE       //////////////////////////////////////////*/

class EnchantGemMP extends EnchantGemAD
{
	constructor(bonus = 5)
	{
		super();

		this.Texture = "item.enchant.gem.yellow";
		this.name = "ITEM.ENCHANT.GEM.CHARGE.NAME";

		this.bonus = new ItemBonus(STAT.CHARGE, bonus);
	}

	Require(item)
	{
		if(item.requiredMP == 0) return false;
		if(item.fixedMP != null) return false;
		if(item.slot == SLOT.CANNON) return true;

		return false;
	}
}
ItemHelper.InitializeItem(EnchantGemMP);



class EnchantGemMP2 extends EnchantGemMP
{
	constructor()
	{
		super(10);
		this.Grade = GRADE.COMMON;
	}
}
ItemHelper.InitializeItem(EnchantGemMP2);

class EnchantGemMP3 extends EnchantGemMP
{
	constructor()
	{
		super(15);
		this.Grade = GRADE.RARE;
	}
}
ItemHelper.InitializeItem(EnchantGemMP3);

class EnchantGemMP4 extends EnchantGemMP
{
	constructor()
	{
		super(20);
		this.Grade = GRADE.MYTHICAL;
	}
}
ItemHelper.InitializeItem(EnchantGemMP4);

class EnchantGemMP5 extends EnchantGemMP
{
	constructor()
	{
		super(25);
		this.Grade = GRADE.LEGENDARY;
	}
}
ItemHelper.InitializeItem(EnchantGemMP5);










/*//////////////////////////////////////////       HP       //////////////////////////////////////////*/

class EnchantGemHP extends EnchantGemAD
{
	constructor(bonus = 20)
	{
		super();

		this.Texture = "item.enchant.gem.violet";
		this.name = "ITEM.ENCHANT.GEM.HP.NAME";

		this.bonus = new ItemBonus(STAT.MAX_HP, bonus);
	}

	Require(item)
	{
		if(item.slot == SLOT.CORE) return true;

		return false;
	}
}
ItemHelper.InitializeItem(EnchantGemHP);



class EnchantGemHP2 extends EnchantGemHP
{
	constructor()
	{
		super(40);
		this.Grade = GRADE.COMMON;
	}
}
ItemHelper.InitializeItem(EnchantGemHP2);

class EnchantGemHP3 extends EnchantGemHP
{
	constructor()
	{
		super(60);
		this.Grade = GRADE.RARE;
	}
}
ItemHelper.InitializeItem(EnchantGemHP3);

class EnchantGemHP4 extends EnchantGemHP
{
	constructor()
	{
		super(80);
		this.Grade = GRADE.MYTHICAL;
	}
}
ItemHelper.InitializeItem(EnchantGemHP4);

class EnchantGemHP5 extends EnchantGemHP
{
	constructor()
	{
		super(100);
		this.Grade = GRADE.LEGENDARY;
	}
}
ItemHelper.InitializeItem(EnchantGemHP5);







/*//////////////////////////////////////////       DEF       //////////////////////////////////////////*/

class EnchantGemDEF extends EnchantGemAD
{
	constructor(bonus = 5)
	{
		super();

		this.Texture = "item.enchant.gem.white";
		this.name = "ITEM.ENCHANT.GEM.DEF.NAME";

		this.bonus = new ItemBonus(STAT.DEFENSE, bonus);
	}

	Require(item)
	{
		if(item.slot == SLOT.CORE) return true;

		return false;
	}
}
ItemHelper.InitializeItem(EnchantGemDEF);



class EnchantGemDEF2 extends EnchantGemDEF
{
	constructor()
	{
		super(10);
		this.Grade = GRADE.COMMON;
	}
}
ItemHelper.InitializeItem(EnchantGemDEF2);

class EnchantGemDEF3 extends EnchantGemDEF
{
	constructor()
	{
		super(15);
		this.Grade = GRADE.RARE;
	}
}
ItemHelper.InitializeItem(EnchantGemDEF3);

class EnchantGemDEF4 extends EnchantGemDEF
{
	constructor()
	{
		super(20);
		this.Grade = GRADE.MYTHICAL;
	}
}
ItemHelper.InitializeItem(EnchantGemDEF4);

class EnchantGemDEF5 extends EnchantGemDEF
{
	constructor()
	{
		super(25);
		this.Grade = GRADE.LEGENDARY;
	}
}
ItemHelper.InitializeItem(EnchantGemDEF5);





















/*//////////////////////////////////////////       AD%       //////////////////////////////////////////*/

class EnchantGemADp extends EnchantGemAD
{
	constructor(bonus = 5)
	{
		super();

		this.Texture = "item.enchant.gem.red";
		this.name = "ITEM.ENCHANT.GEM.AD.P.NAME";

		this.bonus = new ItemBonus(STAT.ATTACK_DAMAGE, bonus, true);
	}
}
ItemHelper.InitializeItem(EnchantGemADp);



class EnchantGemADp2 extends EnchantGemADp
{
	constructor()
	{
		super(10);
		this.Grade = GRADE.COMMON;
	}
}
ItemHelper.InitializeItem(EnchantGemADp2);

class EnchantGemADp3 extends EnchantGemADp
{
	constructor()
	{
		super(15);
		this.Grade = GRADE.RARE;
	}
}
ItemHelper.InitializeItem(EnchantGemADp3);

class EnchantGemADp4 extends EnchantGemADp
{
	constructor()
	{
		super(20);
		this.Grade = GRADE.MYTHICAL;
	}
}
ItemHelper.InitializeItem(EnchantGemADp4);

class EnchantGemADp5 extends EnchantGemADp
{
	constructor()
	{
		super(25);
		this.Grade = GRADE.LEGENDARY;
	}
}
ItemHelper.InitializeItem(EnchantGemADp5);

















/*//////////////////////////////////////////       Attack Speed       //////////////////////////////////////////*/

class EnchantGemAS extends EnchantGemAD
{
	constructor(bonus = 0.1)
	{
		super();

		this.Texture = "item.enchant.gem.green";
		this.name = "ITEM.ENCHANT.GEM.AS.NAME";

		this.bonus = new ItemBonus(STAT.ATTACK_SPEED, bonus);
	}
}
ItemHelper.InitializeItem(EnchantGemAS);



class EnchantGemAS2 extends EnchantGemAS
{
	constructor()
	{
		super(0.2);
		this.Grade = GRADE.COMMON;
	}
}
ItemHelper.InitializeItem(EnchantGemAS2);

class EnchantGemAS3 extends EnchantGemAS
{
	constructor()
	{
		super(0.3);
		this.Grade = GRADE.RARE;
	}
}
ItemHelper.InitializeItem(EnchantGemAS3);

class EnchantGemAS4 extends EnchantGemAS
{
	constructor()
	{
		super(0.4);
		this.Grade = GRADE.MYTHICAL;
	}
}
ItemHelper.InitializeItem(EnchantGemAS4);

class EnchantGemAS5 extends EnchantGemAS
{
	constructor()
	{
		super(0.5);
		this.Grade = GRADE.LEGENDARY;
	}
}
ItemHelper.InitializeItem(EnchantGemAS5);



class EnchantLock extends Item
{
	constructor()
	{
		super();

		this.stackAble = false;
		this.type = TYPE.ENCHANT;
		
		this.Texture = "enchantGemLock";
		this.name = "ITEM.ENCHANT.LOCK.NAME";
		this.shineStrength = 0;
		this.Grade = GRADE.NORMAL;

		this.bonus = null;

	}
}
ItemHelper.InitializeItem(EnchantLock);class EssenceGradeExtractor extends Item
{
	constructor()
	{
		super();

		this.type = TYPE.BLESSING;
		
		this.Texture = "item.essence_extractor";
		this.name = "ITEM.ESSENCE_EXTRACTOR.NAME";
		this.Description = "ITEM.ESSENCE_EXTRACTOR.DESCRIPTION";

		this.price = 1000;
	}

    Require(item)
    {
        if(!item) return false;
        if(!item.equipAble) return false;
        if(!item.Grade) return false;
        if(item.Grade == GRADE.NORMAL) return false;
        // if(item.slot == SLOT.SPECIAL) return false;     //cannot extract accessories

        var id = ItemHelper.GetGradesOrder(item.Grade);
        var grade_essence = Item.Get('EssenceGrade' + (id - 1));
        if(!grade_essence) return false;

        return true;
    }

    Bless(item, isGhostItem = false)
    {
        var amount = 2;
        var grade = item.Grade;
        var id = ItemHelper.GetGradesOrder(grade);
        if(item.slot == SLOT.CANNON) amount = 1;

        var grade_essence = Item.Get('EssenceGrade' + (id - 1));
        if(!grade_essence) return false;

        if(!isGhostItem) World.Player.addItemToInventory(grade_essence, amount);
        item.Grade = GRADE.NORMAL;
    }
}
ItemHelper.InitializeItem(EssenceGradeExtractor);



class EssenceGradeExtractorPermanent extends EssenceGradeExtractor
{
	constructor()
	{
		super();
        this.Grade = GRADE.TRANSCENDENTAL;

        this.name = "ITEM.ESSENCE_EXTRACTOR.PERMANENT.NAME";

        this.stackAble = false;
        this.showGrade = false;
        this.canBeSold = false;
		this.isUnique = true;
	}

    Bless(item, isGhostItem = false)
    {
        super.Bless(item, isGhostItem);

        if(!isGhostItem) this.count++;
    }
}
ItemHelper.InitializeItem(EssenceGradeExtractorPermanent);



class EssenceGrade0 extends Item
{
	constructor(grade = GRADE.COMMON)
	{
		super();
        this.Grade = grade;
		
		this.Texture = "item.essence.common";
		this.name = "Essence";
		this.Description = "ITEM.ESSENCE_GRADE.DESCRIPTION";

        this.ARGS = {GRADE: Style.InjectColor(this.Grade)};

		this.price = 250;
	}
}
ItemHelper.InitializeItem(EssenceGrade0);

class EssenceGrade1 extends EssenceGrade0
{
	constructor()
	{
		super(GRADE.RARE);
		
		this.Texture = "item.essence.rare";
	}
}
ItemHelper.InitializeItem(EssenceGrade1);

class EssenceGrade2 extends EssenceGrade0
{
	constructor()
	{
		super(GRADE.MYTHICAL);
		
		this.Texture = "item.essence.mythical";
	}
}
ItemHelper.InitializeItem(EssenceGrade2);

class EssenceGrade3 extends EssenceGrade0
{
	constructor()
	{
		super(GRADE.LEGENDARY);
		
		this.Texture = "item.essence.legendary";
	}
}
ItemHelper.InitializeItem(EssenceGrade3);

class FlowInBottle extends ItemSpecial
{
	constructor()
	{
		super();

		this.type = TYPE.ITEM_DASH;
        this.restrictTypes = 1;
		
		this.Texture = "item.bottle.flow";
		this.name = "ITEM.FLOW_IN_BOTTLE.NAME";
        this.Description = 'ITEM.FLOW_IN_BOTTLE.DESCRIPTION';

		this.primary = 
		[
			new ItemBonus(STAT.DASH_COOLTIME, 2),
			new ItemBonus(STAT.DASH_DURATION, 10),
			new ItemBonus(STAT.DASH_DISTANCE, 5),
		];
	}
}
ItemHelper.InitializeItem(FlowInBottle);class HolyLauncher extends ItemWeapon
{
	constructor()
	{
		super(true);

		this.type = TYPE.CANNON;
		
		this.Texture = "ShadowScythe";
		this.name = "Holy Cannon";
		this.enchantSlots = 0;

		this.BulletType = 'HolyBullet';
        this.upgradeAble = false;

		this.primary = 
		[
			new ItemBonus(STAT.ATTACK_DAMAGE, 9999),
			new ItemBonus(STAT.ATTACK_SPEED, 60),
            new ItemBonus(STAT.ATTACK_RANGE, 9999)
		];

		this.Lore = "ITEM_HOLY_LAUNCHER_LORE";
	
		this.Model = new ModelCannonBase('model.item.bubbleCannon1', null, 1.1);

        this.Grade = GRADE.TRANSCENDENCE;
	}

    GetAdditionalBulletStats()
    {
        var s = 
        {
            Pierce: 999,
            Bounce: 4,
            Scale: 4,
            spd: 1000
        };
        return s;
    }
}
ItemHelper.InitializeItem(HolyLauncher);/*//////////////////////////////////////////       BULLETS       //////////////////////////////////////////*/

class HolyStoneBullet1 extends EnchantGemAD
{
	constructor(bonus = 1, percent = false)
	{
		super();

		this.Texture = "item.holy_stone.bullet";
		this.name = "ITEM.HOLY_STONE.BULLET.NAME";

		this.bonus = new ItemBonus(STAT.BULLETS_COUNT, bonus, percent);
	}

	Require(item)
	{
		if(item.slot != SLOT.CANNON) return false;
		if(!item.canIncreaseBulletsCount()) return false;

		return true;
	}
}
ItemHelper.InitializeItem(HolyStoneBullet1);




class HolyStoneBullet2 extends HolyStoneBullet1
{
	constructor()
	{
		super(2);
        this.Grade = GRADE.COMMON;
	}
}
ItemHelper.InitializeItem(HolyStoneBullet2);



class HolyStoneBullet3 extends HolyStoneBullet1
{
	constructor()
	{
		super(50, true);
        this.Grade = GRADE.RARE;
	}
}
ItemHelper.InitializeItem(HolyStoneBullet3);


class HolyStoneBullet4 extends HolyStoneBullet1
{
	constructor()
	{
		super(100, true);
        this.Grade = GRADE.MYTHICAL;
	}
}
ItemHelper.InitializeItem(HolyStoneBullet4);



class HolyStoneBullet5 extends HolyStoneBullet1
{
	constructor()
	{
		super(5);
        this.Grade = GRADE.LEGENDARY;
	}
}
ItemHelper.InitializeItem(HolyStoneBullet5);
























/*//////////////////////////////////////////       RANGE       //////////////////////////////////////////*/

class HolyStoneRange1 extends EnchantGemAD
{
	constructor(bonus = 100, percent = false)
	{
		super();

		this.Texture = "item.holy_stone.attack_range";
		this.name = "ITEM.HOLY_STONE.RANGE.NAME";

		this.bonus = new ItemBonus(STAT.ATTACK_RANGE, bonus, percent);
	}

	Require(item)
	{
		if(item.slot != SLOT.CANNON) return false;

		return true;
	}
}
ItemHelper.InitializeItem(HolyStoneRange1);






class HolyStoneRange2 extends HolyStoneRange1
{
	constructor()
	{
		super(150);
        this.Grade = GRADE.COMMON;
	}
}
ItemHelper.InitializeItem(HolyStoneRange2);



class HolyStoneRange3 extends HolyStoneRange1
{
	constructor()
	{
		super(250, true);
        this.Grade = GRADE.RARE;
	}
}
ItemHelper.InitializeItem(HolyStoneRange3);


class HolyStoneRange4 extends HolyStoneRange1
{
	constructor()
	{
		super(300, true);
        this.Grade = GRADE.MYTHICAL;
	}
}
ItemHelper.InitializeItem(HolyStoneRange4);



class HolyStoneRange5 extends HolyStoneRange1
{
	constructor()
	{
		super(400);
        this.Grade = GRADE.LEGENDARY;
	}
}
ItemHelper.InitializeItem(HolyStoneRange5);












/*//////////////////////////////////////////       ATTACK SPEED       //////////////////////////////////////////*/

class HolyStoneAS1 extends EnchantGemAD
{
	constructor(bonus = 20)
	{
		super();

		this.Texture = "item.holy_stone.attack_speed";
		this.name = "ITEM.HOLY_STONE.ATTACK_SPEED.NAME";

		this.bonus = new ItemBonus(STAT.ATTACK_SPEED, bonus, true);
	}

	Require(item)
	{
		if(item.slot != SLOT.CANNON) return false;

		return true;
	}
}
ItemHelper.InitializeItem(HolyStoneAS1);






class HolyStoneAS2 extends HolyStoneAS1
{
	constructor()
	{
		super(40);
        this.Grade = GRADE.COMMON;
	}
}
ItemHelper.InitializeItem(HolyStoneAS2);



class HolyStoneAS3 extends HolyStoneAS1
{
	constructor()
	{
		super(60, true);
        this.Grade = GRADE.RARE;
	}
}
ItemHelper.InitializeItem(HolyStoneAS3);


class HolyStoneAS4 extends HolyStoneAS1
{
	constructor()
	{
		super(80);
        this.Grade = GRADE.MYTHICAL;
	}
}
ItemHelper.InitializeItem(HolyStoneAS4);



class HolyStoneAS5 extends HolyStoneAS1
{
	constructor()
	{
		super(100);
        this.Grade = GRADE.LEGENDARY;
	}
}
ItemHelper.InitializeItem(HolyStoneAS5);class Honeycomb extends Item
{
	constructor()
	{
		super();

		this.stackAble = true;
		this.maxStackSize = 999;
		this.upgradeAble = false;
		this.enchantAble = false;

		this.Texture = 'item.honey.comb';
        this.name = "ITEM.HONEY.COMB.NAME";
		
        this.Description = 'ITEM.HONEY.COMB.DESCRIPTION';

        this.Recipe = new ItemRecipe(this, [
            ['HoneyPiece', 20],
            ['LiquidOxygen', 5]
        ]);

        this.Regeneration = 40;
        this.Time = 20;
        this.ARGS = {REGEN: this.Regeneration, TIME: this.Time};
	}

	onUse(player)
	{
		ApplyEffect(player, 'Regeneration', this.Regeneration/this.Time, this.Time);

        this.count--;
		if(this.count <= 0)
		{
			var index = player.inventory.indexOf(this);
			if(index > -1) player.inventory[index] = null;
		}
	}
}
ItemHelper.InitializeItem(Honeycomb);class InfinityStoneOfSpace extends ItemSpecial
{
	constructor()
	{
		super();
		
        this.type = TYPE.F_KEY_MOVEMENT;
        this.restrictTypes = 1;

		this.Texture = "item.infinity_stone.space";
		this.name = "ITEM.INFINITY_STONE.SPACE.NAME";

		this.primary = 
		[
            new ItemBonus(STAT.ATTACK_DAMAGE, 20, true),
            new ItemBonus(STAT.MAX_HP, 20),
			new ItemBonus(STAT.MOVEMENT_SPEED, 20)
		];

        this.enchantAble = false;
        this.Grade = GRADE.ANGELIC;
        this.showGrade = false;

        this.canBeSold = false;
        this.isUnique = true;
		
		this.Range = 400;

		// this.Lore ='Press [F] to teleport toward cursor.';
		this.Description ='ITEM.INFINITY_STONE.SPACE.DESCRIPTION';
		this.Lore ='ITEM.INFINITY_STONE.SPACE.LORE';

		this.quickFlashCooltime = 5 * Main.FPS;
		this.quickFlashTick = 0;

        this.ARGS = {CD: this.quickFlashCooltime/Main.FPS, R: this.Range};
	}

    getDescription()
    {
        var k = Settings.Controls.UseItem;
        this.ARGS.KEY = (k==' ') ? Lang.Get('KEY.SPACE') : k;
        return super.getDescription();
    }

	onTakeOut()
	{
		World.Player.canFastTravel = false;
	}

    canQuickFlash(owner)
    {
        if(this.quickFlashTick + this.quickFlashCooltime > Main.ageInTicks) return false;
        if(!owner.allowControl) return false;
        if(!owner.allowMove) return false;
        if(owner.canInteractWith.length) return false;     //disable flash when player can interact
        if(!Settings.Controls.StateUseItem) return false;

        return true;
    }


    QuickFlash(owner)
	{
        var r = this.Range;

		var dist = MathHelper.GetDistance([owner.x - Camera.xView, owner.y - Camera.yView], [Mouse.x, Mouse.y]);
		if(dist < r) r = dist;
		var angle = MathHelper.getAngle2([owner.x - Camera.xView, owner.y - Camera.yView], [Mouse.x, Mouse.y]);
		var new_pos = MathHelper.lineToAngle([owner.x, owner.y], r, angle);
		
        var dist_from_center = MathHelper.GetDistance(new_pos, World.CenterPoint);
        var R = World.Radius;


        //destination is outside room
        if(dist_from_center > R)
        {            
            new_pos = MathHelper.GetIntersectionWithCircle([owner.x, owner.y], angle, World.CenterPoint, R);
        }

        

        // Graphic.addPostRenderFunction(Graphic.Layer.GUI, 
        //     () =>
        //     {
        //         ChangeLayer(Graphic.Layer.GUI);

        //         ctx.save();
        //         ctx.beginPath();

        //         ctx.moveTo(owner.x - Camera.xView, owner.y - Camera.yView);
        //         ctx.lineTo(new_pos.x - Camera.xView, new_pos.y - Camera.yView);
        //         ctx.lineWidth = 5;
        //         ctx.stroke();

        //         ctx.closePath();
        //         ctx.restore();

        //         ctx.save();
        //         ctx.fillStyle = 'violet';
        //         ctx.fillRect(new_pos.x - 2 - Camera.xView, new_pos.y - 2 - Camera.yView, 4, 4);
        //         ctx.save();

        //         RestoreLayer();
        //     }
        // )
        // return;


        // World.AddParticle(new Particle("vfx.tp", owner.x + (owner.Width / 2),  owner.y + (owner.Height / 2), 12, owner.Width, owner.Height, owner.Scale * 3));
        World.AddParticle(new ParticleFlash(owner.x,  owner.y, {Scale: owner.Scale}));
        World.AddParticle(new ParticleFlash(new_pos.x,  new_pos.y, {Scale: owner.Scale, Type: 1}));


        

        Camera.Smooth(new_pos.x, new_pos.y, .5);
		owner.x = new_pos.x;
		owner.y = new_pos.y;
        if(owner.canInterruptRecall) owner.isRecalling = false;  //allows to interrupt recall

		this.quickFlashTick = Main.ageInTicks;
	}

	onEquipTick(owner)
	{
		if(this.canQuickFlash(owner)) this.QuickFlash(owner);
        this.UpdateCoolTimeIcon(owner);
        owner.canFastTravel = true;
	}

    UpdateCoolTimeIcon(owner)
    {
        var required = this.quickFlashCooltime;
		var current = Main.ageInTicks - this.quickFlashTick;
		
		owner.UpdateCooltime('FLASH', current, required);
    }
}
ItemHelper.InitializeItem(InfinityStoneOfSpace);class ItemPetFrogo extends ItemSpecial
{
	constructor()
	{
		super();
		
		this.Texture = "item.pet.frogo";
		this.name = "ITEM.PET.FROGO.NAME";

        this.DMG = 40;

		this.primary = 
		[
			new ItemBonus(STAT.SUMMON_DAMAGE, this.DMG)
		];
		
		this.summoned = null;
        this.dropLoot = false;

		this.Description = 'ITEM.PET.FROGO.DESCRIPTION';
	}

	unSummon()
	{
        this.summoned?.Kill();
		this.summoned = null;
	}

	onEquip()
	{
		this.unSummon();
		this.summon();
	}

	onTakeOut()
	{
		this.unSummon();
	}

	summon()
	{
        var entity = new FrogoPet();
            entity.x = World.Player.x;
            entity.y = World.Player.y;
            entity.AD = this.DMG;

        World.AddEntity(entity);
		this.summoned = entity;
	}

	onEquipTick()
	{
		if(!this.summoned) this.summon();
	}
}
ItemHelper.InitializeItem(ItemPetFrogo);class LiquidOxygen extends Item
{
	constructor()
	{
		super();

		this.stackAble = true;
		this.maxStackSize = 999;
		this.upgradeAble = false;
		this.enchantAble = false;

		this.Texture = 'item.liquid_oxygen';
        this.name = "ITEM.LIQUID_OXYGEN.NAME";
		
		this.price = 100;
		this.inShopPrice = 500;

		
        this.Description = 'ITEM.LIQUID_OXYGEN.DESCRIPTION';
		this.ARGS = {PRICE: Style.DottedText(this.price)};
	}

	onUse(player)
	{
		this.count--;

		player.coins += this.price;

		if(this.count <= 0)
		{
			var index = player.inventory.indexOf(this);
			if(index > -1)
			{
				player.inventory[index] = null;
			}
		}
	}
}
ItemHelper.InitializeItem(LiquidOxygen);








class ItemOxygen extends Item
{
	constructor()
	{
		super();

		this.stackAble = true;
		this.maxStackSize = 999999;
		this.upgradeAble = false;
		this.enchantAble = false;

		this.Texture = 'item.oxygen';
        this.name = "ITEM.OXYGEN.NAME";
		
		this.showPriceInfo = false;
	}

	onUse(player)
	{
		this.count--;

		player.coins += 1;

		if(this.count <= 0)
		{
			var index = player.inventory.indexOf(this);
			if(index > -1)
			{
				player.inventory[index] = null;
			}
		}
	}
}
ItemHelper.InitializeItem(ItemOxygen);

class MachineGunBase extends ItemWeapon
{
	constructor()
	{
		super(true);

		this.Grade = GRADE.NORMAL;
		this.type = TYPE.CANNON;
		
		this.Texture = "item.machine_gun.1";
		this.name = "ITEM.MACHINE_GUN.BASE.NAME";
		this.enchantSlots = 2;
        this.knockBack = .1;
		this.BulletType = 'BulletBubble';


		this.primary = 
		[
			new ItemBonus(STAT.ATTACK_DAMAGE, 5),
			new ItemBonus(STAT.ATTACK_SPEED, 6),
			new ItemBonus(STAT.ATTACK_RANGE, 450)
		];

		this.ammoCost = 5;
	
		this.Model = new ModelMachineGun('model.item.machine.gun');
	}
}
ItemHelper.InitializeItem(MachineGunBase);class Icicle1 extends ItemWeapon
{
	constructor()
	{
		super(true);

		this.type = TYPE.CANNON;
		
		this.Texture = "projectile.frost_ball";
		this.name = 'ITEM.ICICLE.1.NAME';
		this.enchantSlots = 2;


		this.primary = 
		[
			new ItemBonus(STAT.ATTACK_DAMAGE, 1),
			new ItemBonus(STAT.ATTACK_SPEED, 0.5)
		];

		// this.Description = 'ITEM.ROCKET_LAUNCHER.SPARK.DESCRIPTION';
		// this.Lore = "ITEM_BUBBLE_TERMINATOR_LORE";
	
		this.Model = new ModelMagicSphere('projectile.frost_ball', 0, .6, -0.15, .75);
        this.ChargeDescription = 'ITEM.SLOWING.DESCRIPTION';

		this.shootBeforeCharge = false;
		this.requiredMP = 40;
		this.ammoCost = 40;

        this.BulletType = 'BulletFrostBall';
        this.chargeBullets = 2;
		this.canIncreaseChargeBulletCount = true;

        this.SlowStrength = 25;
        this.SlowDuration = 5;

		this.Charged = 
		{
			// damage: {min: 1, max: 33},
			AD: 10,
			criticalChance: 0,
			criticalDamage: 0,
			element: ELEMENT.ICE
		};

        this.ARGS = {SLOW_S: this.SlowStrength, SLOW_D: this.SlowDuration};
	}

    GetAdditionalBulletStats()
    {
        var s = super.GetAdditionalBulletStats();
        s.spd = 300;
        s.Scale = 2;
        s.Bounce = 1;
        s.SlowDuration = this.SlowDuration;
        s.SlowStrength = this.SlowStrength

        return s;
    }

	GetBulletDamageInfo(owner = this.Owner)
    {
		if(!this.isChargedShot) return super.GetBulletDamageInfo(owner);
		return this.Charged;
    }
}
ItemHelper.InitializeItem(Icicle1);class HoneyPiece extends Item
{
	constructor()
	{
		super();

		this.stackAble = true;
		this.maxStackSize = 999;
		this.upgradeAble = false;
		this.enchantAble = false;

		this.Texture = 'item.honey.piece';
        this.name = "ITEM.HONEY.PIECE.NAME";
		
        this.Description = 'ITEM.HONEY.PIECE.DESCRIPTION';
	}

	onUse(player)
	{
		var pos = MathHelper.getRandomPointInRange(World.CenterPoint, World.Radius*.9);
        var e = new EntityHoneyDrop(pos.x, pos.y);

        World.AddEntity(e);

        this.count--;

		if(this.count <= 0)
		{
			var index = player.inventory.indexOf(this);
			if(index > -1) player.inventory[index] = null;
		}
	}
}
ItemHelper.InitializeItem(HoneyPiece);class NecklaceRegeneration extends ItemSpecial
{
	constructor()
	{
		super();
		
		this.Texture = "item.necklace.golden";
		this.name = "ITEM.NECKLACE.REGENERATION.NAME";
		this.Description = "ITEM.NECKLACE.REGENERATION.DESCRIPTION";

        this.Regeneration = 10;

		this.primary = 
		[
			new ItemBonus(STAT.MAX_HP, 20)
		];

        this.ARGS = {REGEN: this.Regeneration};
	}

    onEquipTick()
	{
        if(!World) return;
        if(!World.currentRoom) return;
        if(!World.Player) return;

        if(World.currentRoom.isCleared && !World.currentRoom.lastCleared) World.Player.Heal(this.Regeneration);
	}
}
ItemHelper.InitializeItem(NecklaceRegeneration);class PowerUpStone0 extends Item
{
	constructor()
	{
		super();

		this.type = TYPE.UPGRADE;

		this.upgradeChance = 0;			//dodatkowa szansa na ulepszenie
		this.degradeOnFail = true;			//cofa poziom przedmiotu przy niepowodzeniu
		
		this.Texture = "powerUpStone0";
		this.name = "Power-Up Stone";

	}
}
ItemHelper.InitializeItem(PowerUpStone0);class PowerUpStone1 extends Item
{
	constructor()
	{
		super();

		this.type = TYPE.UPGRADE;

		this.upgradeChance = 10;			//dodatkowa szansa na ulepszenie
		this.degradeOnFail = true;			//cofa poziom przedmiotu przy niepowodzeniu
		this.Grade = GRADE.RARE;
		this.shineStrength = 0.5;
		
		this.Texture = "powerUpStone1";
		this.name = "Power-Up Stone";

	}
}
ItemHelper.InitializeItem(PowerUpStone1);class PowerUpStone2 extends Item
{
	constructor()
	{
		super();

		this.type = TYPE.UPGRADE;

		this.upgradeChance = 30;			//dodatkowa szansa na ulepszenie
		this.degradeOnFail = true;			//cofa poziom przedmiotu przy niepowodzeniu
		this.Grade = GRADE.MYSTICAL;
		this.shineStrength = 0.7;
		
		this.Texture = "powerUpStone2";
		this.name = "Power-Up Stone";
	}
}
ItemHelper.InitializeItem(PowerUpStone2);class PowerUpStone3 extends Item
{
	constructor()
	{
		super();

		this.type = TYPE.UPGRADE;

		this.upgradeChance = 50;			//dodatkowa szansa na ulepszenie
		this.degradeOnFail = true;			//cofa poziom przedmiotu przy niepowodzeniu
		this.Grade = GRADE.LEGENDARY;
		this.shineStrength = 1;
		
		this.Texture = "powerUpStone3";
		this.name = "Power-Up Stone";
	}
}
ItemHelper.InitializeItem(PowerUpStone3);class QuestItem extends Item
{
	constructor()
	{
		super();

		this.type = TYPE.QUEST_ITEM;
		
        this.Grade = GRADE.DIVINE;
        this.showGrade = false;
		this.canBeSold = false;
	}
}




class ViVisScissors extends QuestItem
{
	constructor()
	{
		super();

		this.Texture = 'item.quest.golden_scissors';
        this.Description = 'ITEM.VIVISCISSORS.DESCRIPTION';
        this.name = 'ITEM.VIVISCISSORS.NAME';

		this.stackAble = false;
	}
}
ItemHelper.InitializeItem(ViVisScissors);

class Reflector1 extends ItemSpecial
{
	constructor()
	{
		super(true);
		this.Texture = "item.reflector1";
		this.name = "Reflector I";

		this.primary = 
		[
			new ItemBonus(STAT.LIGHT_RANGE, 100)
			// new ItemBonus(STAT.ACCELERATION, acc)
		];
	
		// this.Model = new ItemModel("coreBase", 81, 31, 2, 0, -42);
	}
}
ItemHelper.InitializeItem(Reflector1);class RiffleBase extends ItemWeaponLaser
{
	constructor()
	{
		super(true);

		this.type = TYPE.RIFFLE;
		
		this.Texture = "ShadowScythe";
		this.name = "Riffle 1";
		this.enchantSlots = 3;

		this.primary = 
		[
			new ItemBonus(STAT.ATTACK_DAMAGE, 40),
            new ItemBonus(STAT.ATTACK_SPEED, 1),
            new ItemBonus(STAT.CR, 10),
			new ItemBonus(STAT.ATTACK_RANGE, 1500)
		];

		this.Lore = "ITEM_BUBBLE_TERMINATOR_LORE";
	
		this.Model = new ModelCannonBase('model.item.bubbleCannon1');


        this.Duration = 3;
        this.rotationSpeed = 360;
        this.hurtDelay = 60;
	}

    GetAdditionalBulletStats()
    {
        var s = super.GetAdditionalBulletStats();

        s.hurtDelay = 1;
        s.maxAllowedTargets = 1;
        s.size = 20;

        return s;
    }

    GetCooltime()
    {
        var cooltime = ItemBonus.GetBonusValue(STAT.ATTACK_SPEED, this.primary) ?? 1;
        return 60 / cooltime;
    }
}
ItemHelper.InitializeItem(RiffleBase);




class Rifle1 extends ItemWeapon
{
	constructor()
	{
		super(true);
		
		this.type = TYPE.CANNON;
		
		this.Texture = "item.rifle.1";
		this.name = "ITEM.RIFLE.1.NAME";
		this.enchantSlots = 2;

		this.BulletType = 'BulletBubbleBullet';

		this.primary = 
		[
			new ItemBonus(STAT.ATTACK_DAMAGE, 20),
            new ItemBonus(STAT.ATTACK_SPEED, 0.75),
            new ItemBonus(STAT.CR, 10),
			new ItemBonus(STAT.ATTACK_RANGE, 1500)
		];

		this.ammoCost = 10;
	
		this.Model = new ModelRifle('model.item.rifle');
	}

    GetAdditionalBulletStats()
    {
        var s = super.GetAdditionalBulletStats();
        s.spd = 3000;

        return s;
    }
}
ItemHelper.InitializeItem(Rifle1);





class TheVirtuoso extends RiffleBase
{
	constructor()
	{
		super(true);
        this.BulletType = 'BulletVirtuoso';
		
		this.Texture = "item.riffle.the_virtuoso";
		this.name = "ITEM.THE_VIRTUOSO.NAME";
		this.enchantSlots = 4;

		this.primary = 
		[
			new ItemBonus(STAT.ATTACK_DAMAGE, 444),
            new ItemBonus(STAT.ATTACK_SPEED, 1),
			new ItemBonus(STAT.CR, -100),
			new ItemBonus(STAT.ATTACK_RANGE, 3000)
		];

		this.Lore = "ITEM.THE_VIRTUOSO.LORE";
		this.Description = "ITEM.THE_VIRTUOSO.DESCRIPTION";
	
		this.Model = new ModelCannonBase('model.item.the_virtuoso', null, 1.2, .25, -.35);
        this.requiredMP = 3;
        this.fixedMP = 0;

        this.showRequiredMP = false;

        this.Duration = 6;
	}

    GetAdditionalBulletStats()
    {
        var s = super.GetAdditionalBulletStats();
        s.Item = this;
        delete s.size;

        if(this.currentMP >= this.requiredMP)
        {
            s.Pierce = this.Owner.bulletStats.Pierce + 3;
        }

        return s;
    }

    GetBulletDamageInfo(ownerAD)
    {
        var data = super.GetBulletDamageInfo(ownerAD);
        if(this.currentMP >= this.requiredMP)
        {
            data.AD *= 4;
            data.criticalChance = 100;
        }
        return data;
    }

    Shoot(owner = this.Owner)
    {
        super.Shoot(owner);
    }
}
ItemHelper.InitializeItem(TheVirtuoso);class RingPhysical extends ItemSpecial
{
	constructor()
	{
		super();
		
		this.Texture = "item.ring.golden";
		this.name = "ITEM.RING.PHYSICAL.NAME";

		this.primary = 
		[
			new ItemBonus(STAT.ATTACK_DAMAGE, 10, true)
		];
	}
}
ItemHelper.InitializeItem(RingPhysical);class RocketLauncher1 extends ItemWeapon
{
	constructor()
	{
		super(true);

		this.type = TYPE.CANNON;
		
		this.Texture = "ShadowScythe";
		this.name = 'ITEM.ROCKET_LAUNCHER.1.NAME';
		this.enchantSlots = 2;


		this.primary = 
		[
			new ItemBonus(STAT.ATTACK_DAMAGE, 20),
			new ItemBonus(STAT.ATTACK_SPEED, 0.75),
			new ItemBonus(STAT.ATTACK_RANGE, 800)
		];

		this.BulletType = 'BulletBubbleRocket';

		// this.Description = 'ITEM.ROCKET_LAUNCHER.SPARK.DESCRIPTION';
		// this.Lore = "ITEM_BUBBLE_TERMINATOR_LORE";
	
		this.Model = new ModelCannonBase('model.item.cannonBase');

		this.onUseKnockBack = 3;
		this.shootBeforeCharge = false;
		this.requiredMP = 30;
		this.ammoCost = 15;

		this.chargeBullets = 3;
		this.canIncreaseChargeBulletCount = true;

		this.Charged = 
		{
			// damage: {min: 1, max: 33},
			AD: 30,
			criticalChance: 0,
			criticalDamage: 0,
			element: ELEMENT.PHYSICAL
		};
	}

	onSpecialCharge()
	{
		this.nextShootData.BulletType = 'BulletRocketSmoke';
	}

	GetBulletDamageInfo(owner = this.Owner)
    {
		if(!this.isChargedShot) return super.GetBulletDamageInfo(owner);
		return this.Charged;
    }
}
ItemHelper.InitializeItem(RocketLauncher1);





















class SparkRocketLauncher extends ItemWeapon
{
	constructor()
	{
		super(true);

		this.type = TYPE.CANNON;
		
		this.Texture = "ShadowScythe";
		this.name = 'ITEM.ROCKET_LAUNCHER.SPARK.NAME';
		this.enchantSlots = 2;


		this.primary = 
		[
			new ItemBonus(STAT.ATTACK_DAMAGE, 70),
			new ItemBonus(STAT.ATTACK_SPEED, 0.5),
			new ItemBonus(STAT.ATTACK_RANGE, 800)
		];

		// this.Description = 'ITEM.ROCKET_LAUNCHER.SPARK.DESCRIPTION';
		// this.Lore = "ITEM_BUBBLE_TERMINATOR_LORE";
	
		this.Model = new ModelCannonBase('model.item.cannonBase');

		this.onUseKnockBack = 3;
		this.shootBeforeCharge = false;
		this.requiredMP = 40;
		this.ammoCost = 50;

		this.Charged = 
		{
			// damage: {min: 1, max: 33},
			AD: 33,
			criticalChance: 0,
			criticalDamage: 0,
			element: ELEMENT.THUNDER
		};
	}

	onSpecialCharge()
	{
		this.nextShootData.BulletType = 'BulletRocketSpark';
	}

	GetBulletDamageInfo(owner = this.Owner)
    {
		if(!this.isChargedShot) return super.GetBulletDamageInfo(owner);
		return this.Charged;
    }
}
ItemHelper.InitializeItem(SparkRocketLauncher);class Special1 extends ItemSpecial
{
	constructor()
	{
		super();
		
		this.Texture = "ShadowScythe";
		this.name = "Special I";

		this.primary = 
		[
			new ItemBonus(STAT.ATTACK_DAMAGE, 100)
		];
		
		this.summoned = false;
		this.orbs = [];
		this.Radius = 150;
		this.orbsCount = 4;

		this.Lore = 'Summons 4 orbs to protect you.';
	}

	killOrbs()
	{
		for(var i = 0; i < this.orbs.length; i++)
		{
			this.orbs[i].Kill();
		}

		this.orbs = [];
	}

	onEquip()
	{
		this.killOrbs();
		this.summonOrbs();
	}

	onTakeOut()
	{
		this.killOrbs();
	}

	summonOrbs()
	{
		this.orbs = [];

		var radius = this.Radius;
		var angle = 0;
		var angleStep = 360 / this.orbsCount;

		for(var i = 0; i < this.orbsCount; i++)
		{
			var entity = new EntityBulletShield();
				entity.AI.Apply(new AI_OrbitAround(World.Player, 90, radius, angle));

			this.orbs.push(entity);
			World.AddEntity(entity);

			angle += angleStep;
		}

		this.summoned = true;
	}

	onEquipTick()
	{
		if(!this.summoned) this.summonOrbs();
	}
}
ItemHelper.InitializeItem(Special1);class SummonScroll extends Item
{
	constructor(bossName)
	{
		super();

		this.stackAble = true;
		this.maxStackSize = 999;
		this.upgradeAble = false;
		this.enchantAble = false;

		this.Texture = 'item.summon_scroll';
        this.name = "ITEM.SUMMON_SCROLL.NAME";

        this.canBeSold = false;
        this.Grade = GRADE.MYTHICAL;
        this.showGrade = false;

		
        this.Description = 'ITEM.SUMMON_SCROLL.DESCRIPTION';
		this.BossName = bossName;
		this.ARGS = {};
	}

    getDisplayName()
    {
        this.ARGS.BOSS_NAME = Lang.Get(this.BossName);

        return super.getDisplayName();
    }

	onUse(player)
	{
        if(World.Location.constructor.name != 'BossArena') return;

		this.count--;

		if(this.count <= 0)
		{
			var index = player.inventory.indexOf(this);
			if(index > -1)
			{
				player.inventory[index] = null;
			}
		}

        Summon(this.GetBoss());
        Save();
	}
}




class SummonScrollOxyCell extends SummonScroll
{
	constructor()
	{
		super('ENTITY.OXY_CELL.NAME');
	}

    GetBoss()
    {
        return OxyCell;
    }
}
ItemHelper.InitializeItem(SummonScrollOxyCell);


class SummonScrollTrimago extends SummonScroll
{
	constructor()
	{
		super('ENTITY.TRIMAGO.NAME');
	}

    GetBoss()
    {
        return Trimago;
    }
}
ItemHelper.InitializeItem(SummonScrollTrimago);


class SummonScrollTheFatOne extends SummonScroll
{
	constructor()
	{
		super('ENTITY.THE_FAT_ONE.NAME');
	}

    GetBoss()
    {
        return TheFatOne;
    }
}
ItemHelper.InitializeItem(SummonScrollTheFatOne);


class SummonScrollWaterfly extends SummonScroll
{
	constructor()
	{
		super('ENTITY.WATERFLY.NAME');
	}

    GetBoss()
    {
        return Waterfly;
    }
}
ItemHelper.InitializeItem(SummonScrollWaterfly);


class SummonScrollBubblebee extends SummonScroll
{
	constructor()
	{
		super('ENTITY.BUBBLEBEE.NAME');
	}

    GetBoss()
    {
        return Bubblebee;
    }
}
ItemHelper.InitializeItem(SummonScrollBubblebee);


class SummonScrollFrogo extends SummonScroll
{
	constructor()
	{
		super('ENTITY.FROGO.NAME');
	}

    GetBoss()
    {
        return Frogo;
    }
}
ItemHelper.InitializeItem(SummonScrollFrogo);

class SummonScrollLakeSpiderQueen extends SummonScroll
{
	constructor()
	{
		super('ENTITY.SPIDER.LAKE.QUEEN.NAME');
	}

    GetBoss()
    {
        return LakeSpiderQueen;
    }
}
ItemHelper.InitializeItem(SummonScrollLakeSpiderQueen);




class SummonScrollCelltipede extends SummonScroll
{
	constructor()
	{
		super('ENTITY.CELLTIPEDE.NAME');
	}

    GetBoss()
    {
        return Celltipede;
    }
}
ItemHelper.InitializeItem(SummonScrollCelltipede);



class SummonScrollTheCoveGuardian extends SummonScroll
{
	constructor()
	{
		super('ENTITY.THE_COVE_GUARDIAN.NAME');
	}

    GetBoss()
    {
        return TheCoveGuardian;
    }
}
ItemHelper.InitializeItem(SummonScrollTheCoveGuardian);





class WaterTwister extends ItemSpecial
{
	constructor()
	{
		super();
		
        this.type = TYPE.SPACE_KEY;
        this.restrictTypes = 1;

		this.Texture = "item.water_twister";
		this.name = "ITEM.WATER_TWISTER.NAME";

        this.DMG = 10;
        this.Duration = 10 * Main.FPS;
        this.Cooltime = 15 * Main.FPS;

		this.primary = 
		[
            new ItemBonus(STAT.SUMMON_DAMAGE, this.DMG),
			new ItemBonus(STAT.DURATION, this.Duration),
			new ItemBonus(STAT.COOLTIME, this.Cooltime)
		];

		this.Description ='ITEM.WATER_TWISTER.DESCRIPTION';

        this.lastSummon = -this.Cooltime;


        this.SlowStrength = 30;
        this.SlowDuration = 10;

        this.ARGS = {SLOW_S: this.SlowStrength, SLOW_D: this.SlowDuration};
	}

    canSummon(owner)
    {
        if(this.lastSummon + this.Cooltime > Main.ageInTicks) return false;
        if(!owner.allowControl) return false;
        if(!owner.allowMove) return false;
        if(owner.canInteractWith.length) return false;     //disable flash when player can interact
        if(!Settings.Controls.StateUseItemSkill) return false;

        return true;
    }

    Summon(owner)
    {
        this.lastSummon = Main.ageInTicks;

		var angle = MathHelper.getAngle2([owner.x, owner.y], [Mouse.x + Camera.xView, Mouse.y + Camera.yView]);
		var distance = MathHelper.GetDistance([owner.x - Camera.xView, owner.y- Camera.yView], [Mouse.x, Mouse.y]);
        var target = MathHelper.lineToAngle([owner.x, owner.y], distance, angle);

        var stats = {};
            stats.damage = this.DMG;
            stats.Texture = 'projectile.water_twister.2';
            stats.timeToDespawn = this.Duration;
            stats.SlowDuration = this.SlowDuration;
            stats.SlowStrength = this.SlowStrength;
        
        var bullet = new BulletWaterTwister(owner.x, owner.y, stats);
            bullet.Shoot(owner, target);
            
        World.AddProjectile(bullet);
    }

    getDescription()
    {
        var k = Settings.Controls.UseItemSkill;
        this.ARGS.KEY = (k==' ') ? Lang.Get('KEY.SPACE') : k;
        return super.getDescription();
    }

	onEquipTick(owner)
	{
		if(this.canSummon(owner)) this.Summon(owner);
        if(owner == World.Player) this.UpdateCoolTime(owner);
	}

    UpdateCoolTime(owner)
    {
        var required = this.Cooltime;
		var current = Main.ageInTicks - (this.lastSummon);
		
		owner.UpdateCooltime('ITEM_WATER_TWISTER', current, required);
    }
}
ItemHelper.InitializeItem(WaterTwister);class StarterBag extends ItemBag
{
	constructor()
	{
		super('ITEM.BAG.STARTER.NAME');
		this.Texture = 'item.treasure_orb.lake';

		this.Items = 
		[
			new LootTableItemData('LiquidOxygen', 100, 10, 10),
			new LootTableItemData('EssenceGrade0', 100, 4, 4),
			new LootTableItemData('ConcentratedBossAura', 100, 1, 1)
			,new LootTableItemData('DevBag', 100, 1, 1)
		];

		// this.Texture = "ShadowScythe";
	}
}
ItemHelper.InitializeItem(StarterBag);



class DevBag extends ItemBag
{
	constructor()
	{
		super('ITEM.BAG.DEV.NAME');
		this.Texture = 'item.treasure_orb.lake';

		this.Items = 
		[
			new LootTableItemData('LiquidOxygen', 100, 999, 999),
			new LootTableItemData('RandomAppearanceBox', 100, 1, 1),
			new LootTableItemData('RandomAppearanceBox', 100, 1, 1),
			new LootTableItemData('RandomAppearanceBox', 100, 1, 1),
			new LootTableItemData('RandomAppearanceBox', 100, 1, 1),
			new LootTableItemData('BlessingGrade', 100, 99, 99),
			new LootTableItemData('BlessingGrade1', 100, 99, 99),
			new LootTableItemData('BlessingGrade2', 100, 99, 99),
			new LootTableItemData('BlessingGrade3', 100, 99, 99),
			new LootTableItemData('BlessingGrade4', 100, 99, 99),
			new LootTableItemData('BlessingGrade5', 100, 99, 99),
			new LootTableItemData('BlessingGrade6', 100, 99, 99),
			new LootTableItemData('EssenceGradeExtractorPermanent', 100, 1, 1),

			new LootTableItemData('SummonScrollOxyCell', 100, 99, 99),
			new LootTableItemData('SummonScrollTrimago', 100, 99, 99),
			new LootTableItemData('SummonScrollFrogo', 100, 99, 99),
			new LootTableItemData('SummonScrollAquamantula', 100, 99, 99),
			new LootTableItemData('SummonScrollCelltipede', 100, 99, 99),

			new LootTableItemData('TheVirtuoso', 100, 1, 1),
			new LootTableItemData('BubbleTerminator', 100, 1, 1),
			new LootTableItemData('RocketLauncher0', 100, 1, 1),
			new LootTableItemData('HolyLauncher', 100, 1, 1),
			new LootTableItemData('InfinityStoneOfSpace', 100, 1, 1)
		];

		// this.Texture = "ShadowScythe";
	}
}
ItemHelper.InitializeItem(DevBag);








class TreasureOrbOxyCell extends ItemBag
{
	constructor()
	{
		super('ITEM.BAG.OXY_CELL.NAME');
		this.Texture = 'item.treasure_orb.lake';

		this.Items = 
		[
			// new LootTableItemData('HolyStoneBullet1', 25, 1, 1),
			// new LootTableItemData('MachineGunBase', 25, 1, 1),
			new LootTableItemData('LiquidOxygen', 100, 1, 3),
			new LootTableItemData('SummonScrollOxyCell', 25, 1, 1),
			new LootTableItemData('ConcentratedBossAura', 5, 1, 1)
		];
	}
}
ItemHelper.InitializeItem(TreasureOrbOxyCell);

class TreasureOrbTrimago extends ItemBag
{
	constructor()
	{
		super('ITEM.BAG.TRIMAGO.NAME');
		this.Texture = 'item.treasure_orb.lake';

		this.Items = 
		[
			new LootTableItemData('HolyStoneRange1', 25, 1, 1),
			
			new LootTableItemData('LiquidOxygen', 100, 1, 5),
			new LootTableItemData('SummonScrollTrimago', 25, 1, 1),
			new LootTableItemData('ConcentratedBossAura', 5, 1, 1)
		];
	}
}
ItemHelper.InitializeItem(TreasureOrbTrimago);


class TreasureOrbTheFatOne extends ItemBag
{
	constructor()
	{
		super('ITEM.BAG.THE_FAT_ONE.NAME');
		this.Texture = 'item.treasure_orb.lake';

		this.Items = 
		[
			new LootTableItemData('HolyStoneBullet1', 25, 1, 1),
			
			new LootTableItemData('LiquidOxygen', 100, 2, 6),
			new LootTableItemData('SummonScrollTheFatOne', 25, 1, 1),
			new LootTableItemData('ConcentratedBossAura', 5, 1, 1)
		];
	}
}
ItemHelper.InitializeItem(TreasureOrbTheFatOne);




class TreasureOrbWaterfly extends ItemBag
{
	constructor()
	{
		super('ITEM.BAG.WATERFLY.NAME');
		this.Texture = 'item.treasure_orb.lake';

		this.Items = 
		[
			new LootTableItemData('HolyStoneAS1', 25, 1, 1),
			new LootTableItemData('WaterTwister', 25, 1, 1),

			new LootTableItemData('LiquidOxygen', 100, 2, 6),
			new LootTableItemData('SummonScrollWaterfly', 25, 1, 1),
			new LootTableItemData('ConcentratedBossAura', 5, 1, 1)
		];
	}
}
ItemHelper.InitializeItem(TreasureOrbWaterfly);





class TreasureOrbFrogo extends ItemBag
{
	constructor()
	{
		super('ITEM.BAG.FROGO.NAME');
		this.Texture = 'item.treasure_orb.lake';

		this.Items = 
		[
			// new LootTableItemData('HolyStoneBullet1', 25, 1, 1),
			// new LootTableItemData('MachineGunBase', 25, 1, 1),
			new LootTableItemData('LiquidOxygen', 100, 2, 7),
			new LootTableItemData('ItemPetFrogo', 25, 1, 1),
			new LootTableItemData('SummonScrollFrogo', 25, 1, 1),
			new LootTableItemData('ConcentratedBossAura', 5, 1, 1)
		];
	}
}
ItemHelper.InitializeItem(TreasureOrbFrogo);

class TreasureOrbAquamantula extends ItemBag
{
	constructor()
	{
		super('ITEM.BAG.AQUAMANTULA.NAME');
		this.Texture = 'item.treasure_orb.lake';

		this.Items = 
		[
			new LootTableItemData('LiquidOxygen', 100, 3, 9),
			new LootTableItemData('SummonScrollLakeSpiderQueen', 25, 1, 1),
			new LootTableItemData('ConcentratedBossAura', 5, 1, 1)
		];
	}
}
ItemHelper.InitializeItem(TreasureOrbAquamantula);


class TreasureOrbCelltipede extends ItemBag
{
	constructor()
	{
		super('ITEM.BAG.CELLTIPEDE.NAME');
		this.Texture = 'item.treasure_orb.lake';

		this.Items = 
		[
			// new LootTableItemData('HolyStoneBullet1', 25, 1, 1),
			// new LootTableItemData('MachineGunBase', 25, 1, 1),
			new LootTableItemData('LiquidOxygen', 100, 5, 10),
			new LootTableItemData('SummonScrollCelltipede', 25, 1, 1),
			new LootTableItemData('ConcentratedBossAura', 5, 1, 1)
		];
	}
}
ItemHelper.InitializeItem(TreasureOrbCelltipede);




class StylesTest
{
	static Get()
	{
		var styles =
		{
			Default:
			{
				fontSize: 18,
				fontSizeType: "px",
				textAlign: "left",
				verticalAlign: 10,
				color: "white",
				textMargin: 5,
				strokeSize: 3,
				strokeColor: "black",
				fontWeight: "italic",
				fontFamily: "Helvetica"
			},
			
			LargeButton:
			{
				color: "white",
				fontSize: 60,
				textAlign: "center",
				backgroundColor: "rgba(0, 0, 0, 0)",
				width: 250,
				height: 70,
				strokeColor: "black",
				strokeSize: 5,
				
				States:
				{
					Hover:
					{
						fontSize: 70
					}
				}
			},

			ingameButton:
			{
				width: 45,
				height: 45,
				borderColor: 'lightgray',
				borderRadius: 10,
				borderSize: 2,

				States:
				{
					Hover:
					{
						borderColor: 'white'
					}
				}
			},

			OptionsButton:
			{
				color: "white",
				fontSize: 25,
				textAlign: "center",
				backgroundColor: "rgba(0, 0, 0, 0)",
				width: 100,
				height: 50,
				strokeColor: "black",
				strokeSize: 2,
				
				States:
				{
					Hover:
					{
						fontSize: 30
					},

					Disabled: 
					{
						color: 'rgba(255, 255, 255, 0.5',
						strokeColor: 'rgba(0, 0, 0, 0.5'
					}
				}
			},

			RunInfoClose:
			{
				color: 'lightblue',
				fontSize: 30,
				strokeSize: 3,
				strokeColor: '#569af3',
				textAlign: 'center',
				width: 30,
				height: 30,
				backgroundColor: 'rgba(0, 0, 0, 0)',

				States:
				{
					Hover:
					{
						fontSize: 40
					}
				}
			},

			OptionsControlsButton:
			{
				color: "lightgray",
				fontSize: 20,
				textAlign: "center",
				backgroundColor: "rgba(255, 255, 255, 0.1)",
				borderRadius: 5,
				width: 100,
				height: 30,
				strokeColor: "black",
				strokeSize: 2,
				
				States:
				{
					Hover:
					{
						color: "white"
					}
				}
			},

			small_button:
			{
				color: "black",
				fontSize: 4,
				fontSizeType: "%",
				fontStyle: "Comic Sans MS",
				backgroundColor: "lightgray",
				borderSize: 2,
				borderColor: "black",
				width: 120,
				height: 30,
				
				States:
				{
					Hover:
					{
						color: "black",
						fontSize: 4,
						fontSizeType: "%",
						fontStyle: "Comic Sans MS",
						backgroundColor: "lightblue",
						borderSize: 2,
						borderColor: "black"
					},
					
					Disabled:
					{
						color: "gray",
						fontSize: 4,
						fontSizeType: "%",
						fontStyle: "Comic Sans MS",
						backgroundColor: "lightgray",
						borderSize: 2,
						borderColor: "gray"
					}
				}
			},
			
			barHP:
			{
				color: "white",
				fontSize: 15,
				fontSizeType: "px",
				width: 200,
				height: 15,
				fontStyle: "Nova Square",
				backgroundColor: "rgba(0, 0, 0, 0)",
				borderRadius: 20,

				borderSize: 3,
				progressDisplay: "n",
				strokeSize: 2,
				strokeColor: "black",
				fontWeight: "italic",
				verticalAlign: 0,
				progressImage: "bar_hp",
				borderColor: "white",
				Animation: new AnimationInfo( 
					{
						Frames: 6,
						LoopMode: LOOP.CONTINUE,
						FrameDelay: 5
					}
				)
			},
			
			barShield:
			{
				color: "white",
				fontSize: 15,
				fontSizeType: "px",
				width: 200,
				height: 15,
				fontStyle: "Nova Square",
				backgroundColor: "rgba(0, 0, 0, 0)",
				borderRadius: 20,

				borderSize: 3,
				progressDisplay: "none",
				strokeSize: 2,
				strokeColor: "black",
				fontWeight: "italic",
				verticalAlign: 0,
				progressBar: "rgba(200, 200, 200, 1)",
				borderColor: "white"
			},
			
			barMP:
			{
				color: "white",
				fontSize: 15,
				fontSizeType: "px",
				width: 180,
				height: 10,
				fontStyle: "Nova Square",
				backgroundColor: "rgba(0, 0, 0, 0)",
				borderRadius: 20,

				borderSize: 2,
				progressDisplay: "none",
				strokeSize: 2,
				strokeColor: "black",
				fontWeight: "italic",
				verticalAlign: 0,
				progressImage: "bar_exp",
				borderColor: "white",
				Animation: new AnimationInfo( 
					{
						Frames: 6,
						LoopMode: LOOP.CONTINUE,
						FrameDelay: 5
					}
				)
			},
			
			stage:
			{
				color: "white",
				fontSize: 120,
				verticalAlign: "center",
				fontSizeType: "px",
				strokeSize: 2,
				strokeColor: "black",
				fontWeight: "italic"
			},

			WorldMapSwitch:
			{
				color: "#374850",
				fontSize: 30,
				verticalAlign: "center",
				fontSizeType: "px",
				fontStyle: "Comic Sans MS",
				strokeSize: 15,
				strokeColor: "#183355",
				fontWeight: "italic",
				width: 30,
				height: 50,
				backgroundColor: "rgba(0, 0, 0, 0)",

				States:
				{
					Hover:
					{
						fontSize: 35,
						strokeSize: 15,
						strokeColor: "#3b6cad",
						color: "#7998a3"
					},
					Disabled: 
					{
						strokeColor: "#569af3",
						color: "#abd6e6"
					}
				}
			},
			
			menu:
			{
				color: "lightblue",
				fontSize: 120,
				verticalAlign: "center",
				fontSizeType: "px",
				fontStyle: "Comic Sans MS",
				strokeSize: 15,
				strokeColor: "#569af3",
				fontWeight: "italic"
			},

			menu_subtitle:
			{
				color: "lightblue",
				fontSize: 30,
				verticalAlign: "center",
				fontSizeType: "px",
				fontStyle: "Comic Sans MS",
				strokeSize: 15,
				strokeColor: "#569af3",
				fontWeight: "italic"
			},


			SettingsSlider:
			{
				width: 200,
				height: 20,
				backgroundColor: "rgba(0, 0, 0, 0)",
				borderColor: "rgba(255, 255, 255, 0.7)",
				borderRadius: 5,

				sliderPointer:
				{
					width: 5,
					height: 20,
					backgroundColor: "rgba(255, 255, 255, 0.7)",
					borderColor: "rgba(255, 255, 255, 0.7)",
					borderRadius: 5
				}
			},

			OptionsCheckbox:
			{
				width: 20,
				height: 20,
				borderSize: 3,
				borderRadius: 10,
				borderColor: 'white'
			},

			MenuInfo:
			{
				color: "white",
				fontSize: 15,
				textAlign: "left",
				backgroundColor: "rgba(0, 0, 0, 0)",
				width: 0,
				height: 20,
				strokeColor: "black",
				strokeSize: 2
			},
			
			bossHP:
			{
				color: "lightblue",
				fontSize: 15,
				fontSizeType: "px",
				width: 0,
				height: 15,
				fontStyle: "Comic Sans MS",
				backgroundColor: "rgba(0, 0, 0, 0)",
				borderRadius: 20,
				textAlign: "left",

				borderSize: 5,
				progressDisplay: "none",
				strokeSize: 15,
				strokeColor: "#bc5fff",
				fontWeight: "italic",
				verticalAlign: -15,
				progressImage: "bar_boss_hp",
				borderColor: "lightblue",
				Animation: new AnimationInfo( 
					{
						Frames: 6,
						LoopMode: LOOP.CONTINUE,
						FrameDelay: 5
					}
				)
			},
			
			barEXP:
			{
				color: "white",
				fontSize: 15,
				fontSizeType: "px",
				width: 0,
				height: 10,
				fontStyle: "Nova Square",
				backgroundColor: "rgba(0, 0, 0, 0)",
				borderRadius: 20,

				borderSize: 5,
				progressDisplay: "none",
				strokeSize: 2,
				strokeColor: "black",
				fontWeight: "italic",
				verticalAlign: 0,
				progressImage: "bar_mp",
				borderColor: "white",
				Animation: new AnimationInfo( 
					{
						Frames: 6,
						LoopMode: LOOP.CONTINUE,
						FrameDelay: 5
					}
				)
			},

			barLoading:
			{
				color: "white",
				fontSize: 20,
				fontSizeType: "px",
				width: 0,
				height: 30,
				fontStyle: "Nova Square",
				backgroundColor: "rgba(0, 0, 0, 0)",
				borderRadius: 30,

				borderSize: 5,
				progressDisplay: "%",
				strokeSize: 2,
				strokeColor: "black",
				fontWeight: "bold",
				verticalAlign: 0,
				progressBar: "lightblue",
				borderColor: "white"
			},
			
			inventory_slot_switch_button:
			{
				width: 49,
				height: 20,
				fontSizeType: "px",
				textAlign: "center",
				color: "lightgray",
				backgroundColor: "#909090",
				fontWeight: "bold",
				
				States:
				{
					Hover:
					{
						backgroundColor: "#b3b3b3"
					},
					
					Disabled:
					{
						backgroundColor: "#696969"
					}
				}
			},
			
			inventory_slot:
			{
				width: 50,
				height: 50,
				fontSize: 15,
				fontSizeType: "px",
				textAlign: "right",
				color: "white",
				backgroundImage: "inventory_slot",
				verticalAlign: 30,
				textMargin: 5,
				strokeSize: 3,
				strokeColor: "black",
				fontWeight: "italic",
				
				States:
				{
					Hover:
					{
						backgroundImage: "inventory_slot_hover"
					},
					Disabled:
					{
						backgroundImage: "inventory_slot_locked"
					}
				}
			},

			SPbutton:
			{
				width: 20,
				height: 20,
				textAlign: "center",
				color: "white",
				backgroundColor: "rgba(0, 0, 0, 0)"
			},

			ItemInfoDisplay:
			{
				width: 45,
				height: 45,
				fontSize: 18,
				fontSizeType: "px",
				textAlign: "left",
				color: "white",
				verticalAlign: 10,
				textMargin: 5,
				strokeSize: 3,
				strokeColor: "black",
				fontWeight: "italic bold"
			}
		};
		
		return styles;
	}
}class Overworld extends Dimension
{
    constructor()
    {
        super();

        this.HexMap = [
            [false,false,false,false,false,false,true,false,false,false,false,false,false,false,false,false,false,false,true,true,true,false,false,false,false,false,false,false,false,false],
            [false,false,false,false,true,true,true,true,false,false,false,false,false,false,false,true,true,true,true,true,true,false,false,false,false,false,false,false,false,false],
            [true,true,true,false,true,true,true,false,false,false,false,false,false,false,true,true,true,true,true,true,false,false,false,false,false,false,false,false,false,false],
            [true,true,true,true,true,true,true,false,false,false,false,false,false,false,true,true,true,true,true,true,false,false,false,false,false,false,true,true,false,false],
            [true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,false,false,false,false,true,true,true,false,false],
            [false,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,false,false,true,true,true,true,false,false],
            [false,false,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,false,false],
            [false,false,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,false,false,false],
            [false,false,false,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,false,false,false],
            [false,false,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,false,false,false,false],
            [false,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,false,false,false,false],
            [false,false,false,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,false,false,false,false,false],
            [false,false,false,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,false,false,false,false,false,false],
            [false,false,false,true,true,true,true,true,true,true,false,true,true,true,false,true,true,true,true,true,true,true,true,true,false,false,false,false,false,false],
            [false,false,false,true,true,true,true,true,true,true,false,false,false,false,false,false,true,true,true,true,true,true,true,false,false,false,false,false,false,false],
            [false,false,true,true,true,true,true,false,false,false,false,false,false,false,false,false,true,true,true,true,true,false,false,false,false,false,false,false,false,false],
            [false,true,true,true,true,true,false,false,false,false,false,false,false,false,false,true,true,true,true,true,false,false,false,false,false,false,false,false,false,false],
            [false,true,true,true,true,true,false,false,false,false,false,false,false,false,false,true,true,true,true,true,false,false,false,false,false,false,false,false,false,false],
            [false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false],
            [false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false]
        ];
        
        // this.Points = [
        //     new HexMapPoint(1, 3, 'VILLAGE')
        // ];
    }
}
World.InitializeDimension(Overworld);class BossArena extends Location
{
	constructor()
	{
		super();
		this.Name = "LOCATION.BOSS_ARENA.NAME";
		this.Texture = 'location.boss_arena.room';
		this.TextureAlpha = .5;
		// this.TunnelTexture = 'effect.honey_bubble';
		this.TextureScale = 1.145;

		this.Radius = 1500;
		this.BackgroundTheme = "world.boss_arena";

		this.nextLocation = null;
		this.prevLocation = null;


		this.LocationFamily = '';
		this.allowMap = false;
		

		this.RoomInfo =
		{
			MinRooms: 1,
			MaxRooms: 1,
			EntityTypes: [
	
			],
			MaxEntityTypes: 0,
			BossTypes: [],
			MinEntities: 0,
			MaxEntities: 0,
			MinRadius: this.Radius,
			MaxRadius: this.Radius,
			BossChambers: 0,
			SecretChambers: 0,
			Titles:
			{
			},
			Subtitles:
			{
			},
			onUpdates:
			{
				Start: null,
				Boss: null,
				Secret: null,
				Room: null
			}
		};

		this.summonRotation = 0;
		this.summonTick = 0;
	}

	RenderGradient()
	{
		// var pos = World.GetBackgroundPosition();

		// var grd = ctx.createLinearGradient(pos.x, pos.y, 0, World.Height);
		// 	grd.addColorStop(0, "#C66C00");
		// 	grd.addColorStop(0.5, "#6D3900");
		// 	grd.addColorStop(1, "black");

		// ctx.save();
		// ctx.fillStyle = grd;
		// ctx.fillRect(-Camera.xView, -Camera.yView, World.Width, World.Height);
		// ctx.restore();

		ctx.save();
		ctx.fillStyle = '#110000';
		ctx.fillRect(0, 0, canvas.width, canvas.height);
		ctx.restore();
	}

	RenderRoom()
	{
		super.RenderRoom();


		if(World.Boss && isFunction(World.Boss.onBossRender))
		{
			this.summonTick = 120;
		}
		else
		{
			this.summonTick--;
		}


		if(this.summonTick >= 0)
		{
			var size = 512;
			var scale = 2;
			var alpha = this.summonTick / 120;
			this.summonRotation+= 2;
			Graphic.DrawRotatedImage(ctx, TextureManager.Get('location.boss_arena.summon_circle'), 
				World.CenterPoint.x - Camera.xView, World.CenterPoint.y - Camera.yView, size, size, scale, this.summonRotation, alpha);
		}
	}
	
	Update()
	{
		super.Update();
	}
	
	onLoad()
	{
		this.DefaultLocationLoad();

		
	}
}
World.InitializeLocation(BossArena);class Carthage extends Location
{
	constructor()
	{
		super();
		this.Stage = 0;
		this.Radius = 1000;
		this.Title = "Welcome to Bubble Wars!";
		this.Subtitle = "Use WSAD to move";
		this.Name = "Carthage";
		this.triggerPoints = [];
		this.ageInTicks = 0;


		// this.MapPos = {x: 20, y: 20};
		// this.reqPrevLocation = "Village";



		this.CenterPoint = {x: 0, y: 0};
		this.BackgroundTheme = "interface.InGameCalm";
		this.Room = 0;
		this.Rooms = [];

		this.nextLocation = null;
		this.prevLocation = "TestingChamber";

		this.RoomInfo =
		{
			// MinRooms: 5,
			// MaxRooms: 10,
			MinRooms: 100,
			MaxRooms: 100,
			EntityTypes: [
				// "EntityBubble",
				"EntitySpikeBall"
			],
			MaxEntityTypes: 2,
			BossTypes: [
				"TheFatOne",
				"SpikySniper"
			],
			MinEntities: 5,
			MaxEntities: 15,
			MinRadius: 600,
			MaxRadius: 1200,
			BossChambers: 5,
			SecretChambers: 5,
			Titles:
			{
				Start: "Welcome to Bubble Wars!",
				Boss: "",
				Secret: "Secret Room",
				Room: ""
			},
			Subtitles:
			{
				Start: "Use WSAD to move",
				Boss: "",
				Secret: "",
				Room: ""
			},
			onUpdates:
			{
				Start: null,
				Boss: null,
				Secret: null,
				Room: null
			}
		};
	}
	
	Update()
	{
		super.Update();
	}
	
	onLoad()
	{
		World.MinimalDeep = 0;
		this.DefaultLocationLoad();
	}
}
World.InitializeLocation(Carthage);class Cavern1 extends Location
{
	constructor()
	{
		super();
		this.Name = "LOCATION.CAVERN.1.NAME";

        this.lightLevel = .1;
        this.specialIcon = 'cavern_entrance';
		this.LocationFamily = 'Cavern';


		this.MapPos = {x: 7, y: 1};
		this.reqPrevLocation = ["Cove1"];



		this.CenterPoint = {x: 0, y: 0};
		this.BackgroundTheme = "interface.InGameCalm";

		this.nextLocation = "Cavern2";
		this.prevLocation = "Cove1";

		this.RoomInfo =
		{
			MinRooms: 10,
			MaxRooms: 20,
			EntityTypes: [
				"EntityBat",
				"EntityFatBat",
				"EntityBlindBat"
			],
			MaxEntityTypes: 3,
			BossTypes: [
				"Zubath"
			],
			availableNPC:
			{
				Boss: null,
				Secret: {id: 'Miner', chance: 50},
				Start: null,
				Room: null,
			},
			MinEntities: 5,
			MaxEntities: 15,
			MinRadius: 1000,
			MaxRadius: 1500,
			BossChambers: 3,
			SecretChambers: 3,
			Titles:
			{
				Start: "",
				Boss: "",
				Secret: "Secret Room",
				Room: ""
			},
			Subtitles:
			{
				Start: "",
				Boss: "",
				Secret: "",
				Room: ""
			},
			onUpdates:
			{
				Start: null,
				Boss: null,
				Secret: null,
				Room: null
			}
		};
	}
	
	Update()
	{
		super.Update();
	}
	
	onLoad()
	{
		World.MinimalDeep = 0;
		this.DefaultLocationLoad();
	}
}
World.InitializeLocation(Cavern1);class Cavern2 extends Cavern1
{
	constructor()
	{
		super();
		this.Name = "LOCATION.CAVERN.2.NAME";
        this.specialIcon = false;



		// this.MapPos = {x: 9, y: 2};
		this.reqPrevLocation = ["Cavern1"];


		this.BackgroundTheme = "interface.InGameCalm";

		this.nextLocation = "Cavern3";
		this.prevLocation = "Cavern1";

		this.RoomInfo =
		{
			MinRooms: 20,
			MaxRooms: 30,
			EntityTypes: [
				// "EntityBubble"
			],
			MaxEntityTypes: 1,
			BossTypes: [
				"TheFatOne"
			],
			MinEntities: 5,
			MaxEntities: 15,
			MinRadius: 600,
			MaxRadius: 1200,
			BossChambers: 1,
			SecretChambers: 0,
			Titles:
			{
				Start: "Welcome to Bubble Wars!",
				Boss: "",
				Secret: "Secret Room",
				Room: ""
			},
			Subtitles:
			{
				Start: "Use WSAD to move",
				Boss: "",
				Secret: "",
				Room: ""
			},
			onUpdates:
			{
				Start: null,
				Boss: null,
				Secret: null,
				Room: null
			}
		};
	}
	
	Update()
	{
		super.Update();
	}
	
	onLoad()
	{
		World.MinimalDeep = 0;
		this.DefaultLocationLoad();
	}
}
World.InitializeLocation(Cavern2);class Cavern3 extends Cavern2
{
	constructor()
	{
		super();
		this.Name = "LOCATION.CAVERN.3.NAME";
		


		this.MapPos = {x: 10, y: 0};
		this.reqPrevLocation = ["Cavern2"];



		this.BackgroundTheme = "interface.InGameCalm";

		this.nextLocation = "Cavern4";
		this.prevLocation = "Cavern2";

		this.RoomInfo =
		{
			MinRooms: 20,
			MaxRooms: 30,
			EntityTypes: [
				// "EntityBubble"
			],
			MaxEntityTypes: 1,
			BossTypes: [
				"TheFatOne"
			],
			MinEntities: 5,
			MaxEntities: 15,
			MinRadius: 600,
			MaxRadius: 1200,
			BossChambers: 1,
			SecretChambers: 0,
			Titles:
			{
				Start: "Welcome to Bubble Wars!",
				Boss: "",
				Secret: "Secret Room",
				Room: ""
			},
			Subtitles:
			{
				Start: "Use WSAD to move",
				Boss: "",
				Secret: "",
				Room: ""
			},
			onUpdates:
			{
				Start: null,
				Boss: null,
				Secret: null,
				Room: null
			}
		};
	}
	
	Update()
	{
		super.Update();
	}
	
	onLoad()
	{
		World.MinimalDeep = 0;
		this.DefaultLocationLoad();
	}
}
World.InitializeLocation(Cavern3);class Cavern4 extends Cavern2
{
	constructor()
	{
		super();
		this.Name = "LOCATION.CAVERN.4.NAME";



		this.MapPos = {x: 12, y: 2};
		this.reqPrevLocation = ["Cavern3"];


		this.BackgroundTheme = "interface.InGameCalm";

		this.nextLocation = "Cavern5";
		this.prevLocation = "Cavern3";

		this.RoomInfo =
		{
			MinRooms: 20,
			MaxRooms: 30,
			EntityTypes: [
				// "EntityBubble"
			],
			MaxEntityTypes: 1,
			BossTypes: [
				"TheFatOne"
			],
			MinEntities: 5,
			MaxEntities: 15,
			MinRadius: 600,
			MaxRadius: 1200,
			BossChambers: 1,
			SecretChambers: 0,
			Titles:
			{
				Start: "Welcome to Bubble Wars!",
				Boss: "",
				Secret: "Secret Room",
				Room: ""
			},
			Subtitles:
			{
				Start: "Use WSAD to move",
				Boss: "",
				Secret: "",
				Room: ""
			},
			onUpdates:
			{
				Start: null,
				Boss: null,
				Secret: null,
				Room: null
			}
		};
	}
	
	Update()
	{
		super.Update();
	}
	
	onLoad()
	{
		World.MinimalDeep = 0;
		this.DefaultLocationLoad();
	}
}
World.InitializeLocation(Cavern4);class Cavern5 extends Cavern2
{
	constructor()
	{
		super();
		this.Name = "LOCATION.CAVERN.5.NAME";
		


		this.MapPos = {x: 13, y: 1};
		this.reqPrevLocation = ["Cavern4"];


		this.BackgroundTheme = "interface.InGameCalm";

		this.nextLocation = "Cavern6";
		this.prevLocation = "Cavern4";

		this.RoomInfo =
		{
			MinRooms: 20,
			MaxRooms: 30,
			EntityTypes: [
				// "EntityBubble"
			],
			MaxEntityTypes: 1,
			BossTypes: [
				"TheFatOne"
			],
			MinEntities: 5,
			MaxEntities: 15,
			MinRadius: 600,
			MaxRadius: 1200,
			BossChambers: 1,
			SecretChambers: 0,
			Titles:
			{
				Start: "Welcome to Bubble Wars!",
				Boss: "",
				Secret: "Secret Room",
				Room: ""
			},
			Subtitles:
			{
				Start: "Use WSAD to move",
				Boss: "",
				Secret: "",
				Room: ""
			},
			onUpdates:
			{
				Start: null,
				Boss: null,
				Secret: null,
				Room: null
			}
		};
	}
	
	Update()
	{
		super.Update();
	}
	
	onLoad()
	{
		World.MinimalDeep = 0;
		this.DefaultLocationLoad();
	}
}
World.InitializeLocation(Cavern5);class Cavern6 extends Cavern1
{
	constructor()
	{
		super();
		this.Name = "LOCATION.CAVERN.6.NAME";
	


		this.MapPos = {x: 15, y: 1};
		this.reqPrevLocation = ["Cavern5"];


		this.BackgroundTheme = "interface.InGameCalm";


		this.nextLocation = "";
		this.prevLocation = "Cavern5";

		this.RoomInfo =
		{
			MinRooms: 20,
			MaxRooms: 30,
			EntityTypes: [
				// "EntityBubble"
			],
			MaxEntityTypes: 1,
			BossTypes: [
				"TheFatOne"
			],
			MinEntities: 5,
			MaxEntities: 15,
			MinRadius: 600,
			MaxRadius: 1200,
			BossChambers: 1,
			SecretChambers: 0,
			Titles:
			{
				Start: "Welcome to Bubble Wars!",
				Boss: "",
				Secret: "Secret Room",
				Room: ""
			},
			Subtitles:
			{
				Start: "Use WSAD to move",
				Boss: "",
				Secret: "",
				Room: ""
			},
			onUpdates:
			{
				Start: null,
				Boss: null,
				Secret: null,
				Room: null
			}
		};
	}
	
	Update()
	{
		super.Update();
	}
	
	onLoad()
	{
		World.MinimalDeep = 0;
		this.DefaultLocationLoad();
	}
}
World.InitializeLocation(Cavern6);class Cove1 extends Location
{
	constructor()
	{
		super();
		this.Name = "LOCATION.THE_COVE.NAME";
		this.triggerPoints = [];
		this.ageInTicks = 0;
		this.specialIcon = 'brook';
		
		this.LocationFamily = 'Cove';


		this.MapPos = {x: 5, y: 1};
		this.reqPrevLocation = ["Lake1"];


		this.BackgroundTheme = "interface.InGameCalm";

		this.nextLocation = "Cavern1";
		this.prevLocation = "Lake1";

		this.RoomInfo =
		{
			MinRooms: 20,
			MaxRooms: 30,
			EntityTypes: [
				"EntityCoveFishPoison",
				"EntityCoveFishIce",
				"EntityCoveFishFire"
			],
			MinEntityTypes: 3,
			MaxEntityTypes: 3,
			BossTypes: [
				"TheCoveGuardian"
			],
			MinEntities: 0,
			MaxEntities: 3,
			MinRadius: 900,
			MaxRadius: 1200,
			BossChambers: 1,
			SecretChambers: 0,
			Titles:
			{
				Start: "",
				Boss: "",
				Secret: "",
				Room: ""
			},
			Subtitles:
			{
				Start: "",
				Boss: "",
				Secret: "",
				Room: ""
			},
			onUpdates:
			{
				Start: null,
				Boss: null,
				Secret: null,
				Room: null
			}
		};
	}

	generateRandomRooms(RoomInfo, roomsNumber, min_empty)
	{
		var type1 = [
			['boss', 'room', 'room', 'room', 'room'],
			[null,   null,    null,   null,  'room'],
			['room', 'room',  true,   null,  'room'],
			['room', null,    null,   null,  'room'],
			['room', 'room', 'room', 'room', 'room']
		];

		var type2 = [
			['room', 'room', 'room', 'room', 'room'],
			['room',  null,   null,   null,  'room'],
			['room',  null,   true,  'room',  'room'],
			['room',  null,   null,   null,  null],
			['room', 'room', 'room', 'room', 'boss']
		];

		var types = [type1, type2];

		var rooms = types[MathHelper.randomInRange(0, 1)];
		return {rooms: rooms, startRoom: 12};
	}
	
	Update()
	{
		super.Update();
	}
	
	onLoad()
	{
		World.MinimalDeep = 0;
		this.DefaultLocationLoad();
	}
}
World.InitializeLocation(Cove1);class Lake1 extends Location
{
	constructor()
	{
		super();
		this.Name = "LOCATION.LAKE.1.NAME";
		this.LocationFamily = 'Lake';


		this.MapPos = {x: 4, y: 2};
		this.reqPrevLocation = ["Tutorial"];

		this.BackgroundTheme = "interface.InGameCalm";

		this.nextLocation = "Lake2";
		this.prevLocation = "Village";

		this.RoomInfo =
		{
			MinRooms: 6,
			MaxRooms: 10,
			EntityTypes: [
				"EntityBubble",
				"EntityBubbleFormation0",
				"EntityBubbleFormation2"
			],
			MaxEntityTypes: 3,
			BossTypes: [
				"OxyCell"
			],
			MinEntities: 10,
			MaxEntities: 15,
			MinRadius: 1000,
			MaxRadius: 1200,
			BossChambers: 2,
			SecretChambers: 0,
			Titles:
			{
				Start: "",
				Boss: "",
				Secret: "",
				Room: ""
			},
			Subtitles:
			{
				Start: "",
				Boss: "",
				Secret: "",
				Room: ""
			},
			onUpdates:
			{
				Start: null,
				Boss: null,
				Secret: null,
				Room: null
			}
		};
	}
	
	Update()
	{
		super.Update();
	}
	
	onLoad()
	{
		World.MinimalDeep = 0;
		this.DefaultLocationLoad();
	}
}
World.InitializeLocation(Lake1);class Lake2 extends Lake1
{
	constructor()
	{
		super();
		this.Name = "LOCATION.LAKE.2.NAME";

		this.MapPos = {x: 6, y: 3};
		this.reqPrevLocation = ["Lake1"];


		this.BackgroundTheme = "interface.InGameCalm";

		this.nextLocation = 'Lake3';
		this.prevLocation = "Lake1";

		this.RoomInfo =
		{
			MinRooms: 6,
			MaxRooms: 10,
			EntityTypes: [
				"EntityTrim",
				"EntityFatTrim",
				"EntityTrimFormation0"
			],
			MaxEntityTypes: 3,
			BossTypes: [
				"Trimago"
			],
			MinEntities: 5,
			MaxEntities: 15,
			MinRadius: 1000,
			MaxRadius: 1200,
			BossChambers: 2,
			SecretChambers: 0,
			Titles:
			{
				Start: "",
				Boss: "",
				Secret: "",
				Room: ""
			},
			Subtitles:
			{
				Start: "",
				Boss: "",
				Secret: "",
				Room: ""
			},
			onUpdates:
			{
				Start: null,
				Boss: null,
				Secret: null,
				Room: null
			}
		};
	}
	
	Update()
	{
		super.Update();
	}
	
	onLoad()
	{
		World.MinimalDeep = 0;
		this.DefaultLocationLoad();
	}
}
World.InitializeLocation(Lake2);class Lake3 extends Lake1
{
	constructor()
	{
		super();
		this.Name = "LOCATION.LAKE.3.NAME";

		this.MapPos = {x: 5, y: 5};
		this.reqPrevLocation = ["Lake2"];

		this.BackgroundTheme = "interface.InGameCalm";

		this.nextLocation = "Lake4";
		this.prevLocation = "Lake2";

		this.RoomInfo =
		{
			MinRooms: 10,
			MaxRooms: 12,
			EntityTypes: [
				"EntityBubbleFormation3",
				"EntityBubbleFormation4",
				"EntityBubbleFormation5"
			],
			MaxEntityTypes: 3,
			BossTypes: [
				"TheFatOne"
			],
			availableNPC:
			{
				Boss: {id: 'Stylist', chance: 100},
				Secret: null,
				Start: null,
				Room: null,
			},
			MinEntities: 5,
			MaxEntities: 15,
			MinRadius: 1000,
			MaxRadius: 1200,
			BossChambers: 1,
			SecretChambers: 0,
			Titles:
			{
				Start: "",
				Boss: "",
				Secret: "",
				Room: ""
			},
			Subtitles:
			{
				Start: "",
				Boss: "",
				Secret: "",
				Room: ""
			},
			onUpdates:
			{
				Start: null,
				Boss: null,
				Secret: null,
				Room: null
			}
		};
	}
	
	Update()
	{
		super.Update();
	}
	
	onLoad()
	{
		World.MinimalDeep = 0;
		this.DefaultLocationLoad();
	}
}
World.InitializeLocation(Lake3);class Lake4 extends Lake1
{
	constructor()
	{
		super();
		this.Name = "LOCATION.LAKE.4.NAME";

		// this.MapPos = {x: 5, y: 1};
		this.MapPos = {x: 7, y: 5};
		this.reqPrevLocation = ["Lake2"];



		this.BackgroundTheme = "interface.InGameCalm";

		this.nextLocation = "Lake5";
		this.prevLocation = "Lake3";

		this.RoomInfo =
		{
			MinRooms: 10,
			MaxRooms: 12,
			EntityTypes: [
				// "EntityBubble",
				// "EntityBubbleTank"
			],
			MaxEntityTypes: 2,
			BossTypes: [
				"Waterfly"
			],
			MinEntities: 5,
			MaxEntities: 15,
			MinRadius: 1000,
			MaxRadius: 1200,
			BossChambers: 1,
			SecretChambers: 0,
			Titles:
			{
				Start: "",
				Boss: "",
				Secret: "",
				Room: ""
			},
			Subtitles:
			{
				Start: "",
				Boss: "",
				Secret: "",
				Room: ""
			},
			onUpdates:
			{
				Start: null,
				Boss: null,
				Secret: null,
				Room: null
			}
		};
	}
	
	Update()
	{
		super.Update();
	}
	
	onLoad()
	{
		World.MinimalDeep = 0;
		this.DefaultLocationLoad();
	}
}
World.InitializeLocation(Lake4);class Lake5 extends Lake1
{
	constructor()
	{
		super();

		this.Name = "LOCATION.LAKE.5.NAME";

		// this.MapPos = {x: 5, y: 1};
		this.MapPos = {x: 6, y: 6};
		this.reqPrevLocation = ["Lake3", "Lake4"];

		this.BackgroundTheme = "interface.InGameCalm";
		
		this.nextLocation = "Lake6";
		this.prevLocation = "Lake4";

		this.RoomInfo =
		{
			MinRooms: 10,
			MaxRooms: 16,
			EntityTypes: [
				"EntityHoneyChunk",
				"EntityLakeLittleBee",
				"EntityLakeLargeBee"
			],
			MaxEntityTypes: 3,
			BossTypes: [
				"Bubblebee"
			],
			MinEntities: 10,
			MaxEntities: 20,
			MinRadius: 1000,
			MaxRadius: 1200,
			BossChambers: 3,
			SecretChambers: 0,
			Titles:
			{
				Start: "",
				Boss: "",
				Secret: "Secret Room",
				Room: ""
			},
			Subtitles:
			{
				Start: "",
				Boss: "",
				Secret: "",
				Room: ""
			},
			onUpdates:
			{
				Start: null,
				Boss: null,
				Secret: null,
				Room: null
			}
		};
	}
	
	Update()
	{
		super.Update();
	}
	
	onLoad()
	{
		World.MinimalDeep = 0;
		this.DefaultLocationLoad();
	}
}
World.InitializeLocation(Lake5);class Lake6 extends Lake1
{
	constructor()
	{
		super();
		this.Name = "LOCATION.LAKE.6.NAME";


		// this.MapPos = {x: 5, y: 1};
		this.MapPos = {x: 5, y: 8};
		this.reqPrevLocation = ["Lake5"];


		this.BackgroundTheme = "interface.InGameCalm";

		this.nextLocation = "Lake7";
		this.prevLocation = "Lake5";

		this.RoomInfo =
		{
			MinRooms: 10,
			MaxRooms: 13,
			EntityTypes: [
				"EntityLakeTadpole",
				"EntityLakeFrog",
				"EntityGreenLakeFrog"
			],
			MaxEntityTypes: 3,
			BossTypes: [
				"Frogo"
			],
			MinEntities: 8,
			MaxEntities: 16,
			MinRadius: 1000,
			MaxRadius: 1200,
			BossChambers: 2,
			SecretChambers: 0,
			Titles:
			{
				Start: "",
				Boss: "",
				Secret: "",
				Room: ""
			},
			Subtitles:
			{
				Start: "",
				Boss: "",
				Secret: "",
				Room: ""
			},
			onUpdates:
			{
				Start: null,
				Boss: null,
				Secret: null,
				Room: null
			}
		};
	}
	
	Update()
	{
		super.Update();
	}
	
	onLoad()
	{
		World.MinimalDeep = 0;
		this.DefaultLocationLoad();
	}
}
World.InitializeLocation(Lake6);class Lake7 extends Lake1
{
	constructor()
	{
		super();
		this.Name = "LOCATION.LAKE.7.NAME";


		// this.MapPos = {x: 5, y: 1};
		this.MapPos = {x: 3, y: 8};
		this.reqPrevLocation = ["Lake6"];


		this.BackgroundTheme = "interface.InGameCalm";


		this.nextLocation = "Lake8";
		this.prevLocation = "Lake6";

		this.RoomInfo =
		{
			MinRooms: 12,
			MaxRooms: 15,
			EntityTypes: [
				"EntityLittleLakeSpider",
				"EntityLakeSpider",
				"EntityDashingLakeSpider"
			],
			MaxEntityTypes: 3,
			BossTypes: [
				"LakeSpiderQueen"
			],
			MinEntities: 10,
			MaxEntities: 15,
			MinRadius: 1000,
			MaxRadius: 1400,
			BossChambers: 2,
			SecretChambers: 0,
			Titles:
			{
				Start: "",
				Boss: "",
				Secret: "",
				Room: ""
			},
			Subtitles:
			{
				Start: "",
				Boss: "",
				Secret: "",
				Room: ""
			},
			onUpdates:
			{
				Start: null,
				Boss: null,
				Secret: null,
				Room: null
			}
		};
	}
	
	Update()
	{
		super.Update();
	}
	
	onLoad()
	{
		World.MinimalDeep = 0;
		this.DefaultLocationLoad();
	}
}
World.InitializeLocation(Lake7);class Lake8 extends Lake1
{
	constructor()
	{
		super();
		this.Stage = 0;
		this.Radius = 1000;
		this.Title = "Welcome to Bubble Wars!";
		this.Subtitle = "Use WSAD to move";
		this.Name = "LOCATION.LAKE.8.NAME";
		this.triggerPoints = [];
		this.ageInTicks = 0;


		this.MapPos = {x: 2, y: 5};
		this.reqPrevLocation = ["Lake7"];



		this.CenterPoint = {x: 0, y: 0};
		this.BackgroundTheme = "interface.InGameCalm";
		this.Room = 0;
		this.Rooms = [];

		this.nextLocation = 'Village';
		this.prevLocation = "Lake7";

		this.RoomInfo =
		{
			MinRooms: 10,
			MaxRooms: 20,
			EntityTypes: [
				// "EntityBubble",
				// "EntityBubbleTank"
			],
			MaxEntityTypes: 2,
			BossTypes: [
				"Celltipede"
			],
			MinEntities: 5,
			MaxEntities: 15,
			MinRadius: 1000,
			// MinRadius: 1200,
			MaxRadius: 1200,
			BossChambers: 1,
			SecretChambers: 0,
			Titles:
			{
				Start: "",
				Boss: "",
				Secret: "Secret Room",
				Room: ""
			},
			Subtitles:
			{
				Start: "",
				Boss: "",
				Secret: "",
				Room: ""
			},
			onUpdates:
			{
				Start: null,
				Boss: null,
				Secret: null,
				Room: null
			}
		};
	}
	
	Update()
	{
		super.Update();
	}
	
	onLoad()
	{
		World.MinimalDeep = 0;
		this.DefaultLocationLoad();
	}
}
World.InitializeLocation(Lake8);class Lake9 extends Lake1
{
	constructor()
	{
		super();
		this.Name = "LOCATION.BEEHIVE.NAME";
		this.Texture = 'location.beehive.room';
		this.TextureAlpha = .5;
		this.TunnelTexture = 'effect.honey_bubble';
		this.TextureScale = 1.25;

		this.MapPos = {x: 4, y: 6};
		this.reqPrevLocation = null;
		this.specialIcon = 'beehive';

		this.BackgroundTheme = "interface.InGameCalm";
		
		this.nextLocation = "Village";
		this.prevLocation = "Lake5";

		this.RoomInfo =
		{
			MinRooms: 10,
			MaxRooms: 16,
			EntityTypes: [
				"EntityHoneyChunk",
				"EntityHoneycomb",
				"EntityLakeLargeBee"
			],
			MaxEntityTypes: 3,
			BossTypes: [
				"BubblebeeQueen"
			],
			MinEntities: 10,
			MaxEntities: 20,
			MinRadius: 1000,
			MaxRadius: 1200,
			BossChambers: 1,
			SecretChambers: 0,
			Titles:
			{
				Start: "",
				Boss: "",
				Secret: "Secret Room",
				Room: ""
			},
			Subtitles:
			{
				Start: "",
				Boss: "",
				Secret: "",
				Room: ""
			},
			onUpdates:
			{
				Start: null,
				Boss: null,
				Secret: null,
				Room: null
			}
		};
	}

	RenderGradient()
	{
		var pos = World.GetBackgroundPosition();

		var grd = ctx.createLinearGradient(pos.x, pos.y, 0, World.Height);
			grd.addColorStop(0, "#C66C00");
			grd.addColorStop(0.5, "#6D3900");
			grd.addColorStop(1, "black");

		ctx.save();
		ctx.fillStyle = grd;
		ctx.fillRect(-Camera.xView, -Camera.yView, World.Width, World.Height);
		ctx.restore();
	}
	
	Update()
	{
		super.Update();
	}
	
	onLoad()
	{
		World.MinimalDeep = 0;
		this.DefaultLocationLoad();
	}
}
World.InitializeLocation(Lake9);class TestingChamber extends Location
{
	constructor()
	{
		super();
		this.Stage = 0;
		this.Radius = 1200;
		this.Title = "Bubble Wars";
		this.Subtitle = "Testing Chamber";
		this.Name = "Testing Chamber";
		this.triggerPoints = [];
		this.ageInTicks = 0;

		this.CenterPoint = {x: 0, y: 0};
		this.BackgroundTheme = "interface.InGameCalm";
		this.Room = 0;
		this.Rooms = [];


		this.nextLocation = null;
		this.prevLocation = "Carthage";

		this.RoomInfo =
		{
			// MinRooms: 5,
			// MaxRooms: 10,
			MinRooms: 100,
			MaxRooms: 100,
			EntityTypes: [
				// "EntityBubble",
				// "EntitySpikeBall"
			],
			MaxEntityTypes: 2,
			BossTypes: [
				"TheFatOne",
				"SpikySniper"
			],
			MinEntities: 5,
			MaxEntities: 10,
			MinRadius: 800,
			MaxRadius: this.Radius,
			BossChambers: 5,
			SecretChambers: 5,
			Titles:
			{
				Start: "Bubble Wars",
				Boss: "",
				Secret: "Secret Room",
				Room: ""
			},
			Subtitles:
			{
				Start: "Testing Chamber",
				Boss: "",
				Secret: "",
				Room: ""
			},
			onUpdates:
			{
				Start: null,
				Boss: null,
				Secret: null,
				Room: null
			}
		};
	}
	
	Update()
	{
		if(this.ageInTicks % 2 == 0)
		{
			// this.Radius -= 0.2;
		}
		super.Update();
	}
	
	onLoad()
	{
		World.MinimalDeep = 10;
		this.DefaultLocationLoad();
		

		// Main.ShowHitbox = true;

		// this.triggerPoints[0] = new TriggerPoint(World.CenterPoint.x, World.CenterPoint.y, 320, "test", function(entity)
		// {
		// 	// var motion = Motion.Get([entity.x, entity.y], [this.x, this.y], 400);
		// 	// entity.ApplyMove(motion);
		// });
		
	}
}
World.InitializeLocation(TestingChamber);class TheCastle extends Location
{
	constructor()
	{
		super();
		this.Name = "LOCATION.CASTLE.NAME";
		this.Texture = 'location.castle.room';
		this.TextureAlpha = 1;
		this.TextureScale = 1.22;

		this.Radius = 1200;
		this.BackgroundTheme = "world.boss_arena";

		this.nextLocation = null;
		this.prevLocation = null;

        this.MapPos = {x: 11, y: 5};
		this.reqPrevLocation = ["Lake7"];


		this.LocationFamily = '';
		// this.allowMap = false;
		

		this.RoomInfo =
		{
			MinRooms: 1,
			MaxRooms: 1,
			EntityTypes: [
	
			],
			MaxEntityTypes: 0,
			BossTypes: [
                'TheDestroyer'
            ],
			MinEntities: 0,
			MaxEntities: 0,
			MinRadius: this.Radius,
			MaxRadius: this.Radius,
			BossChambers: 1,
			SecretChambers: 0,
			Titles:
			{
			},
			Subtitles:
			{
			},
			onUpdates:
			{
				Start: null,
				Boss: null,
				Secret: null,
				Room: null
			}
		};

        this.Textures = 
        {
            Pillar: 'location.castle.pillar',
            Door: 'location.castle.door',
            LightSourceBack: 'location.castle.light.back',
            LightSource: 'location.castle.light',
            Fire: 'effect.fire.blue'
        };

        this.Pillars = 
        [
            -4,
            -15,
            -30,
            -45,
            -60,
            -75,
            -86,

            4,
            15,
            30,
            45,
            60,
            75,
            86,

            180-4,
            180-15,
            180-30,
            180-45,
            180-60,
            180-75,
            180-86,

            180+4,
            180+15,
            180+30,
            180+45,
            180+60,
            180+75,
            180+86
        ];

        this.LightSources = 
        [
            -9.25,
            -22.25,
            -37.25,
            -52.25,
            -67.25,
            -80.25,

            9.25,
            22.25,
            37.25,
            52.25,
            67.25,
            80.25,

            180-9.25,
            180-22.25,
            180-37.25,
            180-52.25,
            180-67.25,
            180-80.25,

            180+9.25,
            180+22.25,
            180+37.25,
            180+52.25,
            180+67.25,
            180+80.25
        ];

        this.PillarR = this.Radius - 10;
        this.DoorR = this.Radius - 40;

        this.lightR = this.Radius-100;
	}

    generateRandomRooms(RoomInfo, roomsNumber, min_empty)
	{
		var rooms = 
        [
            [null, 'boss', null],
            [null, true, null],
            [null, null, null]
        ]
		return {rooms: rooms, startRoom: 4};
	}

	RenderGradient()
	{
		// var pos = World.GetBackgroundPosition();

		// var grd = ctx.createLinearGradient(pos.x, pos.y, 0, World.Height);
		// 	grd.addColorStop(0, "#C66C00");
		// 	grd.addColorStop(0.5, "#6D3900");
		// 	grd.addColorStop(1, "black");

		// ctx.save();
		// ctx.fillStyle = grd;
		// ctx.fillRect(-Camera.xView, -Camera.yView, World.Width, World.Height);
		// ctx.restore();

		ctx.save();
		ctx.fillStyle = '#0A0A0A';
		ctx.fillRect(0, 0, canvas.width, canvas.height);
		ctx.restore();
	}

	RenderRoom()
	{
		super.RenderRoom();

        var doors = [];
        var sides = World.currentRoom.GetSides();

        if(sides.top) doors.push(0);
        if(sides.left) doors.push(-90);
        if(sides.bottom) doors.push(-180);
        if(sides.right) doors.push(90);


        var s = this.Radius/1000;
        var Scale = s * this.TextureScale;
        var pillarH = 190;
        var pillarR = (this.PillarR - (pillarH * s / 2)) * this.TextureScale;

        var doorH = 160;
        var doorR = (this.DoorR - (doorH * s / 2)) * this.TextureScale;

        var lightH = 26;
        var lightR = (this.lightR - (lightH * s / 2)) * this.TextureScale;

        for(var i in doors)
        {
            var pos = MathHelper.RotatePoint(World.CenterPoint, doors[i], [World.CenterPoint.x, World.CenterPoint.y - doorR]);
            Graphic.DrawRotatedImage(ctx, TextureManager.Get(this.Textures.Door), pos.x - Camera.xView, pos.y-Camera.yView, 114, doorH, Scale, doors[i], 1);
        }


        for(var i in this.Pillars)
        {
            var pos = MathHelper.RotatePoint(World.CenterPoint, this.Pillars[i], [World.CenterPoint.x, World.CenterPoint.y - pillarR]);
            Graphic.DrawRotatedImage(ctx, TextureManager.Get(this.Textures.Pillar), pos.x - Camera.xView, pos.y-Camera.yView, 40, pillarH, Scale, this.Pillars[i], 1);
        }


        for(var i in this.LightSources)
        {
            var pos = MathHelper.RotatePoint(World.CenterPoint, this.LightSources[i], [World.CenterPoint.x, World.CenterPoint.y - lightR]);
            var f_pos = MathHelper.RotatePoint(World.CenterPoint, this.LightSources[i], [World.CenterPoint.x, World.CenterPoint.y - lightR - (23*Scale)]);

            Graphic.DrawRotatedImage(ctx, TextureManager.Get(this.Textures.LightSourceBack), pos.x - Camera.xView, pos.y-Camera.yView, 30, lightH, Scale, this.LightSources[i], 1);

            var speed = 5;
            var frame = Math.floor(this.ageInTicks%(8*speed) / speed);

            Graphic.DrawRotatedAnimatedImage(ctx, frame, 8, 'Y',
                TextureManager.Get(this.Textures.Fire), f_pos.x - Camera.xView, f_pos.y-Camera.yView, 90, 160, Scale*.25, this.LightSources[i], 1);

            Graphic.DrawRotatedImage(ctx, TextureManager.Get(this.Textures.LightSource), pos.x - Camera.xView, pos.y-Camera.yView, 30, lightH, Scale, this.LightSources[i], 1);
        }
	}
	
	Update()
	{
		super.Update();
	}
	
	onLoad()
	{
		this.DefaultLocationLoad();

		
	}
}
World.InitializeLocation(TheCastle);class TroubleBubble extends Location
{
	constructor()
	{
		super();
		this.Radius = 1000;
		this.Stage = 0;
		this.Title = " ";
		this.Subtitle = " ";
		this.Perfect = false;
		this.isCleared = true;
		this.BackgroundTheme = "interface.InGameCalm";
	}

	onLoad()
	{
		SoundManager.Play(this.BackgroundTheme, "BACKGROUND");
	}
	
	Update()
	{
		this.isCleared = true;
		for(var i = 0; i < World.Entities.length; i++)
		{
			if( (!(World.Entities[i] instanceof Oxygen)) && (!(World.Entities[i] instanceof EntityUpgrade)))
			{
				this.isCleared = false;
				break;
			}
		}

		if( this.isCleared && !InGame.stageClear)
		{
			this.StageClear();
		}
		
		this.Title = " ";
		this.Subtitle = " ";

		var stage = (this.isCleared) ? this.Stage + 1 : this.Stage;
		
		if(stage == 1)
		{
			this.Title = "Welcome to Bubble Wars!";
			this.Subtitle = "Use WSAD to move";
		}
		
		if(stage == 3)
		{
			this.Subtitle = "Watch out for Mines!";
		}
		
		if(stage == 5)
		{
			this.Subtitle = "The fat one...";
		}
	}
	
	StageClear()
	{
		if(World.Player)
		{
			InGame.stageClear = true;
			this.Perfect = false;
			
			var reward = World.Player.requiredOxygen * 20 / 100;
			if(!World.Player.hurted)
			{
				this.Perfect = true;
				reward *= 2;
			}

			if(this.Stage)
			{
				World.AddEntity(new Oxygen(World.CenterPoint.x, World.CenterPoint.y, reward));
				if((this.Stage > 5) && this.Perfect)
				{
					//generuje przedmiot przy odrobinie szczescia, gdy gracz przeszedl
					//poziom powyzej 5 na perfect

					var chance = 5;
					var luck = MathHelper.randomInRange(0, 100);
					
					if(chance > luck) Upgrade.Spawn(World.Player, World.CenterPoint.x, World.CenterPoint.y);
				}
			}
		}
	}

	NewStage()
	{
		InGame.stageClear = false;
		InGame.stageClearTime = 0;
		InGame.stageClearTitleTime = 0;
		World.Player.hurted = false;
		this.Stage++;
		
		
		var stage = this.Stage;
		
		var enemies = 4 + stage;
		var enemyList = [];
		
		for(var entity in World.EntityList)
		{
			if( (World.EntityList[entity].level <= this.Stage) && (World.EntityList[entity].maxLevel >= this.Stage))
			{
				if(World.EntityList[entity].isBoss)
				{
					if(World.EntityList[entity].level == this.Stage)
					{
						World.AddEntity(new World.EntityList[entity].constructor(World.CenterPoint.x, World.CenterPoint.y));
					}
				}
				else
				{
					enemyList.push(World.EntityList[entity]);
				}
			}
		}


		
		if(stage == 10)
		{
			//boss
			enemies = 0;
		}
		
		if(stage == 15)
		{
			//boss
			var boss = new EntityFrostTurret(World.Width * TileSize / 2, World.Height * TileSize / 2, 20);
				boss.isBoss = true;
				boss.name = "Turret from Howling Abbys";
				boss.Scale = 10;
				boss.MAXHP = 1500;
				boss.HP = 1500;
				boss.oxygen = 500;
				boss.AD = 1;
				boss.ATTACK_RANGE = 2000;
				boss.BULLET_SPEED = 400;
				boss.ATTACK_SPEED = 60;
				boss.AI.Apply(new AI_ShotOnCircle({shotCount: 16, shotDelayMin: 0.5, shotDelayMax: 2}, {spd: 600, damage: 30, Texture: "projectile_spike", Scale: 2, width: 15, height: 28}));
			World.AddEntity(boss);
			
			enemies = 0;
		}
		
		if(stage == 20)
		{
			//boss
			var boss = new EntityLaserTurret(World.Width * TileSize / 2, World.Height * TileSize / 2, 20);
				boss.isBoss = true;
				boss.name = "The Destroyer";
				boss.Scale = 10;
				boss.MAXHP = 10000;
				boss.HP = 10000;
				boss.oxygen = 1000;
				boss.AD = 5;
				boss.ATTACK_RANGE = 2000;
			World.AddEntity(boss);
			
			enemies = 10;
			enemyList = [EntityFrostTurret];
		}
		
		for(var i = 0; i < enemies; i++)
		{
			var entityType = MathHelper.randomInRange(0, enemyList.length - 1);
			
			var pos = MathHelper.getRandomPointInRange([World.CenterPoint.x, World.CenterPoint.y], World.Radius - 100);
			
			var entity = new enemyList[entityType].constructor(pos.x, pos.y);
			World.AddEntity(entity);
		}
	}
	
	Render()
	{
		
		// super.Render();
	}
}
World.InitializeLocation(TroubleBubble);class Tutorial extends Location
{
	constructor()
	{
		super();
		this.Stage = 0;
		this.Radius = 1000;
		this.Title = "Welcome to Bubble Wars!";
		this.Subtitle = "Use WSAD to move";
		this.Name = "LOCATION.TUTORIAL.NAME";
		this.triggerPoints = [];
		this.ageInTicks = 0;

		this.MapPos = {x: 3, y: 4};
		this.reqPrevLocation = ["Village"];

		this.LocationFamily = 'Tutorial';


		this.canSave = false;

		this.CenterPoint = {x: 0, y: 0};
		this.BackgroundTheme = "interface.Village";
		this.Room = 0;
		

		this.nextLocation = 'Village';
		this.prevLocation = null;

		this.RoomInfo =
		{
			MinRooms: 6,
			MaxRooms: 6,
			EntityTypes: [
				"TutorialBubble"
			],
			MaxEntityTypes: 1,
			BossTypes: [
				"RubberDuck"
			],
			availableNPC:
			{
				Boss: {id: 'Mage', chance: 100},
				Secret: null,
				Start: null,
				Room: null,
			},
			MinEntities: 5,
			MaxEntities: 15,
			MinRadius: 600,
			MaxRadius: 1200,
			BossChambers: 1,
			SecretChambers: 0,
			Titles:
			{
				Start: "",
				Boss: "",
				Secret: "Secret Room",
				Room: ""
			},
			Subtitles:
			{
				Start: "",
				Boss: "",
				Secret: "",
				Room: ""
			},
			onUpdates:
			{
				Start: null,
				Boss: null,
				Secret: null,
				Room: null
			}
		};


		this.arrowAlpha = new Transition(0.3, 1, 0.5, true, 0.2, 0.2);
		this.arrow = 0;


		var boss = new Room(3, 1100, [['RubberDuck', true]], false, true, false);
			boss.allowExpReward = false;
			boss.onUpdate = function()
			{
				if(World.Player.locationInfo.Tutorial.isCleared && World.Boss) World.Boss.LootTable = new LootTable([]);
			}

		var start = new Room(10, 750, [], true, false, false);
			start.Title = 'TUTORIAL.INFO.1';
			start.Subtitle = 'TUTORIAL.INFO.2';

		var room1 = new Room(9, 900, [['TutorialBubble', false], ['TutorialBubble', false]], false, false, false);
			room1.Title = '';
			room1.Subtitle = 'TUTORIAL.INFO.3';
			room1.allowExpReward = false;

		var room2 = new Room(13, 600, [], false, false, false);
			room2.Subtitle = "TUTORIAL.INFO.4";
			room2.isCleared = true;
			room2.allowExpReward = false;

		var room3 = new Room(5, 750, [
				['TutorialBubble', false],
				['TutorialBubble', false],
				['TutorialBubble', false],
				['TutorialBubble', false]
			], false, false, false);
			room3.Subtitle = 'TUTORIAL.INFO.5';
			room3.allowExpReward = false;
			room3.onUpdate = function()
			{
				if(this.isCleared)
				{
					World.Location.Subtitle = 'TUTORIAL.INFO.6';
				}
			};

		var room4 = new Room(4, 750, [
				['TutorialBubble', false],
				['TutorialBubble', false],
				['TutorialBubble', false],
				['TutorialBubble', false]
			], false, false, false);
			room4.allowExpReward = false;
			room4.onUpdate = function()
			{
				if(World.Player.stats.Level > 1) return;

				if(!this.setitemdrop)
				{
					if(World.Entities[3])
					{
						if(!(World.Entities[3] instanceof Oxygen))
						{
							World.Entities[3].onKill = function()
							{
								var item = new EnchantGemAD();
								World.AddEntity(new EntityItem(item, this.x, this.y));
							};
						}
					}

					if(World.Entities[2])
					{
						if(!(World.Entities[2] instanceof Oxygen))
						{
							World.Entities[2].onKill = function()
							{
								var item = new CannonBase();
									item.Grade = GRADE.COMMON;
								World.AddEntity(new EntityItem(item, this.x, this.y));
							};
						}
					}

					this.setitemdrop = true;
				}

				

				if(this.isCleared)
				{
					var showPickup = false;
					for(var i = 0; i < World.Entities.length; i++)
					{
						if(World.Entities[i] instanceof EntityItem)
						{
							showPickup = true;
							break;
						}
					}

					if(showPickup)
					{
						World.Location.Subtitle = 'TUTORIAL.INFO.7';
					}
					else
					{
						World.Location.Subtitle = 'TUTORIAL.INFO.8';
					}
				}
			};


		this.room5 = new Room(11, 750, [
			['TutorialBubble', false],
			['TutorialBubble', false],
			['TutorialBubble', false],
			['TutorialBubble', false],
			['TutorialBubble', false],
			['TutorialBubble', false],
			['TutorialBubble', false],
			['TutorialBubble', false],
			['TutorialBubble', false],
			['TutorialBubble', false],
			['TutorialBubble', false],
			['TutorialBubble', false]
		], false, false, false);
		this.room5.allowExpReward = false;
		this.room5.onUpdate = function()
			{
				
				for(var i = 0; i < World.Entities.length; i++)
				{
					if(World.Entities[i] instanceof Oxygen)
					{
						World.Entities[i].FOLLOW_RANGE = (World.Radius * 2);
						if(World.Player.stats.Level > 1)
						{
							World.Entities[i].value = 1;
						}
					}
				}

				if(World.Player.stats.Level > 1 && World.Player.oxygen > 20) return;

				if(this.isCleared)
				{
					World.Location.Subtitle = 'TUTORIAL.INFO.10';
				}
			};

		var room6 = new Room(7, 800, [
			['TutorialBubble', false],
			['TutorialBubble', false],
			['TutorialBubble', false],
			['TutorialBubble', false],
			['TutorialBubble', false]
		], false, false, false);
			room6.allowExpReward = false;
			room6.onUpdate = function()
			{
				if(this.isCleared)
				{
					World.Location.Subtitle = 'TUTORIAL.INFO.11';
				}
			};


		var room7 = new Room(0, 750, [
			['TutorialBubble', false],
			['TutorialBubble', false],
			['TutorialBubble', false],
			['TutorialBubble', false],
			['TutorialBubble', false]
		], false, false, false);
		room7.allowExpReward = false;
		room7.onUpdate = function()
		{
			if(this.isCleared)
			{
				World.Location.Subtitle = 'TUTORIAL.INFO.9';
			}
		};
		room7.onEnter = function()
		{
			World.Location.UnlockRoom();
		}

		this.Rooms = 
		[
			[room7, null, null, boss],
			[room4, room3, null, room6],
			[null, room1, start, null],
			[null, room2, null, null]
		];
		
	}

	canOpenPortal()
	{
		return isNPCMet('Mage');
	}
	
	Update()
	{
		super.Update();

		if(document.getElementById('difficulty').dataset.open == 'true') World.Player.allowControl = false;
	}

	UnlockRoom()
	{
		this.Rooms[2][3] = this.room5;
		this.Rooms[2][2].Title = '';
		this.Rooms[2][2].Subtitle = 'TUTORIAL.INFO.12';
	}
	
	onLoad()
	{
		World.MinimalDeep = 0;
		
		InGame.GUI.Map.WorldMapShowing = "LOCATION";

		if(this.BackgroundTheme)
		{
			SoundManager.Play(this.BackgroundTheme, "BACKGROUND");
		}

		this.Rooms[2][2].Enter();
		World.deep = World.MinimalDeep + MathHelper.GetRoomByIndex(this.Rooms, this.Room).y;

		if(!World.Player.locationInfo.Tutorial?.isCleared) UI_Helper.OpenDifficulties();
	}
}
World.InitializeLocation(Tutorial);class Village extends Location
{
	constructor()
	{
		super();
		this.Stage = 0;
		this.Radius = 1100;
		this.Title = "Bubble Wars";
		this.Subtitle = "";
		this.Name = "LOCATION.VILLAGE.NAME";
		this.triggerPoints = [];
		this.ageInTicks = 0;

		this.CenterPoint = {x: 0, y: 0};
		this.BackgroundTheme = "interface.Village";
		this.Room = 0;
		this.Rooms = [];

		this.nextLocation = null;
		this.prevLocation = null;


		this.LocationFamily = 'Village';


		this.MapPos = {x: 1, y: 3};
		this.allowMap = false;
		this.isVillage = true;

		this.startX = 0;
		this.startY = 128;

		this.alwaysShowBubbleTunnel = 
		{
			top: false,
			bottom: true,
			left: false,
			right: false
		};
		

		this.RoomInfo =
		{
			MinRooms: 1,
			MaxRooms: 1,
			EntityTypes: [
	
			],
			MaxEntityTypes: 0,
			BossTypes: [],
			MinEntities: 0,
			MaxEntities: 0,
			MinRadius: this.Radius,
			MaxRadius: this.Radius,
			BossChambers: 0,
			SecretChambers: 0,
			Titles:
			{
			},
			Subtitles:
			{
				Start: "Village"
			},
			onUpdates:
			{
				Start: null,
				Boss: null,
				Secret: null,
				Room: null
			}
		};

		this.lastTriggerUpdate = 0;
	}

	onBorderTrigger(trigger)
	{
		if(trigger.id != 'borderTrigger2') return;
		
		if(World.Location.lastTriggerUpdate+1 != World.ageInTicks && document.getElementById('world_map').dataset.open != 'true') UI_Helper.ToggleWorldMap();

		World.Location.lastTriggerUpdate = World.ageInTicks;
	}
	
	Update()
	{
		super.Update();
	}

	onExit()
	{
		World.Player.Effects.Clear('Regeneration');
	}


	summonNPC(_constructor, x, y)
	{
		var pos = MathHelper.getRandomPointInRange([World.CenterPoint.x, World.CenterPoint.y], this.Radius - 100, 150);
		World.Spawn(new _constructor(x ?? pos.x, y ?? pos.y));
	}
	
	onLoad()
	{
		this.DefaultLocationLoad();

		this.summonNPC(DevMerchant);

		this.summonNPC(Merchant);
		this.summonNPC(Sensei);
		this.summonNPC(Mage);
		

		if(isNPCMet('STYLIST')) this.summonNPC(Stylist);
		if(isNPCMet('MINER')) this.summonNPC(Miner);


		this.summonNPC(Statue, World.CenterPoint.x, World.CenterPoint.y);
		ApplyEffect(World.Player, 'Regeneration', 2, 999999, false, {});
	}
}
World.InitializeLocation(Village);class ArmorModel extends ModelBase
{
	constructor(model)
	{
		super(model);


		var breast_armor = new Part(26, 30, 16);
		breast_armor.SetTexture("armor_base2", 26, 30);
		breast_armor.SetTextureRender(0, 0, 0, 16, 102, 156, -1, -1);
		breast_armor.SetRotation(180, 4, 7);

		var body_armor1 = new Part(40, 66, 34);
		body_armor1.SetTexture("armor_base2", 40, 66);
		body_armor1.SetTextureRender(1, 1, 0, 0, 0, 152);
		body_armor1.SetRotation(180, 18, 16);

		var body_armor2 = new Part(37, 63, 41);
		body_armor2.SetTexture("armor_base2", 37, 63);
		body_armor2.SetTextureRender(2, 2, 0, 0, 4, 74);
		body_armor2.SetRotation(180, 23, 11);

		var right_leg_armor = new Part(31, 63, 49);
		right_leg_armor.SetTexture("armor_base2", 31, 63);
		right_leg_armor.SetTextureRender(3, 3, 0, 49, 95, 64, -1, -1);
		right_leg_armor.SetRotation(180, 16, 7);

		var right_leg_armor2 = new Part(20, 57, 43);
		right_leg_armor2.SetTexture("armor_base2", 20, 57);
		right_leg_armor2.SetTextureRender(4, 4, 0, 43, 73, 69, -1, -1);
		right_leg_armor2.SetRotation(180, 12, 7);

		var left_leg_armor = new Part(31, 63, 49);
		left_leg_armor.SetTexture("armor_base2", 31, 63);
		left_leg_armor.SetTextureRender(5, 5, 0, 49, 95, 64, -1, -1);
		left_leg_armor.SetRotation(180, 16, 7);

		var left_leg_armor2 = new Part(20, 57, 43);
		left_leg_armor2.SetTexture("armor_base2", 20, 57);
		left_leg_armor2.SetTextureRender(6, 6, 0, 43, 73, 69, -1, -1);
		left_leg_armor2.SetRotation(180, 12, 7);

		var right_leg_armor3 = new Part(34, 15, 12);
		right_leg_armor3.SetTexture("armor_base2", 34, 15);
		right_leg_armor3.SetTextureRender(7, 7, 14, -6, 94, 129, -1, -1);
		right_leg_armor3.SetRotation(180, 11, 10);
		right_leg_armor3.Axis = "x";

		var left_leg_armor3 = new Part(34, 15, 12);
		left_leg_armor3.SetTexture("armor_base2", 34, 15);
		left_leg_armor3.SetTextureRender(8, 8, 14, -6, 94, 129, -1, -1);
		left_leg_armor3.SetRotation(180, 11, 10);
		left_leg_armor3.Axis = "x";

		var left_hand_armor2 = new Part(14, 50, 46);
		left_hand_armor2.SetTexture("armor_base2", 14, 50);
		left_hand_armor2.SetTextureRender(9, 9, 0, 38, 97, 1, -1, -1);
		left_hand_armor2.SetRotation(180, 7, 6);

		var right_hand_armor2 = new Part(14, 50, 46);
		right_hand_armor2.SetTexture("armor_base2", 14, 50);
		right_hand_armor2.SetTextureRender(10, 10, 0, 38, 97, 1, -1, -1);
		right_hand_armor2.SetRotation(180, 7, 6);

		var left_hand_armor = new Part(14, 50, 36);
		left_hand_armor.SetTexture("armor_base2", 14, 50);
		left_hand_armor.SetTextureRender(11, 11, 0, 0, 113, 1);
		left_hand_armor.SetRotation(180, 7, 7);

		var right_hand_armor = new Part(14, 50, 36);
		right_hand_armor.SetTexture("armor_base2", 14, 50);
		right_hand_armor.SetTextureRender(12, 12, 0, 0, 113, 1);
		right_hand_armor.SetRotation(180, 7, 7);

		var head_armor = new Part(65, 70, 12);
		head_armor.SetTexture("armor_base2", 65, 70);
		head_armor.SetTextureRender(13, 13, 0, 74, 0, 1, -1, -1);
		head_armor.SetRotation(180, 32, -2);

		model.Parts.breast.AddChild(breast_armor, true);
		model.Parts.body1.AddChild(body_armor1, true);
		model.Parts.body2.AddChild(body_armor2, true);
		model.Parts.right_leg.AddChild(right_leg_armor, true);
		model.Parts.right_leg2.AddChild(right_leg_armor2, true);
		model.Parts.left_leg.AddChild(left_leg_armor, true);
		model.Parts.left_leg2.AddChild(left_leg_armor2, true);
		model.Parts.right_leg3.AddChild(right_leg_armor3, true);
		model.Parts.left_leg3.AddChild(left_leg_armor3, true);
		model.Parts.left_hand2.AddChild(left_hand_armor2, true);
		model.Parts.right_hand2.AddChild(right_hand_armor2, true);
		model.Parts.left_hand.AddChild(left_hand_armor, true);
		model.Parts.right_hand.AddChild(right_hand_armor, true);
		model.Parts.hair_layer_0.AddChild(head_armor, true);

		this.Parts.breast_armor = breast_armor;
		this.Parts.body_armor1 = body_armor1;
		this.Parts.body_armor2 = body_armor2;
		this.Parts.right_leg_armor = right_leg_armor;
		this.Parts.right_leg_armor2 = right_leg_armor2;
		this.Parts.left_leg_armor = left_leg_armor;
		this.Parts.left_leg_armor2 = left_leg_armor2;
		this.Parts.right_leg_armor3 = right_leg_armor3;
		this.Parts.left_leg_armor3 = left_leg_armor3;
		this.Parts.left_hand_armor2 = left_hand_armor2;
		this.Parts.right_hand_armor2 = right_hand_armor2;
		this.Parts.left_hand_armor = left_hand_armor;
		this.Parts.right_hand_armor = right_hand_armor;
		this.Parts.head_armor = head_armor;
	}

	Update()
	{
		super.Update();
	}

	Render(context)
	{
		super.Render(context);
	}
}class ModelPlayer extends ModelBase
{
	constructor(owner)
	{
		super(owner);

		this.Width = 64;
		this.Height = 256;

		this.Offset.x = -26;
		this.Offset.y = -150;

		var body1 = new Part(40, 66, 34);
		body1.SetTexture("player_base2", 40, 66);
		body1.SetTextureRender(13, 13, 0, 34, 0, 152, -1, -1);
		body1.SetRotation(180, 18, 16);

		var body_pivot1 = new Part(0, 30, 10);
		body_pivot1.SetTexture("hand", 0, 30);
		body_pivot1.SetTextureRender(-2, -2);
		body_pivot1.SetRotation(60, 10, 10);

		var body2 = new Part(37, 63, 41);
		body2.SetTexture("player_base2", 37, 63);
		body2.SetTextureRender(12, 12, 0, 41, 4, 74, -1, -1);
		body2.SetRotation(-60, 23, 11);

		var breast_pivot = new Part(0, 32, 12);
		breast_pivot.SetTexture("hand", 0, 32);
		breast_pivot.SetTextureRender(-2, -2);
		breast_pivot.SetRotation(166, 10, 10);

		var breast = new Part(26, 30, 16);
		breast.SetTexture("player_base2", 26, 30);
		breast.SetTextureRender(14, 14, 0, 0, 102, 156);
		breast.SetRotation(15, 4, 7);

		var hands_pivot = new Part(0, 34, 14);
		hands_pivot.SetTexture("hand", 0, 34);
		hands_pivot.SetTextureRender(-2, -2);
		hands_pivot.SetRotation(254, 10, 10);

		var right_hand = new Part(14, 50, 36);
		right_hand.SetTexture("player_base2", 14, 50);
		right_hand.SetTextureRender(19, 3, 0, 0, 113, 1);
		right_hand.SetRotation(-427, 7, 7);

		var left_hand = new Part(14, 50, 36);
		left_hand.SetTexture("player_base2", 14, 50);
		left_hand.SetTextureRender(3, 19, 0, 0, 113, 1);
		left_hand.SetRotation(-432, 7, 7);

		var right_hand2 = new Part(14, 50, 46);
		right_hand2.SetTexture("player_base2", 14, 50);
		right_hand2.SetTextureRender(18, 2, 0, 0, 97, 1);
		right_hand2.SetRotation(-8, 7, 6);

		var left_hand2 = new Part(14, 50, 46);
		left_hand2.SetTexture("player_base2", 14, 50);
		left_hand2.SetTextureRender(2, 18, 0, 0, 97, 1);
		left_hand2.SetRotation(-17, 7, 6);

		var head_pivot = new Part(0, 31, 11);
		head_pivot.SetTexture("hand", 0, 31);
		head_pivot.SetTextureRender(-2, -2);
		head_pivot.SetRotation(-51, 10, 10);

		var head = new Part(55, 70, 54);
		head.SetTexture("player_base2", 55, 70);
		head.SetTextureRender(10, 10, 0, 54, 0, 0, -1, -1);
		head.SetRotation(50, 22, 8);

		var right_leg = new Part(31, 63, 49);
		right_leg.SetTexture("player_base2", 31, 63);
		right_leg.SetTextureRender(8, 5, 0, 0, 95, 64);
		right_leg.SetRotation(0, 16, 7);

		var right_leg2 = new Part(20, 57, 43);
		right_leg2.SetTexture("player_base2", 20, 57);
		right_leg2.SetTextureRender(7, 4, 0, 0, 73, 69);
		right_leg2.SetRotation(0, 12, 7);

		var right_leg_pivot = new Part(0, 25, 5);
		right_leg_pivot.SetTexture("hand", 0, 25);
		right_leg_pivot.SetTextureRender(-2, -2);
		right_leg_pivot.SetRotation(-310, 10, 10);

		var right_leg3 = new Part(34, 15, 16);
		right_leg3.SetTexture("player_base2", 34, 15);
		right_leg3.SetTextureRender(9, 6, 0, 0, 94, 129);
		right_leg3.SetRotation(310, 9, 4);
		right_leg3.Axis = "x";

		var left_leg = new Part(31, 63, 49);
		left_leg.SetTexture("player_base2", 31, 63);
		left_leg.SetTextureRender(5, 8, 0, 0, 95, 64);
		left_leg.SetRotation(-8, 16, 7);

		var left_leg2 = new Part(20, 57, 43);
		left_leg2.SetTexture("player_base2", 20, 57);
		left_leg2.SetTextureRender(4, 7, 0, 0, 73, 69);
		left_leg2.SetRotation(2, 12, 7);

		var left_leg_pivot = new Part(0, 25, 5);
		left_leg_pivot.SetTexture("hand", 0, 25);
		left_leg_pivot.SetTextureRender(-2, -2);
		left_leg_pivot.SetRotation(-310, 10, 10);

		var left_leg3 = new Part(34, 15, 16);
		left_leg3.SetTexture("player_base2", 34, 15);
		left_leg3.SetTextureRender(6, 9, 0, 0, 94, 129);
		left_leg3.SetRotation(318, 9, 4);
		left_leg3.Axis = "x";

		var hair_layer_0 = new Part(55, 80, 30);
		hair_layer_0.SetTexture("hair2", 55, 80);
		hair_layer_0.SetTextureRender(15, 15);
		hair_layer_0.SetRotation(180, 22, 8);

		var right_handheld = new Part(128, 128, 100);
		right_handheld.SetTexture("shadow_scythe", 128, 128);
		right_handheld.SetTextureRender(16, 0, 0, 0, 0, 0, -1, -1);
		right_handheld.SetRotation(-197, 48, 80);
		right_handheld.Axis = "x";
		right_handheld.BindItemSlot(SLOT.HAND+"0", this);

		var left_handheld = new Part(128, 128, 100);
		left_handheld.SetTexture("shadow_scythe", 128, 128);
		left_handheld.SetTextureRender(0, 16, 0, 0, 0, 0, -1, -1);
		left_handheld.SetRotation(175, 48, 80);
		left_handheld.Axis = "x";
		left_handheld.BindItemSlot(SLOT.HAND+"1", this);

		var eyes = new Part(17, 13, 100);
		eyes.SetTexture("eyes", 34, 26);
		eyes.SetTextureRender(11, 11);
		eyes.SetRotation(180, -9, -24);

		var right_hand_pivot = new Part(0, 18, 100);
		right_hand_pivot.SetTexture("hand", 20, 100);
		right_hand_pivot.SetTextureRender(-2, -2);
		right_hand_pivot.SetRotation(-171, 10, 10);

		var right_hand3 = new Part(16, 24, 100);
		right_hand3.SetTexture("hand", 32, 48);
		right_hand3.SetTextureRender(17, 1);
		right_hand3.SetRotation(166, 6, 4);

		var left_hand_pivot = new Part(0, 18, 100);
		left_hand_pivot.SetTexture("hand", 20, 100);
		left_hand_pivot.SetTextureRender(-2, -2);
		left_hand_pivot.SetRotation(-171, 10, 10);

		var left_hand3 = new Part(16, 24, 100);
		left_hand3.SetTexture("hand", 32, 48);
		left_hand3.SetTextureRender(1, 17);
		left_hand3.SetRotation(170, 6, 4);

		body1.AddChild(body_pivot1);
		body_pivot1.AddChild(body2);
		body2.AddChild(breast_pivot);
		breast_pivot.AddChild(breast);
		body2.AddChild(hands_pivot);
		hands_pivot.AddChild(right_hand);
		hands_pivot.AddChild(left_hand);
		right_hand.AddChild(right_hand2);
		left_hand.AddChild(left_hand2);
		body2.AddChild(head_pivot);
		head_pivot.AddChild(head);
		right_leg.AddChild(right_leg2);
		right_leg2.AddChild(right_leg_pivot);
		right_leg_pivot.AddChild(right_leg3);
		left_leg.AddChild(left_leg2);
		left_leg2.AddChild(left_leg_pivot);
		left_leg_pivot.AddChild(left_leg3);
		head.AddChild(hair_layer_0);
		right_hand2.AddChild(right_handheld);
		left_hand2.AddChild(left_handheld);
		head.AddChild(eyes);
		right_hand2.AddChild(right_hand_pivot);
		right_hand_pivot.AddChild(right_hand3);
		left_hand2.AddChild(left_hand_pivot);
		left_hand_pivot.AddChild(left_hand3);

		body1.AddChild(body_pivot1);
		body_pivot1.AddChild(body2);
		body2.AddChild(breast_pivot);
		breast_pivot.AddChild(breast);
		body2.AddChild(hands_pivot);
		hands_pivot.AddChild(right_hand);
		hands_pivot.AddChild(left_hand);
		right_hand.AddChild(right_hand2);
		left_hand.AddChild(left_hand2);
		body2.AddChild(head_pivot);
		head_pivot.AddChild(head);
		right_leg.AddChild(right_leg2);
		right_leg2.AddChild(right_leg_pivot);
		right_leg_pivot.AddChild(right_leg3);
		left_leg.AddChild(left_leg2);
		left_leg2.AddChild(left_leg_pivot);
		left_leg_pivot.AddChild(left_leg3);
		head.AddChild(hair_layer_0);
		right_hand3.AddChild(right_handheld);
		left_hand3.AddChild(left_handheld);
		head.AddChild(eyes);
		right_hand2.AddChild(right_hand_pivot);
		right_hand_pivot.AddChild(right_hand3);
		left_hand2.AddChild(left_hand_pivot);
		left_hand_pivot.AddChild(left_hand3);

		this.Parts.body1 = body1;
		this.Parts.body_pivot1 = body_pivot1;
		this.Parts.body2 = body2;
		this.Parts.breast_pivot = breast_pivot;
		this.Parts.breast = breast;
		this.Parts.hands_pivot = hands_pivot;
		this.Parts.right_hand = right_hand;
		this.Parts.left_hand = left_hand;
		this.Parts.right_hand2 = right_hand2;
		this.Parts.left_hand2 = left_hand2;
		this.Parts.head_pivot = head_pivot;
		this.Parts.head = head;
		this.Parts.right_leg = right_leg;
		this.Parts.right_leg2 = right_leg2;
		this.Parts.right_leg_pivot = right_leg_pivot;
		this.Parts.right_leg3 = right_leg3;
		this.Parts.left_leg = left_leg;
		this.Parts.left_leg2 = left_leg2;
		this.Parts.left_leg_pivot = left_leg_pivot;
		this.Parts.left_leg3 = left_leg3;
		this.Parts.hair_layer_0 = hair_layer_0;
		this.Parts.right_handheld = right_handheld;
		this.Parts.left_handheld = left_handheld;
		this.Parts.eyes = eyes;
		this.Parts.right_hand_pivot = right_hand_pivot;
		this.Parts.right_hand3 = right_hand3;
		this.Parts.left_hand_pivot = left_hand_pivot;
		this.Parts.left_hand3 = left_hand3;

		this.ApplyArmorModel(ArmorModel);
		this.ApplyModelAnimation(ModelPlayerAnimation);
	}

	Update()
	{
		super.Update();
	}

	Render(context)
	{
		super.Render(context);
	}
}class ModelPlayerAnimation extends AnimationBase
{
    constructor(model)
    {
        super(model);
    }

    Update()
    {
        super.Update();

        if(this.Model.Owner.isMoving)
        {
            if(this.AnimationInfo == null)
            {
                this.Run("Walk");
            }
        }
        else
        {
            if(this.AnimationInfo != null)
            {
                if(this.AnimationInfo.id == "Walk")
                {
                    this.Break();
                }
            }
        }
    }

    Walk(Initialize)
    {
        if(Initialize)
        {
            this.AnimationInfo.Frames = 15;
            this.AnimationInfo.FrameDelay = 2;
            this.AnimationInfo.LoopMode = LOOP.RETURN;
            this.AnimationInfo.onAnimationEnd = function(){console.log("END")};

            this.AnimationInfo.onBreak = function(animation)
            {
                animation.ResetElementProperties("right_hand");
                animation.ResetElementProperties("left_hand");

                animation.ResetElementProperties("right_leg");
                animation.ResetElementProperties("left_leg");
            }
        }
        var frame = this.AnimationInfo.Frame;

        this.ApplyRotation("right_hand", 270 + frame * 2);
        this.ApplyRotation("left_hand", 310 - frame * 2);

        this.ApplyRotation("breast", 15 + frame / 2);

        this.ApplyRotation("right_leg", 20 - frame * 2.5);
        this.ApplyRotation("left_leg", 340 + frame * 2.5);
    }
}class ModelCannonBase
{
    constructor(texture, textureRotation , scale, tX, tY)
    {
        this.Texture = texture;
        this.TextureRotation = textureRotation ?? 180;
        this.Rotation = -10;
        this.Scale = scale ?? 1;
        this.translateX = tX ?? .3;
        this.translateY = tY ?? -.45;

        this.HandPose = 
        [
            {
                x: -8,
                y: -44,
                rotation: 210,
                tX: 0,
                tY: 0
            },
            {
                x: -12,
                y: -62,
                rotation: 210,
                tX: 0,
                tY: 0
            }
        ];
    }

    Update(owner)
    {

    }

    UpdateHandPose(gaugeTranslate)
    {
        for(var i = 0; i < this.HandPose.length; i++)
        {
            this.HandPose[i].tY = gaugeTranslate;
        }
    }

    Render(context, owner)
    {
        var x = owner.x - Camera.xView;
        var y = owner.y - Camera.yView;
        var height = owner.Height;
        var width = owner.Width;

        var rotation = owner.Appearance.Rotation;
        var scale = owner.Appearance.Scale * this.Scale;
        var alpha = owner.Appearance.Transparency;

        var texture = TextureManager.Get(this.Texture);
        var baseRotation = rotation + this.TextureRotation + this.Rotation;

        var tX = this.translateX * width / this.Scale;
        var tY = this.translateY * height / this.Scale;

        var gaugeTranslate = (1 - owner.attackGauge) * 8;
        this.UpdateHandPose(gaugeTranslate);

        Graphic.DrawRotatedImage(context, texture, x, y, width, height, scale, baseRotation, alpha, tX, tY + gaugeTranslate);
    }
}class SkinBase
{
    static Variants = [];

    constructor(owner)
    {
        this.Name = 'SKIN.BASE.NAME';
        this.Owner = owner;
        this.Textures = 
        {
            Base: 'player.skin.base',
            BaseRotation: 180
        };

        this.Hands = 
        [
            ['entity.npc.hand.left', 16, 16],
            ['entity.npc.hand.right', 16, 16]
        ];

    }

    static InitVariant(skin)
    {
        this.Variants.push(skin);
        skin.isVariant = true;
    }

    Update()
    {

    }

    RenderHands(context)
    {
        var owner = this.Owner;
        if(!owner.GetWeapon()) return;

        var ownerX = owner.x - Camera.xView;
        var ownerY = owner.y - Camera.yView;
        
        var owner_rotation = owner.Appearance.Rotation;
        var scale = owner.Appearance.Scale;
        var alpha = owner.Appearance.Transparency;
        var weaponModel = owner.GetCurrentWeaponModel();

        var hands = this.Hands;

		for(var i = 0; i < hands.length; i++)
		{
			var hand = hands[i];
            var weaponHandPose = weaponModel.HandPose[i];

			var texture = TextureManager.Get(hand[0]);
			var tX = weaponHandPose.tX ?? 0;
			var tY = weaponHandPose.tY ?? 0;
            var handX = weaponHandPose.x ?? 0;
            var handY = weaponHandPose.y ?? 0;

            var width = hand[1] ?? 16;
			var height = hand[2] ?? 16;

            var endPoints = [
                (ownerX + (owner.Width * scale * .5) + (tX + handX - (width/2)) * scale),
                (ownerY + (owner.Height * scale * .5) + (tY + handY - (height/2)) * scale)
            ];
            var pos = MathHelper.RotatePoint([ownerX, ownerY], owner_rotation + weaponModel.Rotation, endPoints);

			var rotation = weaponHandPose.rotation ?? hand[5] ?? 0;

			context.save();
			context.translate(pos.x, pos.y);
			context.rotate((owner_rotation + rotation) * Math.PI/180);
			context.globalAlpha = alpha;
			context.drawImage(
				texture, 0, 0, texture.width, texture.height,
				-((width / 2)) * scale, -((height / 2)) * scale,
				(width * scale), (height * scale)
			);
			context.restore();
		}
    }

    Render(context)
    {
        var owner = this.Owner;
        var x = owner.x - Camera.xView;
        var y = owner.y - Camera.yView;
        var height = owner.Height;
        var width = owner.Width;

        var rotation = owner.Appearance.Rotation;
        var scale = owner.Appearance.Scale;
        var alpha = owner.Appearance.Transparency;

        var textureBase = TextureManager.Get(this.Textures.Base);
        var baseRotation = rotation + this.Textures.BaseRotation;

        Graphic.DrawRotatedImage(context, textureBase, x, y, width, height, scale, baseRotation, alpha);
    }
}
Player.InitSkin(SkinBase);

class SkinBaseF extends SkinBase
{
    constructor(owner)
    {
        super(owner);
        this.Name = 'SKIN.BASE.F.NAME';
        this.Textures = 
        {
            Base: 'player.skin.base.f',
            BaseRotation: 180
        };
    }
}
Player.InitSkin(SkinBaseF);class ModelBoomerangBase extends ModelCannonBase
{
    constructor(texture, textureRotation, scale, tX, tY)
    {
        super(texture, textureRotation, scale, tX, tY);
       
        this.HandPose = 
        [
            {
                x: 0,
                y: 0,
                rotation: 230,
                tX: 0,
                tY: 0
            },
            {
                x: -50,
                y: -62,
                rotation: 210,
                tX: 0,
                tY: 0
            }
        ];

        this.showProjectile = true;
    }

    Update(owner)
    {
        var weapon = owner.GetWeapon();
        if(weapon)
        {
            this.showProjectile = weapon.GetAvailableThrows() > 0;
        }

        if(!this.showProjectile)
        {
            this.HandPose[0].x = 20;
            this.HandPose[0].y = -20;
            this.HandPose[0].rotation = 210;
        }
        else
        {
            this.HandPose[0].x = 0;
            this.HandPose[0].y = 0;
            this.HandPose[0].rotation = 230;
        }
    }

    UpdateHandPose(gaugeTranslate)
    {
        return;
        for(var i = 0; i < this.HandPose.length; i++)
        {
            this.HandPose[i].tY = gaugeTranslate;
        }
    }

    Render(context, owner)
    {
        if(!this.showProjectile) return;

        super.Render(context, owner);
    }
}class ModelMachineGun extends ModelCannonBase
{
    constructor(texture, textureRotation , scale = 2, tX, tY)
    {
        super(texture, textureRotation, scale, tX, tY)
       
        this.Texture0 = 'model.item.machine.gun.0';
    }

    UpdateHandPose(gaugeTranslate)
    {
        for(var i = 0; i < this.HandPose.length; i++)
        {
            this.HandPose[i].tY = gaugeTranslate;
        }
    }

    Render(context, owner)
    {
        var x = owner.x - Camera.xView;
        var y = owner.y - Camera.yView;
        var height = owner.Height;
        var width = owner.Width;

        var s0 = width/128;
        var width0 = 32 * s0;
        var height0 = 40 * s0;
        var tY0 = -44 * s0;

        var rotation = owner.Appearance.Rotation;
        var scale = owner.Appearance.Scale * this.Scale;
        var alpha = owner.Appearance.Transparency;

        var texture = TextureManager.Get(this.Texture);
        var texture0 = TextureManager.Get(this.Texture0);
        var baseRotation = rotation + this.TextureRotation + this.Rotation;

        var tX = this.translateX * width / this.Scale;
        var tY = this.translateY * height / this.Scale;

        var gaugeTranslate = (1 - owner.attackGauge) * 8 / 4;
        this.UpdateHandPose(gaugeTranslate);

        var frames = 4;
        var frame = owner.ageInTicks%frames;
        if(!owner.isAttacking) frame = 0;

        Graphic.DrawRotatedImage(context, texture, x, y, width, height, scale, baseRotation, alpha, tX, tY + gaugeTranslate);
        Graphic.DrawRotatedAnimatedImage(context, frame, frames, 'X', texture0, x, y, width0, height0, scale, baseRotation, alpha, tX, tY0 + tY + gaugeTranslate);
    }
}class ModelMagicSphere extends ModelCannonBase
{
    constructor(texture, textureRotation , scale = 2, tX, tY)
    {
        super(texture, textureRotation, scale, tX, tY);

        this.HandPose[0].y = -45;
        this.HandPose[0].x = 5;
        this.HandPose[0].rotation = 230;

        this.HandPose[1].y = -55;
        this.HandPose[1].x = -40;
        this.HandPose[1].rotation = 140;
    }

    UpdateHandPose(gaugeTranslate)
    {
        return;
    }
}class ModelRifle extends ModelCannonBase
{
    constructor(texture, textureRotation , scale = 1.5, tX = 0.28, tY = -.25)
    {
        super(texture, textureRotation, scale, tX, tY)
       
        this.Texture0 = 'model.item.rifle.0';
    }

    Render(context, owner)
    {
        var x = owner.x - Camera.xView;
        var y = owner.y - Camera.yView;
        var height = owner.Height;
        var width = owner.Width;

        var s0 = width/128;
        var tY0 = (-width-44) * s0;

        var rotation = owner.Appearance.Rotation;
        var scale = owner.Appearance.Scale * this.Scale;
        var alpha = owner.Appearance.Transparency;

        var texture = TextureManager.Get(this.Texture);
        var texture0 = TextureManager.Get(this.Texture0);
        var baseRotation = rotation + this.TextureRotation + this.Rotation;

        var tX = this.translateX * width / this.Scale;
        var tY = this.translateY * height / this.Scale;

        var gaugeTranslate = (1 - owner.attackGauge) * 8;
        this.UpdateHandPose(gaugeTranslate);

        Graphic.DrawRotatedImage(context, texture, x, y, width, height, scale, baseRotation, alpha, tX, tY + gaugeTranslate);
        Graphic.DrawRotatedImage(context, texture0, x, y, width, height, scale, baseRotation, alpha, tX, tY0 + tY + gaugeTranslate);
    }
}class SkinCatgirl extends SkinBase
{
    static Variants = [];
    
    constructor(owner)
    {
        super(owner);

        this.Name = 'SKIN.CATGIRL.NAME';
        this.Textures = 
        {
            Base: 'player.skin.catgirl.base',
            BaseRotation: 180,

            Tail: 'player.skin.catgirl.tail',
            TailRotation: 180
        };

        this.TailFrames = 12;
        this.TailAnimation = new Transition(0, this.TailFrames -1, .75, false, 0, 0, true);
    }

    Update()
    {

    }

    Render(context)
    {
        var owner = this.Owner;
        var x = owner.x - Camera.xView;
        var y = owner.y - Camera.yView;
        var height = owner.Height;
        var width = owner.Width;

        var rotation = owner.Appearance.Rotation;
        var scale = owner.Appearance.Scale;
        var alpha = owner.Appearance.Transparency;

        var textureBase = TextureManager.Get(this.Textures.Base);
        var baseRotation = rotation + this.Textures.BaseRotation;

        var textureTail = TextureManager.Get(this.Textures.Tail);
        var tailRotation = rotation + this.Textures.TailRotation;
        var tailTranslationY = height * .45 * scale;

        var tailPos = MathHelper.lineToAngle([x,y], tailTranslationY, rotation+90);
        var tailFrame = this.TailAnimation.Update();

            Graphic.DrawRotatedAnimatedImage(context, tailFrame, this.TailFrames, 'Y', 
                textureTail, tailPos.x, tailPos.y, width, height, scale, tailRotation, alpha * .75, 0, ((height * .95 * scale) - tailTranslationY)/scale);

        Graphic.DrawRotatedImage(context, textureBase, x, y, width, height, scale, baseRotation, alpha);
    }
}
// Player.InitSkin(SkinCatgirl);
class SkinKitsune extends SkinBase
{
    static Variants = [];

    constructor(owner)
    {
        super(owner);

        this.Name = 'SKIN.KITSUNE.NAME';
        this.Textures = 
        {
            Base: 'player.skin.kitsune.base',
            BaseRotation: 180,

            Tail: 'player.skin.kitsune.tail',
            TailRotation: 180
        };

        this.TailFrames = 12;
        this.TailAnimation = new Transition(0, this.TailFrames -1, .75, false, 0, 0, true);
    }

    Update()
    {

    }

    Render(context)
    {
        var owner = this.Owner;
        var x = owner.x - Camera.xView;
        var y = owner.y - Camera.yView;
        var height = owner.Height;
        var width = owner.Width;

        var rotation = owner.Appearance.Rotation;
        var scale = owner.Appearance.Scale;
        var alpha = owner.Appearance.Transparency;

        var textureBase = TextureManager.Get(this.Textures.Base);
        var baseRotation = rotation + this.Textures.BaseRotation;

        var textureTail = TextureManager.Get(this.Textures.Tail);
        var tailRotation = rotation + this.Textures.TailRotation;
        var tailTranslationY = height * .45 * scale;
        var tails = 9;
        var tailsAngleStep = 10;
        var tailAngles = 
        [
            tailRotation - (4 * tailsAngleStep),
            tailRotation + (4 * tailsAngleStep),

            tailRotation - (3 * tailsAngleStep),
            tailRotation + (3 * tailsAngleStep),

            tailRotation - (2 * tailsAngleStep),
            tailRotation + (2 * tailsAngleStep),

            tailRotation - (1 * tailsAngleStep),
            tailRotation + (1 * tailsAngleStep),

            tailRotation
        ];
        var tailPos = MathHelper.lineToAngle([x,y], tailTranslationY, rotation+90);
        var tailFrame = this.TailAnimation.Update();

        for(var i = 0; i < tails; i++)
        {
            var dir = (i%2 == 0) ? 1 : -1;
            var f = (this.TailFrames + tailFrame + (i*dir)) % (this.TailFrames-1);
            // f = tailFrame + dir;
            Graphic.DrawRotatedAnimatedImage(context, f, this.TailFrames, 'Y', 
                textureTail, tailPos.x, tailPos.y, width, height, scale, tailAngles[i], alpha * .75, 0, ((height * .95 * scale) - tailTranslationY)/scale);
        }

        Graphic.DrawRotatedImage(context, textureBase, x, y, width, height, scale, baseRotation, alpha);
    }
}
Player.InitSkin(SkinKitsune);



class SkinKitsuneAngelic extends SkinKitsune
{
    constructor(owner)
    {
        super(owner);

        this.Name = 'SKIN.KITSUNE.ANGELIC.NAME';

        this.Textures.Base = 'player.skin.kitsune.angelic.base';
        this.Textures.Tail = 'player.skin.kitsune.angelic.tail';
    }
}
Player.InitSkin(SkinKitsuneAngelic);




class SkinKitsuneShadowflame extends SkinKitsune
{
    constructor(owner)
    {
        super(owner);

        this.Name = 'SKIN.KITSUNE.SHADOWFLAME.NAME';
        
        this.Textures.Base = 'player.skin.kitsune.shadowflame.base';
        this.Textures.Tail = 'player.skin.kitsune.shadowflame.tail';
    }
}
Player.InitSkin(SkinKitsuneShadowflame);class SkinReaper extends SkinBase
{
    static Variants = [];

    constructor(owner)
    {
        super(owner);

        this.Name = 'SKIN.REAPER.NAME';
        this.Textures = 
        {
            Base: 'player.skin.reaper.base',
            BaseRotation: 180,

            Cape: 'player.skin.reaper.cape'
        };

        this.CapeFrames = 12;
        this.CapeAnimation = new Transition(0, this.CapeFrames -1, .75, false, 0, 0, true);

        this.Hands = 
        [
            ['player.skin.reaper.hand.left', 16, 16],
            ['player.skin.reaper.hand.right', 16, 16]
        ];
    }

    Update()
    {

    }

    Render(context)
    {
        var owner = this.Owner;
        var x = owner.x - Camera.xView;
        var y = owner.y - Camera.yView;
        var height = owner.Height;
        var width = owner.Width;

        var rotation = owner.Appearance.Rotation;
        var scale = owner.Appearance.Scale;
        var alpha = owner.Appearance.Transparency;

        var textureBase = TextureManager.Get(this.Textures.Base);
        var baseRotation = rotation + this.Textures.BaseRotation;

        var textureCape = TextureManager.Get(this.Textures.Cape);
        var frame = this.CapeAnimation.Update();

        Graphic.DrawRotatedAnimatedImage(context, frame, this.CapeFrames, 'Y', 
            textureCape, x, y, width, height, scale, baseRotation, alpha, 0, height * .5);

        Graphic.DrawRotatedImage(context, textureBase, x, y, width, height, scale, baseRotation, alpha);
    }
}
Player.InitSkin(SkinReaper);

//Merchant

	new DialogLine('MerchantTest', 'Merchant do was przemowil lol xD', [new DialogOption('Pokaz mi swoje towary.', DialogLine.OpenShop, 'store')]);
	new DialogLine('DevMerchantStart', 'Mam tu dla was wszystkie itemaski z caluśkiej gry towarzysze! Ale ani slowa adminowi!', [new DialogOption('Pokaz mi swoje towary.', DialogLine.OpenLargeShop, 'store')]);


	

//Sensei
	new DialogLine('SenseiDialog', 'NPC.SENSEI.DIALOG.1', [
		new DialogOption('Pokaz mi co masz.', DialogLine.OpenKnowledge, 'knowledge')
	]);




//Mage

new DialogLine('MageMetDialog', 'NPC.MAGE.DIALOG.0', [
	new DialogOption('NPC.MAGE.DIALOG.0.OPTION.1', () => DialogLine.ChangeDialogLine('MageDialog'))
]);

	new DialogLine('MageDialog', ['NPC.MAGE.DIALOG.1', 'NPC.MAGE.DIALOG.2', 'NPC.MAGE.DIALOG.3'], [
		new DialogOption('Chce cos stworzyc.', DialogLine.OpenCrafting, 'crafting')
	]);



//Miner
new DialogLine('MinerMetDialog', 'NPC.MINER.DIALOG.0', [
	new DialogOption('NPC.STYLIST.MINER.0.OPTION.1', () => DialogLine.ChangeDialogLine('MinerDialog'))
]);
	new DialogLine('MinerDialog', 'NPC.MINER.DIALOG.1', [
		new DialogOption('NPC.MINER.DIALOG.1.OPTION.1', DialogLine.OpenShop, 'store')
	]);



//Stylist
new DialogLine('StylistMetDialog', 'NPC.STYLIST.DIALOG.0', [
	new DialogOption('NPC.STYLIST.DIALOG.0.OPTION.1', () => DialogLine.ChangeDialogLine('StylistDialog'))
]);

	new DialogLine('StylistDialog', ['NPC.STYLIST.DIALOG.1', 'NPC.STYLIST.DIALOG.2'], [
		new DialogOption('Chce sie zmienic.', DialogLine.OpenAppearance, 'customize')
	]);





//Statue
new DialogLine('StatueMetDialog', 'NPC.STATUE.DIALOG.0', [
	new DialogOption('NPC.STATUE.DIALOG.0.OPTION.1', () => DialogLine.ChangeDialogLine('StatueDialog'))
]);

	new DialogLine('StatueDialog', 'NPC.STATUE.DIALOG.1', [
		new DialogOption('NPC.STATUE.DIALOG.1.OPTION.1', () => {Commands.GoToLocation('BossArena'); DialogLine.Exit()},  'boss_arena', () => {return World.Player.haveItemInstanceInInventory(SummonScroll) != -1}),
		new DialogOption('NPC.STATUE.DIALOG.1.OPTION.2', () => DialogLine.ChangeDialogLine('StatueDialogSacrifice'))
	]);

		new DialogLine('StatueDialogSacrifice', 'NPC.STATUE.DIALOG.SACRIFICE', [
			new DialogOption('NPC.STATUE.DIALOG.SACRIFICE.OPTION.1', () => {World.Player.interactionWith?.Sacrifice(); DialogLine.Exit()})
			// new DialogOption('NPC.STATUE.DIALOG.SACRIFICE.OPTION.2', () => DialogLine.ChangeDialogLine('StatueDialogSacrifice'))
		], ['NPC.STATUE.DIALOG.SACRIFICE.EXIT']);






//Bubblebee
new DialogLine('BubblebeeDialog', 'BOSS.BUBBLEBEE.DIALOG.1', [
	new DialogOption('BOSS.BUBBLEBEE.DIALOG.1.OPTION.1', () => {World.Player.interactionWith.TakeHoney(); DialogLine.Exit()},  'honeycomb', () => {return World.Player.haveItemInInventory('Honeycomb') != -1})
], ['BOSS.BUBBLEBEE.DIALOG.EXIT']);






/////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////  Q  U  E  S  T  S  ///////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////


new DialogLine('QuestLineLevelUp1', 'QUEST.LEVELUP.1', 
	[new DialogOption('QUEST.ACCEPT', () => {QuestList.Accept('QuestLineLevelUp1'); DialogLine.Exit();})],
	['QUEST.DECLINE']
);
new DialogLine('QuestLineLevelUp1Complete', 'QUEST.LEVELUP.1.COMPLETE', 
	[new DialogOption('QUEST.COMPLETE', () => {QuestList.Complete('QuestLineLevelUp1'); DialogLine.Exit();})],
	['QUEST.DECLINE']
);



new DialogLine('QuestLineLevelUp2', 'QUEST.LEVELUP.2', 
	[new DialogOption('QUEST.ACCEPT', () => {QuestList.Accept('QuestLineLevelUp2'); DialogLine.Exit();})],
	['QUEST.DECLINE']
);
new DialogLine('QuestLineLevelUp2Complete', 'QUEST.LEVELUP.2.COMPLETE', 
	[new DialogOption('QUEST.COMPLETE', () => {QuestList.Complete('QuestLineLevelUp2'); DialogLine.Exit();})],
	['QUEST.DECLINE']
);



new DialogLine('QuestLineLevelUp3', 'QUEST.LEVELUP.3', 
	[new DialogOption('QUEST.ACCEPT', () => {QuestList.Accept('QuestLineLevelUp3'); DialogLine.Exit();})],
	['QUEST.DECLINE']
);
new DialogLine('QuestLineLevelUp3Complete', 'QUEST.LEVELUP.3.COMPLETE', 
	[new DialogOption('QUEST.COMPLETE', () => {QuestList.Complete('QuestLineLevelUp3'); DialogLine.Exit();})],
	['QUEST.DECLINE']
);










new DialogLine('QuestLineViViScissors', 'QUEST.VIVISCISSORS', 
	[new DialogOption('QUEST.ACCEPT', () => {QuestList.Accept('QuestLineViViScissors'); DialogLine.Exit();})],
	['QUEST.DECLINE']
);
new DialogLine('QuestLineViViScissorsComplete', 'QUEST.VIVISCISSORS.COMPLETE', 
	[new DialogOption('QUEST.COMPLETE', () => {QuestList.Complete('QuestLineViViScissors'); DialogLine.Exit();})],
	['QUEST.DECLINE']
);






LANGS["EN"] =
{
    'MENU.START': 'Play',
    'MENU.TESTING_CHAMBER': 'Testing Chamber',
    'MENU.LOADING.READY': 'Click to start',
    'MENU.SETTINGS': 'Settings',
    'MENU.QUIT': 'Quit',
    'MENU.CONTINUE': 'Continue',
    'MENU.CREDITS': 'Credits',

    'MENU.SETTINGS.GENERAL': 'General',
    'MENU.SETTINGS.AUDIO': 'Audio',
    'MENU.SETTINGS.VIDEO': 'Video',
    'MENU.SETTINGS.CONTROLS': 'Controls',

    'MENU.SETTINGS.GENERAL.SHOWDAMAGEDEALT': 'Display damage dealt',
    'MENU.SETTINGS.GENERAL.SHOWDAMAGERECEIVED': 'Display damage received',

    'MENU.SETTINGS.GENERAL.SHOWMINIMAP': 'Show Minimap',
    'MENU.SETTINGS.GENERAL.SHOWRADAR': 'Show Radar',
    'MENU.SETTINGS.GENERAL.SHOWITEMPRICE': 'Show Item price',
    'MENU.SETTINGS.GENERAL.ALLOWWINDOWDRAG': 'Draggable windows',
    'MENU.SETTINGS.GENERAL.ALWAYSREPOSEWINDOWS': 'Reset windows position',

    

    'MENU.SETTINGS.AUDIO.VOLUME.OVERALL': 'Overall volume',
    'MENU.SETTINGS.AUDIO.VOLUME.MUSIC': 'Music volume',
    'MENU.SETTINGS.AUDIO.VOLUME.EFFECTS': 'FX volume',

    'MENU.SETTINGS.APPLY': 'Apply',
    'MENU.SETTINGS.RESET': 'Reset All',

    'MENU.SETTINGS.VIDEO.FULLSCREEN': 'Fullscreen',
    'MENU.SETTINGS.VIDEO.RESOLUTION': 'Resolution',
    'MENU.SETTINGS.VIDEO.UI_SCALE': 'UI Scale',

    'MENU.SETTINGS.CONTROLS.PLAYERMOVEUP': 'Move up',
    'MENU.SETTINGS.CONTROLS.PLAYERMOVEDOWN': 'Move down',
    'MENU.SETTINGS.CONTROLS.PLAYERMOVELEFT': 'Move left',
    'MENU.SETTINGS.CONTROLS.PLAYERMOVERIGHT': 'Move right',

    'MENU.SETTINGS.CONTROLS.ALWAYSDASHTOWARDCURSOR': 'Always dash towards the cursor',
    'MENU.SETTINGS.CONTROLS.SKILL': 'Use Item Skill',
    'MENU.SETTINGS.CONTROLS.OPENINVENTORY': 'Open Inventory',
    'MENU.SETTINGS.CONTROLS.OPENMINIMAP': 'Open Minimap',
    'MENU.SETTINGS.CONTROLS.OPENMAP': 'Open World Map',
    'MENU.SETTINGS.CONTROLS.OPENSTATS': 'Open Stats',
    'MENU.SETTINGS.CONTROLS.INTERACT': 'Interact',
    'MENU.SETTINGS.CONTROLS.ITEM': 'Use Item',
    'MENU.SETTINGS.CONTROLS.OPENQUESTLOG': 'Open Quest Log',

    'MENU.KNOWLEDGE.UNLOCK': 'Unlock Knowledge',
    'MENU.KNOWLEDGE.PRICE': '({price} Oxygen)',

    'MENU.KNOWLEDGE.LEVEL': 'Level: {LEVEL}',
    'MENU.KNOWLEDGE.XP': 'XP: {XP}',

    'KEY.SPACE': 'Spacebar',


    'CONFIRM.SURE': 'Are you sure you want to continue?',
    'CONFIRM.YES': 'Yes',
    'CONFIRM.NO': 'No',

    'SAVE_SLOT.DELETE': 'Are you sure you want to delete this save?',
    'SAVE_SLOT.EMPTY': '(Empty Save Slot)',
    'LOCATION': 'Location',

    'CREDITS.GAME_DESIGNER': 'Game Designer / Programmer',
    'CREDITS.GRAPHIC': 'Graphics',
    'CREDITS.MUSIC': 'Music',
    'CREDITS.LANGS': 'Translation',
    'CREDITS.SPECIAL_THANKS': 'Special Thanks',
    'CREDITS.BALANCE': 'Game Balance',


    'STAT.LEVEL': 'Level',
    'STAT.LIFE': 'Life',
    'STAT.EXP': 'Exp',
    'STAT.SP': 'SP',
    'STAT.ATTACK_RANGE': 'Attack Range',

    'DEATH_SCREEN.RESPAWN': 'Click to respawn',

    [GRADE.NORMAL]: '',
    'NORMAL': 'Normal',
    [GRADE.COMMON]: 'Common',
    [GRADE.RARE]: 'Rare',
    [GRADE.MYTHICAL]: 'Mythical',
    [GRADE.LEGENDARY]: 'Legendary',

    [GRADE.ANGELIC]: 'Angelic',
    [GRADE.DEMONIC]: 'Demonic',
    [GRADE.DIVINE]: 'Divine',
    [GRADE.TRANSCENDENTAL]: 'Transcendental',



    [STAT.ATTACK_DAMAGE]: "Damage",
    [STAT.MAX_HP]: "Max HP",
    [STAT.ATTACK_RANGE]: "Range",
    [STAT.ATTACK_SPEED]: "Attack Speed",

    [STAT.COOLTIME]: "Cool down",
    [STAT.DURATION]: "Duration",

    [STAT.CR]: "Critical Chance",
    [STAT.CD]: "Critical Damage",

    [STAT.HARDNESS]: "Hardness",
    [STAT.POWER]: "Power",
    [STAT.DEXTERITY]: "Dexterity",
    [STAT.CHARGE]: "Charge",
    [STAT.AMMO_COST]: "Ammo Cost",

    [STAT.DEFENSE]: "Defense",
    [STAT.BULLETS_COUNT]: "Bullets",
    [STAT.SUMMON_DAMAGE]: 'Summon Damage',
    [STAT.BLOCK_CHANCE]: 'Block Chance',
    [STAT.ELEMENTAL_MASTERY]: 'Elemental Mastery',

    [STAT.DAMAGE_ICE]: 'Ice Damage',
    [STAT.DAMAGE_FIRE]: 'Fire Damage',
    [STAT.DAMAGE_THUNDER]: 'Thunder Damage',
    [STAT.DAMAGE_POISON]: 'Poison Damage',

    [STAT.DASH_DURATION]: 'Dash Duration',
    [STAT.DASH_COOLTIME]: 'Dash Cool down',
    [STAT.DASH_DISTANCE]: 'Dash Distance',

    'TEXT.BLOCK': 'Block!',
    'TEXT.INVINCIBLE': 'Invincible!',
    'TEXT.NOT_ENOUGH_OXYGEN': 'Not enough oxygen!',

    'STAT.DEFENSE.TITLE': "You take {def} points of physical damage less and all the non-physical damage gets reduced by {reduction}%.",

    'SP.HARDNESS.TITLE': "Increases Defense by {value}.",
    'SP.POWER.TITLE': "Increases Attack Damage by {value}%.",
    'SP.DEXTERITY.TITLE': "Increases Attack Speed by {value}%.",
    'SP.CHARGE.TITLE': "Increases the number of charges gained from attacks. Currently: {value}.",
    'SP.AMMO_COST.TITLE': "Reduces the amount of Oxygen required to use a weapon by {value}.",
    
    'DIFFICULTY': 'Difficulty',

    'DIFFICULTY.EASY.NAME': 'Easy',
    'DIFFICULTY.EASY.DESCRIPTION': 'Enemies deal only {DamageMultiplierP}% of damage.\nNo death penalty.',

    'DIFFICULTY.MEDIUM.NAME': 'Medium',
    'DIFFICULTY.MEDIUM.DESCRIPTION': 'Enemies deal {DamageMultiplierP}% of damage.\nIf you get killed you lose:\n-{DeathPenaltyXp}% of exp',

    'DIFFICULTY.HARD.NAME': 'Hard',
    'DIFFICULTY.HARD.DESCRIPTION': 'Enemies are smarter (at least a few of them).\nEnemies deal {DamageMultiplierP}% of damage.\nIf you get killed you lose:\n-{DeathPenaltyXp}% of exp\n-{DeathPenaltyOxygen}% of Oxygen',


    'TUTORIAL.INFO.1': 'Welcome to Bubble Wars!',
    'TUTORIAL.INFO.2': 'Use WASD to move.',
    'TUTORIAL.INFO.3': 'Use LMB to shoot.',
    'TUTORIAL.INFO.4': "Oh no, you can't go any farther from here. Try to search for a way around!",
    'TUTORIAL.INFO.5': "Defeat all the enemies!",
    'TUTORIAL.INFO.6': "Great job!",
    'TUTORIAL.INFO.7': "Pick up this Item.",
    'TUTORIAL.INFO.8': "Open inventory[E] to enchant and equip your new weapon.",

    'TUTORIAL.INFO.9': "Open Minimap[Tab] and teleport to the Starting Room",
    'TUTORIAL.INFO.10': "Press [C] button and upgrade your Power stat!",
    'TUTORIAL.INFO.11': "Get ready for a boss fight!",
    'TUTORIAL.INFO.12': "Let`s find the boss!",

   'LOCATION.BOSS_ARENA.NAME': 'Boss Arena',
   'LOCATION.VILLAGE.NAME': 'Village',
   'LOCATION.TUTORIAL.NAME': 'Paddling Pool',

   'LOCATION.LAKE.1.NAME': 'Lake 1',
   'LOCATION.LAKE.2.NAME': 'Lake 2',
   'LOCATION.LAKE.3.NAME': 'Lake 3',
   'LOCATION.LAKE.4.NAME': 'Lake 4',
   'LOCATION.LAKE.5.NAME': 'Lake 5',
   'LOCATION.LAKE.6.NAME': 'Lake 6',
   'LOCATION.LAKE.7.NAME': 'Lake 7',
   'LOCATION.LAKE.8.NAME': 'Lake 8',

   'LOCATION.BEEHIVE.NAME': 'Beehive',
   'LOCATION.THE_COVE.NAME': 'The Cove',

   'LOCATION.CAVERN.1.NAME': 'Cavern 1',
   'LOCATION.CAVERN.2.NAME': 'Cavern 2',
   'LOCATION.CAVERN.3.NAME': 'Cavern 3',
   'LOCATION.CAVERN.4.NAME': 'Cavern 4',
   'LOCATION.CAVERN.5.NAME': 'Cavern 5',
   'LOCATION.CAVERN.6.NAME': 'Cavern 6',

    


    //Items Lore
    ITEM_SHADOW_SCYTHE_LORE: "Super Scythe,\nfrom another world",
    ITEM_BUBBLE_TERMINATOR_LORE: "It will kill,\nIt will destroy the world,\nNo matter what you do it won`t stop!",
    ITEM_HOLY_LAUNCHER_LORE: "Holy Gaucamole!!!",



    'ITEM.SLOWING.DESCRIPTION': 'Slowness power: {SLOW_S}%\nSlowness duration: {SLOW_D}s',


    'ITEM.CLICK_TO_OPEN.RIGHT': "RMB to open.",
    'ITEM.BAG.DESCRIPTION': "May contain:",
    'ITEM.QUEST.DESCRIPTION': 'Quest Item',
    'ITEM.UNIQUE': 'Unique',

    'ITEM.SUMMON_SCROLL.NAME': 'Summon Scroll ({BOSS_NAME})',
    'ITEM.SUMMON_SCROLL.DESCRIPTION': 'This scroll contains sealed soul of <--color-grade-mythical;{BOSS_NAME}>.\nMake sure you are ready for battle before summoning the boss.\nCan only be used at the Boss Arena.',

    'ITEM.BAG.THEFATONE.NAME': '<#ff00ff>The Fat One`s Bag',

    'ITEM.BAG.DEV.NAME': 'Developer`s Treasure Orb',
    'ITEM.BAG.STARTER.NAME': 'Starter Treasure Orb',
    'ITEM.BAG.OXY_CELL.NAME': 'Treasure Orb (Oxy-Cell)',
    'ITEM.BAG.TRIMAGO.NAME': 'Treasure Orb (Trimago)',
    'ITEM.BAG.THE_FAT_ONE.NAME': 'Treasure Orb (The Fat One)',
    'ITEM.BAG.WATERFLY.NAME': 'Treasure Orb (Waterfly)',
    'ITEM.BAG.BUBBLEBEE.NAME': 'Treasure Orb (Bubblebee)',
    'ITEM.BAG.FROGO.NAME': 'Treasure Orb (Frogo)',
    'ITEM.BAG.AQUAMANTULA.NAME': 'Treasure Orb (Aquamantula)',
    'ITEM.BAG.CELLTIPEDE.NAME': 'Treasure Orb (Celltipede)',

    'ITEM.ESSENCE_EXTRACTOR.NAME': 'Essence Extractor',
    'ITEM.ESSENCE_EXTRACTOR.PERMANENT.NAME': 'Permanent Essence Extractor',
    'ITEM.ESSENCE_GRADE.DESCRIPTION': "Contains powerful energy of {GRADE} tier equipment.",
    'ITEM.ESSENCE_EXTRACTOR.DESCRIPTION': "Drop on an item to extract its grade.\n<--color-item-negative>Be careful! Item`s grade will be set back to Normal!",
    'ITEM.LIQUID_OXYGEN.DESCRIPTION': "<--color-grade-rare>RMB to extract {PRICE} Oxygen bubbles.",

    'ITEM.BLESSING_STONE.NAME': 'Blessing Stone',
    'ITEM.BLESSING_STONE.DESCRIPTION': "Drop on an item to increase its grade.\nCan only be used on {GRADE} tier equipment.",
    'ITEM.BLESSING_STONE.DESCRIPTION.2': "Drop on an item to increase its grade.\nCan only be used on {GRADE}/{GRADE2} tier equipment.",

    'ITEM.BLESSING_STONE.BROKEN.NAME': 'Broken Blessing Stone',
    'ITEM.BLESSING_STONE.BROKEN.DESCRIPTION': "A Blessing Stone that has lost its properties.\nHowever, it can still be useful.",

    'ITEM.CONCENTRATED_AURA.BOSS.NAME': 'Concentrated Boss Aura',
    'ITEM.CONCENTRATED_AURA.BOSS.DESCRIPTION': 'Concentrated aura coming from within the Bosses` Cores.\nIt contains mighty energy.',

    'ITEM.CONCENTRATED_AURA.NAME': 'Concentrated Aura',
    'ITEM.CONCENTRATED_AURA.DESCRIPTION': 'Drop on your Core to increase its grade.\nCan only be used on {GRADE} tier Cores.',

    'ITEM.OXYGEN.NAME': 'Oxygen',
    'ITEM.LIQUID_OXYGEN.NAME': 'Liqud Oxygen',

    'ITEM.APPEARANCE_BOX.NAME': 'Unknown Appearance Box',
    'ITEM.APPEARANCE_BOX.DESCRIPTION': 'RMB to obtain one of the following Appearance Boxes:',

    'ITEM.APPEARANCE_BOX.FIXED.NAME': '{TYPE} Appearance Box',

    'ITEM.ENCHANT.LOCK.NAME': '<gray>Locked Slot',
    'ITEM.ENCHANT.GEM.AD.NAME': 'Enchanted Gem (Attack)',
    'ITEM.ENCHANT.GEM.HP.NAME': 'Enchanted Gem (Health)',
    'ITEM.ENCHANT.GEM.DEF.NAME': 'Enchanted Gem (Defense)',
    'ITEM.ENCHANT.GEM.SPD.NAME': 'Enchanted Gem (Speed)',
    'ITEM.ENCHANT.GEM.CHARGE.NAME': 'Enchanted Gem (Charge)',
    'ITEM.ENCHANT.GEM.AD.P.NAME': 'Enchanted Gem (Attack %)',
    'ITEM.ENCHANT.GEM.AS.NAME': 'Enchanted Gem (Attack Speed)',

    'ITEM.HOLY_STONE.BULLET.NAME': 'Sacred Stone (Bullet)',
    'ITEM.HOLY_STONE.ATTACK_SPEED.NAME': 'Sacred Stone (Attack Speed)',
    'ITEM.HOLY_STONE.RANGE.NAME': 'Sacred Stone (Attack Range)',

    'ITEM.ENCHANT.GEM.DESCRIPTION': 'Drop on an Item to enchant it.',

    'ITEM.ENCHANT.SAPPHIRE.NAME': 'Sapphire',
    'ITEM.ENCHANT.RUBY.NAME': 'Ruby',
    'ITEM.ENCHANT.EMERALD.NAME': 'Emerald',
    'ITEM.ENCHANT.TOPAZ.NAME': 'Topaz',


    'ITEM.THE_VIRTUOSO.NAME': 'The Virtuoso',
    'ITEM.THE_VIRTUOSO.LORE': 'It never hurt anyone.\nIt is the performance that kills.',
    'ITEM.THE_VIRTUOSO.DESCRIPTION': 'Every 4th attack deals 4x higher damage\nand can pierce through up to 4 units.',

    'ITEM.MACHINE_GUN.BASE.NAME': 'Bubble Machine Gun I',


    'ITEM.BAMBOO_STICK.NAME': 'Bamboo Stick',
    'ITEM.BAMBOO_STICK.LORE': 'Legend has it that the Bamboo Stick used by a professional\nis far greater of a weapon than the Enchanted Blade.',
    'ITEM.BAMBOO_STICK.DESCRIPTION': 'Charge Effect: Recovers 1 HP on enemy hit.',

    'ITEM.VIVISCISSORS.NAME': 'ViVi`s Golden Scissors',
    'ITEM.VIVISCISSORS.DESCRIPTION': 'High-class scissors made out of pure gold.\nLong awaited by their former owner to return to her.',

    'ITEM.CORE.BASE.NAME': 'Vital Core',
    'ITEM.CORE.BASE.DESCRIPTION': 'A basic Core that prolongs the vitality of the body.',
    'ITEM.CORE.BASE.LORE': 'The core gives life to every living being.\nThis is the storage for all the memories.\nDo not abandon it.',

    'ITEM.WATER_TWISTER.NAME': 'Water Twister',
    'ITEM.WATER_TWISTER.DESCRIPTION': 'Press [{KEY}] to summon the Water Twister.\nEnemies who pass through\nwill be slowed down by {SLOW_S}% for {SLOW_D}s.',

    'ITEM.INFINITY_STONE.SPACE.NAME': 'Infinity Stone of Space',
    'ITEM.INFINITY_STONE.SPACE.DESCRIPTION': 'Allows the teleportation to every cleared room.\nPress [{KEY}] to shift towards the cursor.\nDistance: {R}\nCool down: {CD}s',
    'ITEM.INFINITY_STONE.SPACE.LORE': 'The stone that arrived from another universe.\nOnly a few can harness its power.',

    'ITEM.ENCHANT.CRYSTAL.AD.NAME': 'Enchanted Crystal (Attack)',
    'ITEM.ENCHANT.CRYSTAL.DEF.NAME': 'Enchanted Crystal (Defense)',
    'ITEM.ENCHANT.CRYSTAL.BLOCK.NAME': 'Enchanted Crystal (Block)',
    'ITEM.ENCHANT.CRYSTAL.MASTERY.NAME': 'Enchanted Crystal (Elemental Mastery)',
    'ITEM.ENCHANT.CRYSTAL.DESCRIPTION': 'Drop on an accessory to enchant.',
    'ITEM.ENCHANT.CRYSTAL.BLOCK.DESCRIPTION': 'Block Chance is capped at 50%.\nDrop on an accessory to enchant.',
    'ITEM.ENCHANT.CRYSTAL.MASTERY.DESCRIPTION': 'Elemental Mastery increases your damage of every element.\nDrop on an accessory to enchant.',

    'ITEM.ROCKET_LAUNCHER.SPARK.NAME': 'Spark Launcher I',
    'ITEM.ROCKET_LAUNCHER.1.NAME': 'Rocket Launcher I',

    'ITEM.PET.FROGO.NAME': 'Little Frogo',
    'ITEM.PET.FROGO.DESCRIPTION': 'Summons a tiny Frogo to fight for you.',

    'ITEM.RIFLE.1.NAME': 'Bubble Rifle I',

    'ITEM.CANON.BUBBLE.1.NAME': 'Bubble Cannon I',
    'ITEM.CANON.BUBBLE.2.NAME': 'Bubble Cannon II',


    'ITEM.ICICLE.1.NAME': 'Frozen Orb I',

    'ITEM.FLOW_IN_BOTTLE.NAME': 'Flow in a bottle',
    'ITEM.FLOW_IN_BOTTLE.DESCRIPTION': 'Press [RMB] to dash.',

    'ITEM.RING.PHYSICAL.NAME': 'Mysterious Ring',

    'ITEM.NECKLACE.REGENERATION.NAME': 'Mysterious Necklace',
    'ITEM.NECKLACE.REGENERATION.DESCRIPTION': 'Recovers {REGEN} HP each time you clear a room.',


    'ITEM.HONEY.COMB.NAME': 'Honeycomb',
    'ITEM.HONEY.COMB.DESCRIPTION': 'Super sweet honeycomb made by bubblebees.\nWho knows what could happen,\nif you give it back to them.\n\nRMB to recover {REGEN}HP in {TIME}s.',

    'ITEM.HONEY.PIECE.NAME': 'Honey chunk',
    'ITEM.HONEY.PIECE.DESCRIPTION': 'Super sweet honey chunk.\n\nRMB to summon Honey Drop.',

    'ITEM.THE_ECHO.NAME': 'The Echo',




















    'SKIN.BASE.NAME': 'Base',
    'SKIN.BASE.F.NAME': 'Base (F)',

    'SKIN.KITSUNE.NAME': 'Kitsune',
    'SKIN.KITSUNE.ANGELIC.NAME': 'Angelic Kitsune',
    'SKIN.KITSUNE.SHADOWFLAME.NAME': 'Shadowflame Kitsune',

    'SKIN.REAPER.NAME': 'The Reaper',
    'SKIN.CATGIRL.NAME': 'Catgirl',



    //npc
    NPC_MERCHANT_NAME: 'Merch Guy',


    'DIALOG.EXIT': 'See you.',

    'NPC.SENSEI.NAME.0': 'Wii Sensei',
    'NPC.SENSEI.NAME.1': 'Jhones Sensei',
    'NPC.SENSEI.NAME.2': 'Yan Ying Sensei',
    'NPC.SENSEI.NAME.3': 'Splitter Sensei',

    'NPC.SENSEI.DIALOG.1' :"This combat lesson has definitely improved your skills of... combat.",




    'NPC.MINER.NAME.0': 'Bob the Miner',
    'NPC.MINER.NAME.1': 'Jeff the Miner',
    'NPC.MINER.NAME.2': 'Hugo the Miner',
    'NPC.MINER.NAME.3': 'Pablo the Miner',


    'NPC.MAGE.NAME.0': 'Sabrine',
    'NPC.MAGE.NAME.1': 'Twilight',
    'NPC.MAGE.NAME.2': 'Megan',
    'NPC.MAGE.NAME.3': 'Selene',


    'NPC.MINER.DIALOG.0': "Heigh-ho! Heigh-ho! It's home from work I... What? Who are you? Oh, nevermind. I oughta mine out this big jewel. Here, take that torchlight and help me. (Three swings of a pickaxe later)\
    Damn, is it that hard to keep a torchlight leveled?! Sorry, too much work for today. The name is {NAME}.",
        'NPC.MINER.DIALOG.0.OPTION.1': 'Nice to meet you.',
    'NPC.MINER.DIALOG.1': 'Do you have any junk for me?',
        'NPC.MINER.DIALOG.1.OPTION.1': 'Show me your wares!',

    'NPC.MAGE.DIALOG.0' :"Watch your steps! I am {NAME}, the greatest sorceress of all times! (Her staff drops on the floor) Oh! You didn`t see that, did you?",
        'NPC.MAGE.DIALOG.0.OPTION.1': 'Nice to meet you.',
    'NPC.MAGE.DIALOG.1' :"I was trying to acquire some pentafluoroxenone hexafluororutenate, but it became a liquid oxygen overnight. Where did I go wrong?",
    'NPC.MAGE.DIALOG.2' :"Don't worry about the mess. I've made some sparkling water, though I didn't expect a spark to make the whole village blow up...",
    'NPC.MAGE.DIALOG.3' :"That blast from earlier? Oh, no need to worry! I just got the ingredients wrong...",



    'NPC.STYLIST.NAME': 'Vivi',
    'NPC.STYLIST.DIALOG.0': 'Oh, my... I finally see a friendly face... I got stuck here with this big... thing, for almost a month! I`m Vivi by the way, nice to meet you, darling!',
        'NPC.STYLIST.DIALOG.0.OPTION.1': 'It`s my pleasure.',
    'NPC.STYLIST.DIALOG.1': 'What`s up, sweetie?',
    'NPC.STYLIST.DIALOG.2': 'How is it going, my love?',

    'NPC.STATUE.NAME': 'Ancient Statue',
    'NPC.STATUE.DIALOG.0': '(Shady-looking statueue...)',
    'NPC.STATUE.DIALOG.0.OPTION.1': 'Touch...',

    'NPC.STATUE.DIALOG.1': '(You feel unpleasant aura emanating from a stone silhouette)',
    'NPC.STATUE.DIALOG.1.OPTION.1': 'Boss Arena',
    'NPC.STATUE.DIALOG.1.OPTION.2': 'Sacrifice',

    'NPC.STATUE.DIALOG.SACRIFICE': 'Do you want to sacrifice all of your Oxygen?',
    'NPC.STATUE.DIALOG.SACRIFICE.OPTION.1': 'Yeah!',
    'NPC.STATUE.DIALOG.SACRIFICE.EXIT': 'Not really, no.',





    'ENTITY.BUBBLE.NAME': 'Bubble',

    'ENTITY.BUBBLE_FORMATION.1.NAME': 'Bubble formation I',
    'ENTITY.BUBBLE_FORMATION.2.NAME': 'Bubble formation II',
    'ENTITY.BUBBLE_FORMATION.3.NAME': 'Bubble formation III',
    'ENTITY.BUBBLE_FORMATION.4.NAME': 'Bubble formation IV',
    'ENTITY.BUBBLE_FORMATION.5.NAME': 'Bubble formation V',

    'ENTITY.TRIM.NAME': 'Trim',
    'ENTITY.TRIM.FAT.NAME': 'Fat Trim',
    'ENTITY.TRIM.FORMATION.0.NAME': 'Trim Formation I',




    'ENTITY.TADPOLE.LAKE.NAME': 'Lake Tadpole',
    'ENTITY.FROG.LAKE.NAME': 'Lake Frog',
    'ENTITY.FROG.LAKE.GREEN.NAME': 'Green Lake Frog',
    'ENTITY.FROGO.NAME': 'Frogo',
    'ENTITY.FROGO.PET.NAME': 'Little Frogo',

    'ENTITY.OXY_CELL.NAME': 'Oxy-Cell',
    'ENTITY.TRIMAGO.NAME': 'Trimago',
    'ENTITY.THE_FAT_ONE.NAME': 'The Fat One',

    'ENTITY.WATERFLY.NAME': 'Waterfly',

    'ENTITY.HONEY.CHUNK.NAME': 'Honey Chunk',
    'ENTITY.HONEYCOMB.NAME': 'Honeycomb',
    'ENTITY.BEE.LAKE.LITTLE.NAME': 'Little Lake Bee',
    'ENTITY.BEE.LAKE.LARGE.NAME': 'Lake Bee',
    'ENTITY.BUBBLEBEE.NAME': 'Bubblebee',
    'ENTITY.BUBBLEBEE.QUEEN.NAME': 'Bubblebee Queen',

    'ENTITY.SPIDER.LAKE.NAME': 'Lake Spider',
    'ENTITY.SPIDER.LITTLE.LAKE.NAME': 'Little Lake Spider',
    'ENTITY.SPIDER.DASHING.LAKE.NAME': 'Dashing Lake Spider',

    'ENTITY.SPIDER.LAKE.DESCRIPTION': "This enemy lays eggs. If they don't get exterminated, the room will swarm with Little Lake Spiders.\n\nOnce it does, you will die.",
    'ENTITY.SPIDER.LITTLE.LAKE.DESCRIPTION': 'This foe is really quick. Once you get in its range, it will jump in your face and will not let go easily. If kept alive for too long, it will grow and lay eggs.\n\nOnce it does, you will die.',
    'ENTITY.SPIDER.DASHING.LAKE.DESCRIPTION': 'This enemy is fairly quick. When provoked, it starts dashing. Stuns on hit.\n\nThis is how you will probably die.',

    'ENTITY.SPIDER.LAKE.QUEEN.NAME': 'Aquamantula',
    'ENTITY.SPIDER.LAKE.QUEEN.DESCRIPTION': 'Giant spider queen that wants to feed you to her offspring. Lays eggs and dashes when enraged. Try to get her to hit the wall or slow her down, or else you will face her wrath.\n\nWhich means you will die.',

    'ENTITY.CELLTIPEDE.NAME': 'Celltipede',

    'ENTITY.COVE.FISH.POISON.NAME': 'Poisoning Cove Guardian',
    'ENTITY.COVE.FISH.FIRE.NAME': 'Blazing Cove Guardian',
    'ENTITY.COVE.FISH.ICE.NAME': 'Frozen Cove Guardian',
    'ENTITY.THE_COVE_GUARDIAN.NAME': 'The Cove Guardian',



    'ENTITY.BAT.NAME': 'blue Bat',
    'ENTITY.BAT.FAT.NAME': 'Fat blue Bat',
    'ENTITY.BAT.BLIND.NAME': 'Blind blue Bat',
    'ENTITY.ZUBATH.NAME': 'Zubath',












    'QUEST.COMPLETE': 'Complete',
    'QUEST.ACCEPT': 'Accept',
    'QUEST.DECLINE': 'Decline',



    'QUEST.LEVELUP.1.NAME': 'Road to Greatness I',
    'QUEST.LEVELUP.1.DESCRIPTION': 'This underwater world is full of dangers and filthy creatures. You have to gain some experience in order to stand a change against them. Reach Level 10 and report back to Sensei.',
    'QUEST.LEVELUP.1': 'Our world overflows with various nasty monsters. You must get stronger if you want to survive. Here`s the job:\n-Reach Level 10 and come back to me.',
    'QUEST.LEVELUP.1.COMPLETE': 'It took you long enough. Oh well, being a superhero isn`t for everyone. This is your reward:\n-Bamboo Stick.',

    'QUEST.LEVELUP.2.NAME': 'Road to Greatness II',
    'QUEST.LEVELUP.2.DESCRIPTION': 'Sensei still sees you as beginner. Reach Level 20 and prove him wrong.',
    'QUEST.LEVELUP.2': 'You`re still novice. Sad matter indeed. Here`s the job:\n-Reach Level 20 and come back to me.',
    'QUEST.LEVELUP.2.COMPLETE': 'It takes a lot to be that slow. Try not to die and it will go faster. Nevertheless, you did it. This is your reward.',

    'QUEST.LEVELUP.3.NAME': 'Road to Greatness III',
    'QUEST.LEVELUP.3.DESCRIPTION': 'You started believing that there is some meaning in your work. Sensei disagrees. Reach Level 30 and show him your true power.',
    'QUEST.LEVELUP.3': 'Your work so far was quite... Mediocre, you need to do better. Here`s the job:\n-Reach Level 30 and come back to me.',
    'QUEST.LEVELUP.3.COMPLETE': 'I`ve seen turtles finishing it faster, and they weren`t the ninja ones. I`m disappointed in you, but I shall get you some help. This is your reward.',



    'QUEST.VIVISCISSORS.NAME': 'Vivi`s Issues',
    'QUEST.VIVISCISSORS.DESCRIPTION': 'While being chased by spiders, the charming stylist, Vivi, lost her favourite scissors. Make way to the Lake 7 and bring it back.',
    'QUEST.VIVISCISSORS': 'So good to see you, my love! You`re not going to believe what I`ve been through! During my last visit in the Lake, these nasty spiders noticed me and started chasing me down! \
        That`s when I lost my gorgeous scissors, could you please find them?\n-Go to the Lake 7 and bring this item back.',

    'QUEST.VIVISCISSORS.COMPLETE': 'Oh! You made it! I`m so happy right now, you have no idea! This is your reward:\n-XP: 1.500\n-Oxygen: 20.000\n-Unknown Appearance Box',









    'DEATH_QUOTE.CORE_DROP': 'You literally took out your heart and threw it away...',












    //GUI
    OXYGEN: 'Oxygen',
    WORLD_MAP: 'World Map'
};LANGS["PL"] =
{
    'MENU.START': 'Graj',
    'MENU.TESTING_CHAMBER': 'Komora testowa',
    'MENU.LOADING.READY': 'Kliknij, aby rozpocząć',
    'MENU.SETTINGS': 'Ustawienia',
    'MENU.QUIT': 'Wyjdź',
    'MENU.CONTINUE': 'Kontynuuj',
    'MENU.CREDITS': 'Twórcy & Źródła',

    'MENU.SETTINGS.GENERAL': 'Ogólne',
    'MENU.SETTINGS.AUDIO': 'Dźwięk',
    'MENU.SETTINGS.VIDEO': 'Grafika',
    'MENU.SETTINGS.CONTROLS': 'Sterowanie',

    'MENU.SETTINGS.GENERAL.SHOWDAMAGEDEALT': 'Pokaż zadawane obrażenia',
    'MENU.SETTINGS.GENERAL.SHOWDAMAGERECEIVED': 'Pokaż otrzymywane obrażenia',

    'MENU.SETTINGS.GENERAL.SHOWMINIMAP': 'Pokaż minimapę',
    'MENU.SETTINGS.GENERAL.SHOWRADAR': 'Pokaż radar',
    'MENU.SETTINGS.GENERAL.SHOWITEMPRICE': 'Pokaż ceny przedmiotów',
    'MENU.SETTINGS.GENERAL.ALLOWWINDOWDRAG': 'Ruchome okienka',
    'MENU.SETTINGS.GENERAL.ALWAYSREPOSEWINDOWS': 'Resetuj pozycję okienek',

    

    'MENU.SETTINGS.AUDIO.VOLUME.OVERALL': 'Głośność ogólna',
    'MENU.SETTINGS.AUDIO.VOLUME.MUSIC': 'Głośność muzyki',
    'MENU.SETTINGS.AUDIO.VOLUME.EFFECTS': 'Głośność efektów',

    'MENU.SETTINGS.APPLY': 'Zastosuj',
    'MENU.SETTINGS.RESET': 'Przywróć domyślne',

    'MENU.SETTINGS.VIDEO.FULLSCREEN': 'Pełny ekran',
    'MENU.SETTINGS.VIDEO.RESOLUTION': 'Rozdzielczość',
    'MENU.SETTINGS.VIDEO.UI_SCALE': 'Skala interfejsu',

    'MENU.SETTINGS.CONTROLS.PLAYERMOVEUP': 'Ruch w górę',
    'MENU.SETTINGS.CONTROLS.PLAYERMOVEDOWN': 'Ruch w dół',
    'MENU.SETTINGS.CONTROLS.PLAYERMOVELEFT': 'Ruch w lewo',
    'MENU.SETTINGS.CONTROLS.PLAYERMOVERIGHT': 'Ruch w prawo',

    'MENU.SETTINGS.CONTROLS.ALWAYSDASHTOWARDCURSOR': 'Zawsze unikaj w stronę kursora',
    'MENU.SETTINGS.CONTROLS.SKILL': 'Użyj przedmiotu specjalnego',
    'MENU.SETTINGS.CONTROLS.OPENINVENTORY': 'Otwórz ekwipunek',
    'MENU.SETTINGS.CONTROLS.OPENMINIMAP': 'Otwórz mini mapę',
    'MENU.SETTINGS.CONTROLS.OPENMAP': 'Otwórz mapę świata',
    'MENU.SETTINGS.CONTROLS.OPENSTATS': 'Otwórz statystyki',
    'MENU.SETTINGS.CONTROLS.INTERACT': 'Interakcja',
    'MENU.SETTINGS.CONTROLS.ITEM': 'Użyj przedmiotu',
    'MENU.SETTINGS.CONTROLS.OPENQUESTLOG': 'Otwórz dziennik zadań',

    'MENU.KNOWLEDGE.UNLOCK': 'Odblokuj wiedzę',
    'MENU.KNOWLEDGE.PRICE': '({price} Tlenu)',

    'MENU.KNOWLEDGE.LEVEL': 'Poziom: {LEVEL}',
    'MENU.KNOWLEDGE.XP': 'XP: {XP}',

    'KEY.SPACE': 'Spacja',


    'CONFIRM.SURE': 'Na pewno chcesz kontynuować?',
    'CONFIRM.YES': 'Tak',
    'CONFIRM.NO': 'Nie',

    'SAVE_SLOT.DELETE': 'Na pewno chcesz usunąć ten zapis?',
    'SAVE_SLOT.EMPTY': '(Pusty zapis)',
    'LOCATION': 'Lokalizacja',

    'CREDITS.GAME_DESIGNER': 'Twórca gry / programista',
    'CREDITS.GRAPHIC': 'Grafika',
    'CREDITS.MUSIC': 'Muzyka',
    'CREDITS.LANGS': 'Tłumaczenie',
    'CREDITS.SPECIAL_THANKS': 'Specjalne podziękowania',
    'CREDITS.BALANCE': 'Balans rozgrywki',


    'STAT.LEVEL': 'Poziom',
    'STAT.LIFE': 'Życie',
    'STAT.EXP': 'Exp',
    'STAT.SP': 'PS',
    'STAT.ATTACK_RANGE': 'Zasięg ataku',

    'DEATH_SCREEN.RESPAWN': 'Naciśnij, aby wskrzesić',

    [GRADE.NORMAL]: '',
    'NORMAL': 'Zwykły',
    [GRADE.COMMON]: 'Pospolity',
    [GRADE.RARE]: 'Rzadki',
    [GRADE.MYTHICAL]: 'Mityczny',
    [GRADE.LEGENDARY]: 'Legendarny',

    [GRADE.ANGELIC]: 'Anielski',
    [GRADE.DEMONIC]: 'Demoniczny',
    [GRADE.DIVINE]: 'Boski',
    [GRADE.TRANSCENDENTAL]: 'Nadprzyrodzony',



    [STAT.ATTACK_DAMAGE]: "Obrażenia",
    [STAT.MAX_HP]: "Maksymalne życie",
    [STAT.ATTACK_RANGE]: "Zasięg",
    [STAT.ATTACK_SPEED]: "Prędkość ataku",

    [STAT.COOLTIME]: "Czas odnowienia",
    [STAT.DURATION]: "Czas trwania",

    [STAT.CR]: "Szansa na cios kryt.",
    [STAT.CD]: "Obrażenia ciosu kryt.",

    [STAT.HARDNESS]: "Twardość",
    [STAT.POWER]: "Siła",
    [STAT.DEXTERITY]: "Zręczność",
    [STAT.CHARGE]: "Ładunek",
    [STAT.AMMO_COST]: "Koszt amunicji",

    [STAT.DEFENSE]: "Obrona",
    [STAT.BULLETS_COUNT]: "Pociski",
    [STAT.SUMMON_DAMAGE]: 'Obrażenia przyw.',
    [STAT.BLOCK_CHANCE]: 'Szansa na blok',
    [STAT.ELEMENTAL_MASTERY]: 'Siła żywiołów',

    [STAT.DAMAGE_ICE]: 'Obrażenia lodu',
    [STAT.DAMAGE_FIRE]: 'Obrażenia ognia',
    [STAT.DAMAGE_THUNDER]: 'Obrażenia błyskawic',
    [STAT.DAMAGE_POISON]: 'Obrażenia trucizn',

    [STAT.DASH_DURATION]: 'Czas trwania uniku',
    [STAT.DASH_COOLTIME]: 'Czas odnowienia uniku',
    [STAT.DASH_DISTANCE]: 'Długość uniku',

    'TEXT.BLOCK': 'Blok!',
    'TEXT.INVINCIBLE': 'Nietykalność!',

    'STAT.DEFENSE.TITLE': "Otrzymujesz o {def} punktów mniej obrażeń fizycznych oraz zmniejszasz wszelkie inne typy uszkodzeń o {reduction}%.",

    'SP.HARDNESS.TITLE': "Zwiększa obronę o {value}.",
    'SP.POWER.TITLE': "Zwiększa obrażenia o {value}%.",
    'SP.DEXTERITY.TITLE': "Zwiększa prędkość ataku o {value}%.",
    'SP.CHARGE.TITLE': "Zwiększa liczbę ładunków otrzymywanych z ataków. Obecnie: {value}.",
    'SP.AMMO_COST.TITLE': "Zmniejsza ilość Tlenu potrzebnego do użycia broni o {value}.",
    
    'DIFFICULTY': 'Poziom trudności',

    'DIFFICULTY.EASY.NAME': 'Łatwy',
    'DIFFICULTY.EASY.DESCRIPTION': 'Przeciwnicy zadają jedynie {DamageMultiplierP}% obrażeń.\nŚmierć nie niesie ze sobą poważniejszych konsekwencji.',

    'DIFFICULTY.MEDIUM.NAME': 'Normalny',
    'DIFFICULTY.MEDIUM.DESCRIPTION': 'Przeciwnicy zadają {DamageMultiplierP}% obrażeń.\nW chwili śmierci stracisz:\n-{DeathPenaltyXp}% doświadczenia',

    'DIFFICULTY.HARD.NAME': 'Trudny',
    'DIFFICULTY.HARD.DESCRIPTION': 'Przeciwnicy są mądrzejsi (przynajmniej niektórzy).\nPrzeciwnicy zadają {DamageMultiplierP}% obrażeń.\nW chwili śmierci stracisz:\n-{DeathPenaltyXp}% doświadczenia\n-{DeathPenaltyOxygen}% Tlenu',


    'TUTORIAL.INFO.1': 'Witaj w Bubble Wars!',
    'TUTORIAL.INFO.2': 'Użyj WSAD, aby się poruszać.',
    'TUTORIAL.INFO.3': 'Użyj LPM, aby strzelać.',
    'TUTORIAL.INFO.4': "Och nie, tędy nie przejdziesz. Szukaj innej drogi!",
    'TUTORIAL.INFO.5': "Pokonaj wszystkich przeciwników!",
    'TUTORIAL.INFO.6': "Świetna robota!",
    'TUTORIAL.INFO.7': "Podnieś ten przedmiot.",
    'TUTORIAL.INFO.8': "Otwórz ekwipunek[E], aby wzmocnić i założyć nową broń.",

    'TUTORIAL.INFO.9': "Otwórz minimapę[Tab] i przenieś się do pokoju startowego.",
    'TUTORIAL.INFO.10': "Naciśnij [C] i zwiększ swoje statystyki!",
    'TUTORIAL.INFO.11': "Przygotuj się na walkę z bossem!",
    'TUTORIAL.INFO.12': "Poszukajmy bossa!",

   
    'LOCATION.BOSS_ARENA.NAME': 'Arena Bossów',
    'LOCATION.VILLAGE.NAME': 'Wioska',
    'LOCATION.TUTORIAL.NAME': 'Brodzik',

    'LOCATION.LAKE.1.NAME': 'Jeziorko 1',
    'LOCATION.LAKE.2.NAME': 'Jeziorko 2',
    'LOCATION.LAKE.3.NAME': 'Jeziorko 3',
    'LOCATION.LAKE.4.NAME': 'Jeziorko 4',
    'LOCATION.LAKE.5.NAME': 'Jeziorko 5',
    'LOCATION.LAKE.6.NAME': 'Jeziorko 6',
    'LOCATION.LAKE.7.NAME': 'Jeziorko 7',
    'LOCATION.LAKE.8.NAME': 'Jeziorko 8',

    'LOCATION.BEEHIVE.NAME': 'Ul',
    'LOCATION.THE_COVE.NAME': 'Zatoka',

    'LOCATION.CAVERN.1.NAME': 'Jaskinia 1',
    'LOCATION.CAVERN.2.NAME': 'Jaskinia 2',
    'LOCATION.CAVERN.3.NAME': 'Jaskinia 3',
    'LOCATION.CAVERN.4.NAME': 'Jaskinia 4',
    'LOCATION.CAVERN.5.NAME': 'Jaskinia 5',
    'LOCATION.CAVERN.6.NAME': 'Jaskinia 6',

    


    //Items Lore
    ITEM_SHADOW_SCYTHE_LORE: "",
    ITEM_BUBBLE_TERMINATOR_LORE: "It will kill,\nIt will destroy the world,\nNo matter what you do it won`t stop!",
    ITEM_HOLY_LAUNCHER_LORE: "Holy Gaucamole!!!",



    'ITEM.SLOWING.DESCRIPTION': 'Siła spowolnienia: {SLOW_S}%\nDługość spowolnienia: {SLOW_D}s',


    'ITEM.CLICK_TO_OPEN.RIGHT': "PPM, aby otworzyć.",
    'ITEM.BAG.DESCRIPTION': "Może zawierać:",
    'ITEM.QUEST.DESCRIPTION': 'Przedmiot do zadania',
    'ITEM.UNIQUE': 'Unikat',

    'ITEM.SUMMON_SCROLL.NAME': 'Zwój przywołania ({BOSS_NAME})',
    'ITEM.SUMMON_SCROLL.DESCRIPTION': 'Ten zwój zawiera zapieczętowaną duszę <--color-grade-mythical;{BOSS_NAME}>.\nUpewnij się, że jesteś gotowy na walkę przed użyciem zwoju.\nMoże zostać użyty tylko na Arenie.',

    'ITEM.BAG.THEFATONE.NAME': '<#ff00ff>Sakwa Grubca',

    'ITEM.BAG.DEV.NAME': 'Kula skarbów dewelopera',
    'ITEM.BAG.STARTER.NAME': 'Początkowa kula skarbów',
    'ITEM.BAG.OXY_CELL.NAME': 'Kula skarbów (Oxy-Cell)',
    'ITEM.BAG.TRIMAGO.NAME': 'Kula skarbów (Trimago)',
    'ITEM.BAG.THE_FAT_ONE.NAME': 'Kula skarbów (Grubiec)',
    'ITEM.BAG.WATERFLY.NAME': 'Kula skarbów (Ważkopływ)',
    'ITEM.BAG.BUBBLEBEE.NAME': 'Kula skarbów (Bąbelkowa pszczoła)',
    'ITEM.BAG.FROGO.NAME': 'Kula skarbów (Frogo)',
    'ITEM.BAG.AQUAMANTULA.NAME': 'Kula skarbów (Aquamantula)',
    'ITEM.BAG.CELLTIPEDE.NAME': 'Kula skarbów (Celltipede)',

    'ITEM.ESSENCE_EXTRACTOR.NAME': 'Ekstraktor esencji',
    'ITEM.ESSENCE_EXTRACTOR.PERMANENT.NAME': 'Trwały ekstraktor esencji',
    'ITEM.ESSENCE_GRADE.DESCRIPTION': "Zawiera potężną energię ekwipunku stopnia: {GRADE}.",
    'ITEM.ESSENCE_EXTRACTOR.DESCRIPTION': "Przenieś na przedmiot, by pobrać jego stopień.\n<--color-item-negative>Uważaj! Stopień przedmiotu wróci do normalnego!",
    'ITEM.LIQUID_OXYGEN.DESCRIPTION': "<--color-grade-rare>PPM, aby otrzymać {PRICE} Tlenu.",

    'ITEM.BLESSING_STONE.NAME': 'Kamień błogosławieństwa',
    'ITEM.BLESSING_STONE.DESCRIPTION': "Przenieś na przedmiot, aby zwiększyć jego stopień.\nMoże zostać użyty tylko na przedmiotach o stopniu: {GRADE}.",
    'ITEM.BLESSING_STONE.DESCRIPTION.2': "Przenieś na przedmiot, aby zwiększyć jego stopień.\nMoże zostać użyty tylko na przedmiotach o stopniu: {GRADE}/{GRADE2}.",

    'ITEM.BLESSING_STONE.BROKEN.NAME': 'Pęknięty kamień błogosławieństwa',
    'ITEM.BLESSING_STONE.BROKEN.DESCRIPTION': "Kamień błogosławieństwa, który stracił swoje właściwości.\nPomimo tego, nadal może być użyteczny.",

    'ITEM.CONCENTRATED_AURA.BOSS.NAME': 'Skoncentrowana aura bossów',
    'ITEM.CONCENTRATED_AURA.BOSS.DESCRIPTION': 'Skoncentrowana aura pochodząca z wnętrza rdzeni bossów.\nZawiera w sobie pokaźną energię.',

    'ITEM.CONCENTRATED_AURA.NAME': 'Skoncentrowana aura',
    'ITEM.CONCENTRATED_AURA.DESCRIPTION': 'Przenieś na swój Rdzeń, aby zwiększyć jego stopień.\nMoże zostać użyty tylko na rdzeniach o stopniu {GRADE}.',

    'ITEM.OXYGEN.NAME': 'Tlen',
    'ITEM.LIQUID_OXYGEN.NAME': 'Płynny tlen',

    'ITEM.APPEARANCE_BOX.NAME': 'Tajemnicza Skrzynia Strojów',
    'ITEM.APPEARANCE_BOX.DESCRIPTION': 'PPM, aby zyskać jedną z poniższych Skrzyń Strojów:',

    'ITEM.APPEARANCE_BOX.FIXED.NAME': 'Skrzynia Strojów - {TYPE}',

    'ITEM.ENCHANT.LOCK.NAME': '<gray>Zablokowany slot',
    'ITEM.ENCHANT.GEM.AD.NAME': 'Zaczarowany klejnot (Atak)',
    'ITEM.ENCHANT.GEM.HP.NAME': 'Zaczarowany klejnot (Życie)',
    'ITEM.ENCHANT.GEM.DEF.NAME': 'Zaczarowany klejnot (Obrona)',
    'ITEM.ENCHANT.GEM.SPD.NAME': 'Zaczarowany klejnot (Prędkość)',
    'ITEM.ENCHANT.GEM.CHARGE.NAME': 'Zaczarowany klejnot (Ładunki)',
    'ITEM.ENCHANT.GEM.AD.P.NAME': 'Zaczarowany klejnot (Atak %)',
    'ITEM.ENCHANT.GEM.AS.NAME': 'Zaczarowany klejnot (Prędkość ataku)',

    'ITEM.HOLY_STONE.BULLET.NAME': 'Święty kamień (Pociski)',
    'ITEM.HOLY_STONE.ATTACK_SPEED.NAME': 'Święty kamień (Prędkość ataku)',
    'ITEM.HOLY_STONE.RANGE.NAME': 'Święty kamień (Zasięg ataku)',

    'ITEM.ENCHANT.GEM.DESCRIPTION': 'Przenieś na przedmiot, aby go wzmocnić.',

    'ITEM.ENCHANT.SAPPHIRE.NAME': 'Szafir',
    'ITEM.ENCHANT.RUBY.NAME': 'Rubin',
    'ITEM.ENCHANT.EMERALD.NAME': 'Szmaragd',
    'ITEM.ENCHANT.TOPAZ.NAME': 'Topaz',


    'ITEM.THE_VIRTUOSO.NAME': 'Wirtuoz',
    'ITEM.THE_VIRTUOSO.LORE': 'Nigdy nikogo nie zranił.\nTo spektakl zabija.',
    'ITEM.THE_VIRTUOSO.DESCRIPTION': 'Co czwarty strzał zadaje 4-krotnie większe obrażenia.\nMoże przebić do 4 jednostek.',

    'ITEM.MACHINE_GUN.BASE.NAME': 'Bąbelkowe działo maszynowe I',


    'ITEM.BAMBOO_STICK.NAME': 'Bambusowy kij',
    'ITEM.BAMBOO_STICK.LORE': 'Legenda głosi, że w rękach profesjonalisty\njest potężniejszy niż Zaklęty Miecz.',
    'ITEM.BAMBOO_STICK.DESCRIPTION': 'Efekt naładowania: Przywraca 1 PŻ wraz z trafieniem przeciwnika.',

    'ITEM.VIVISCISSORS.NAME': 'Złote nożyczki Vivi',
    'ITEM.VIVISCISSORS.DESCRIPTION': 'Wysokiej jakości nożyczki ze szczerego złota.\nWłaścicielka będzie wniebowzięta, gdy otrzyma je z powrotem.',

    'ITEM.CORE.BASE.NAME': 'Życiodajny Rdzeń',
    'ITEM.CORE.BASE.DESCRIPTION': 'Podstawowy Rdzeń podtrzymujący najważniejsze funkcje życiowe.',
    'ITEM.CORE.BASE.LORE': 'Rdzeń stanowi źródło życia każdej żywej istoty.\nTo w nim przechowywane są wspomnienia.\nNie wyrzekaj się go.',

    'ITEM.WATER_TWISTER.NAME': 'Wodny wir',
    'ITEM.WATER_TWISTER.DESCRIPTION': 'Naciśnij [{KEY}], aby przywołać wodny wir.\nPrzeciwnicy, którzy przez niego przejdą,\nzostaną spowolnieni o {SLOW_S}% na {SLOW_D}s.',

    'ITEM.INFINITY_STONE.SPACE.NAME': 'Kamień Przestrzeni Nieskończoności',
    'ITEM.INFINITY_STONE.SPACE.DESCRIPTION': 'Pozwala się przenieść do każdego oczyszczonego pokoju.\nNaciśnij [{KEY}], aby mignąć w stronę kursora.\Dystans: {R}\nCzas odnowienia: {CD}s.',
    'ITEM.INFINITY_STONE.SPACE.LORE': 'Kamień, który przybył do nas z innego uniwersum.\nTylko nieliczni są w stanie okiełznać jego moc.',

    'ITEM.ENCHANT.CRYSTAL.AD.NAME': 'Zaczarowany kryształ (Atak)',
    'ITEM.ENCHANT.CRYSTAL.DEF.NAME': 'Zaczarowany kryształ (Obrona)',
    'ITEM.ENCHANT.CRYSTAL.BLOCK.NAME': 'Zaczarowany kryształ (Blok)',
    'ITEM.ENCHANT.CRYSTAL.MASTERY.NAME': 'Zaczarowany kryształ (Siła żywiołów)',
    'ITEM.ENCHANT.CRYSTAL.DESCRIPTION': 'Przenieś na akcesoria, aby je wzmocnić.',
    'ITEM.ENCHANT.CRYSTAL.BLOCK.DESCRIPTION': 'Szansa na blok nie może przewyższać 50%.\nPrzenieś na akcesoria, aby je wzmocnić.',
    'ITEM.ENCHANT.CRYSTAL.MASTERY.DESCRIPTION': 'Siła żywiołów zwiększa obrażenia od ataków żywiołami.\nPrzenieś na akcesoria, aby je wzmocnić.',

    'ITEM.ROCKET_LAUNCHER.SPARK.NAME': 'Wyrzutnia iskier I',
    'ITEM.ROCKET_LAUNCHER.1.NAME': 'Wyrzutnia rakiet I',

    'ITEM.PET.FROGO.NAME': 'Mały Frogo',
    'ITEM.PET.FROGO.DESCRIPTION': 'Przywołuje malutkiego Frogo do pomocy w walce.',

    'ITEM.RIFLE.1.NAME': 'Bąbelkowy karabin I',

    'ITEM.CANON.BUBBLE.1.NAME': 'Bąbelkowe działo I',
    'ITEM.CANON.BUBBLE.2.NAME': 'Bąbelkowe działo II',


    'ITEM.ICICLE.1.NAME': 'Lodowa kula I',

    'ITEM.FLOW_IN_BOTTLE.NAME': 'Przypływ w butelce',
    'ITEM.FLOW_IN_BOTTLE.DESCRIPTION': 'Naciśnięcie [PPM] spowoduje wykonanie zrywu w danym kieurnku.',

    'ITEM.RING.PHYSICAL.NAME': 'Tajemniczy pierścień',

    'ITEM.NECKLACE.REGENERATION.NAME': 'Tajemniczy Naszyjnik',
    'ITEM.NECKLACE.REGENERATION.DESCRIPTION': 'Przywraca {REGEN} PŻ za każdym razem, gdy oczyścisz pokój.',


    'ITEM.HONEY.COMB.NAME': 'Plaster miodu',
    'ITEM.HONEY.COMB.DESCRIPTION': 'Super słodki plaster miodu wykonany przez Bąbelkowe pszczoły.\nKto wie, co może się stać,\njeśli oddasz im go z powrotem.\n\nPPM aby przywrócić {REGEN}PŻ w ciągu {TIME}s.',

    'ITEM.HONEY.PIECE.NAME': 'Kawałek miodu',
    'ITEM.HONEY.PIECE.DESCRIPTION': 'Super słodki kawałek miodu.\n\PPM aby przywołać Miodową kroplę.',

    'ITEM.THE_ECHO.NAME': 'Echo',





















    'SKIN.BASE.NAME': 'Podstawowy',
    'SKIN.BASE.F.NAME': 'Podstawowy (K)',

    'SKIN.KITSUNE.NAME': 'Kitsune',
    'SKIN.KITSUNE.ANGELIC.NAME': 'Anielska Kitsune',
    'SKIN.KITSUNE.SHADOWFLAME.NAME': 'Kitsune mrocznego ognia',

    'SKIN.REAPER.NAME': 'Żniwiarz',
    'SKIN.CATGIRL.NAME': 'Kocica',



    //npc
    NPC_MERCHANT_NAME: 'Handlarz',


    'DIALOG.EXIT': 'Narazie.',

    'NPC.SENSEI.NAME.0': 'Sensei Wii',
    'NPC.SENSEI.NAME.1': 'Sensei Jhones',
    'NPC.SENSEI.NAME.2': 'Sensei Yan Ying',
    'NPC.SENSEI.NAME.3': 'Sensei Splitter',

    'NPC.SENSEI.DIALOG.1' :"Jestem pewny, że ta lekcja walki nauczyła cię... walki.",




    'NPC.MINER.NAME.0': 'Górnik Bob',
    'NPC.MINER.NAME.1': 'Górnik Jeff',
    'NPC.MINER.NAME.2': 'Górnik Hugo',
    'NPC.MINER.NAME.3': 'Górnik Pablo',


    'NPC.MAGE.NAME.0': 'Sabrine',
    'NPC.MAGE.NAME.1': 'Twilight',
    'NPC.MAGE.NAME.2': 'Megan',
    'NPC.MAGE.NAME.3': 'Selene',


    'NPC.MINER.DIALOG.0': 'Hej, ho! Hej, ho! Do pracy by się... A ty coś za jeden? Zresztą, nieważne. Muszę wykopać ten klejnot. Potrzymaj latarkę. (Trzy machnięcia kilofem później)\
    Ale ty mi to świecisz, czy sobie?! Wybacz, za dużo pracy na dziś. Jestem {NAME}.',
        'NPC.MINER.DIALOG.0.OPTION.1': 'Miło poznać.',
    'NPC.MINER.DIALOG.1': 'Masz dla mnie jakieś błyskotki?',
        'NPC.MINER.DIALOG.1.OPTION.1': 'Pokaż mi swoje towary!',

    'NPC.MAGE.DIALOG.0' :"Uważaj, gdzie stąpasz! Trafiłeś na {NAME}, największą czarodziejkę wszechczasów! (upuszcza kij na podłogę) Oj! Nie widziałeś tego, prawda?",
        'NPC.MAGE.DIALOG.0.OPTION.1': 'Miło poznać.',
    'NPC.MAGE.DIALOG.1' :"Próbowałam zrobić trochę heksafluoroarsenianu pentafluoroksenonu, ale przez noc zmienił się w ciekły tlen. Co poszło nie tak?",
    'NPC.MAGE.DIALOG.2' :"Nie przejmuj się bałaganem. Zrobiłam wodę gazowaną i nie przewidziałam, że gazu będzie wystarczająco, żeby wysadzić całą wieś...",
    'NPC.MAGE.DIALOG.3' :"Tamten wcześniejszy wybuch? Aj, to nic takiego! Pomyliłam składniki...",



    'NPC.STYLIST.NAME': 'Vivi',
    'NPC.STYLIST.DIALOG.0': 'Ojej, wreszcie widzę jakąś przyjazną twarz. Utknęłam tutaj z tą wielką... rzeczą, na cały miesiąc!! Jestem Vivi. Miło cię poznać, skarbie!',
        'NPC.STYLIST.DIALOG.0.OPTION.1': 'Przyjemność po mojej stronie.',
    'NPC.STYLIST.DIALOG.1': 'O co chodzi, cukiereczku?',
    'NPC.STYLIST.DIALOG.2': 'Jak leci, moje kochanie?',


    'NPC.STATUE.NAME': 'Starożytna Statua',
    'NPC.STATUE.DIALOG.0': '(Niepokojąco wyglądająca statułka...)',
    'NPC.STATUE.DIALOG.0.OPTION.1': 'Dotknij...',

    'NPC.STATUE.DIALOG.1': '(Czujesz niepokojącą aurę emanującą z kamiennej postaci)',
    'NPC.STATUE.DIALOG.1.OPTION.1': 'Arena Bossów',
    'NPC.STATUE.DIALOG.1.OPTION.2': 'Ofiara',

    'NPC.STATUE.DIALOG.SACRIFICE': 'Na pewno chcesz ofiarować cały swój Tlen?',
    'NPC.STATUE.DIALOG.SACRIFICE.OPTION.1': 'Tak nakazuje obyczaj!',
    'NPC.STATUE.DIALOG.SACRIFICE.EXIT': 'Nie no, aż tyle to nie.',





    'ENTITY.BUBBLE.NAME': 'Bąbelek',

    'ENTITY.BUBBLE_FORMATION.1.NAME': 'Bąbelkowa formacja I',
    'ENTITY.BUBBLE_FORMATION.2.NAME': 'Bąbelkowa formacja II',
    'ENTITY.BUBBLE_FORMATION.3.NAME': 'Bąbelkowa formacja III',
    'ENTITY.BUBBLE_FORMATION.4.NAME': 'Bąbelkowa formacja IV',
    'ENTITY.BUBBLE_FORMATION.5.NAME': 'Bąbelkowa formacja V',

    'ENTITY.TRIM.NAME': 'Trim',
    'ENTITY.TRIM.FAT.NAME': 'Gruby Trim',
    'ENTITY.TRIM.FORMATION.0.NAME': 'Formacja Trimów I',




    'ENTITY.TADPOLE.LAKE.NAME': 'Kijanka Jeziorna',
    'ENTITY.FROG.LAKE.NAME': 'Żaba Jeziorna',
    'ENTITY.FROG.LAKE.GREEN.NAME': 'Zielona Żaba Jeziorna',
    'ENTITY.FROGO.NAME': 'Frogo',
    'ENTITY.FROGO.PET.NAME': 'Mały Frogo',

    'ENTITY.OXY_CELL.NAME': 'Ogniwo Tlenowe',
    'ENTITY.TRIMAGO.NAME': 'Trimago',
    'ENTITY.THE_FAT_ONE.NAME': 'Grubel',

    'ENTITY.WATERFLY.NAME': 'Ważkopływ',

    'ENTITY.HONEY.CHUNK.NAME': 'Miodowy kawałek',
    'ENTITY.HONEYCOMB.NAME': 'Plaster miodu',
    'ENTITY.BEE.LAKE.LITTLE.NAME': 'Mała Jeziorna Pszczoła',
    'ENTITY.BEE.LAKE.LARGE.NAME': 'Jeziorna Pszczoła',
    'ENTITY.BUBBLEBEE.NAME': 'Bąbelkowa pszczoła',
    'ENTITY.BUBBLEBEE.QUEEN.NAME': 'Królowa bąbelkowych pszczół',

    'ENTITY.SPIDER.LAKE.NAME': 'Pająk Jeziorny',
    'ENTITY.SPIDER.LITTLE.LAKE.NAME': 'Mały Pająk Jeziorny',
    'ENTITY.SPIDER.DASHING.LAKE.NAME': 'Skaczący Pająk Jeziorny',

    'ENTITY.SPIDER.LAKE.DESCRIPTION': 'Ten przeciwnik potrafi składać jajeczka. Jeśli szybko ich nie zniszczysz, w pokoju zaroi się od mniejszych pająków tego typu.\n\nWtedy umrzesz.',
    'ENTITY.SPIDER.LITTLE.LAKE.DESCRIPTION': 'Ten przeciwnik jest bardzo szybki. Gdy podejdziesz zbyt blisko, skoczy na ciebie i nie odpuści. Jeśli pozwolisz mu żyć wystarczająco długo, urośnie i zacznie składać jajeczka.\n\nWtedy umrzesz.',
    'ENTITY.SPIDER.DASHING.LAKE.DESCRIPTION': 'Ten przeciwnik jest dość szybki. Gdy go zaatakujesz, ten zacznie na ciebie szarżować. Jeśli cię trafi, zostaniesz ogłuszony.\n\nWtedy najprawdopodobniej umrzesz.',

    'ENTITY.SPIDER.LAKE.QUEEN.NAME': 'Aquamantula',
    'ENTITY.SPIDER.LAKE.QUEEN.DESCRIPTION': 'Olbrzymia królowa pająków. Chętnie nakarmi tobą swoje potomstwo. Potrafi składać jajeczka, a rozwścieczona szarżuje. Spróbuj zafundować jej bliskie spotkanie ze ścianą lub spowolnić. Inaczej zbyt wiele z ciebie nie zostanie.\n\nCzyli umrzesz.',

    'ENTITY.CELLTIPEDE.NAME': 'Celltipede',

    'ENTITY.COVE.FISH.POISON.NAME': 'Jadowity Strażnik Zatoki',
    'ENTITY.COVE.FISH.FIRE.NAME': 'Płomienny Strażnik Zatoki',
    'ENTITY.COVE.FISH.ICE.NAME': 'Mrożący Strażnik Zatoki',
    'ENTITY.THE_COVE_GUARDIAN.NAME': 'Strażnik Zatoki',



    'ENTITY.BAT.NAME': 'bieski Toperz',
    'ENTITY.BAT.FAT.NAME': 'Gruby bieski Toperz',
    'ENTITY.BAT.BLIND.NAME': 'Ślepy bieski Toperz',
    'ENTITY.ZUBATH.NAME': 'Zubath',











    'QUEST.COMPLETE': 'Ukończono',
    'QUEST.ACCEPT': 'Akceptuj',
    'QUEST.DECLINE': 'Odrzuć',



    'QUEST.LEVELUP.1.NAME': 'Droga ku potędze I',
    'QUEST.LEVELUP.1.DESCRIPTION': 'W podwodnym świecie czeka na ciebie pełno niebezpieczeństw. Aby stawić im czoła, musisz nabrać doświadczenia. Osiągnij poziom 10 i wróć do Senseia.',
    'QUEST.LEVELUP.1': 'Nasz świat jest pełen niebezpieczeństw. Aby w nim przetrwać, musisz nabrać doświadczenia. Oto, co masz zrobić:\n-Osiągnij poziom 10 i wróć do mnie.',
    'QUEST.LEVELUP.1.COMPLETE': 'Zajęło ci to dłużej niż zakładałem, ale cóż, nie każdy się nadaje na superbohatera. Oto twoja nagroda:\n-Bambusowy Kij',

    'QUEST.LEVELUP.2.NAME': 'Droga ku potędze II',
    'QUEST.LEVELUP.2.DESCRIPTION': 'Sensei nadal uważa cię za nowicjusza. Osiągnij poziom 20 i udowodnij mu, że się myli.',
    'QUEST.LEVELUP.2': 'Nadal jesteś żółtodziobem, przykra sprawa. Oto, co masz zrobić:\n-Osiągnij poziom 20 i wróć do mnie.',
    'QUEST.LEVELUP.2.COMPLETE': 'Wolniej to można chyba już tylko stać. Spróbuj tyle nie umierać, to pójdzie szybciej. Ech, mimo wszystko wykonałeś zadanie. Oto twoja nagroda.',

    'QUEST.LEVELUP.3.NAME': 'Droga ku potędze III',
    'QUEST.LEVELUP.3.DESCRIPTION': 'Żyłeś w przekonaniu, że zaczynasz coś znaczyć. Sensei twierdzi inaczej. Osiągnij poziom 30 i pokaż mu, że jest inaczej.',
    'QUEST.LEVELUP.3': 'Osiągnąłeś już trochę - trochę za mało. Oto, co masz zrobić:\n-Osiągnij poziom 30 i wróć do mnie.',
    'QUEST.LEVELUP.3.COMPLETE': 'Żółwie wykonały to zadanie szybciej, i to nie te ninja. Jestem zawiedziony, ale liczę, że to ci pomoże. Oto twoja nagroda.',



    'QUEST.VIVISCISSORS.NAME': 'Kłopoty Vivi',
    'QUEST.VIVISCISSORS.DESCRIPTION': 'Podczas ucieczki przed pająkami, urocza stylistka Vivi zgubiła swoje ukochane nożyczki. Udaj się do lokalizacji Jeziorko 7 i odzyskaj przedmiot.',
    'QUEST.VIVISCISSORS': 'Dobrze cię widzieć, skarbie! Nie uwierzysz, co mi się przytrafiło! Podczas jednej z podróży te wstrętne pająki zaczęły mnie gonić! \
        W pośpiechu zgubiłam moje najlepsze nożyczki. Proszę, odnajdź je!\n-Udaj się do lokalizacji Jezioro 7 i odzyskaj przedmiot.',

    'QUEST.VIVISCISSORS.COMPLETE': 'Och! Udało ci się! Nawet nie wiesz, jaka jestem szczęśliwa! Oto twoja nagroda:\n-XP: 1.500\n-Tlen: 20.000\n-Unknown Appearance Box',









    'DEATH_QUOTE.CORE_DROP': 'Dosłownie wyjąłeś swoje serce i je wyrzuciłeś...',












    //GUI
    OXYGEN: 'Tlen',
    WORLD_MAP: 'Mapa świata'
};Main.Initialize();